\documentclass{article}

\begin{document}
\begin{abstract}
  This is a note on the new plugin mechanism added to ggobi. The goal
  is to allow optional facilities to be loaded into the running ggobi
  application.
 This mechanism allows us and other users to provide extensions
 to ggobi. These  might introduce new plot types, ways
 to read data or auxillary tools to view and manipulate
 data.

\end{abstract}

\section{Motivation}

\section{Adding Controls \& Menus}

\section{Hooks and Events}
Allow the plugin to write to the stored data
in the ggobirc.

\section{API}

\section{Example}


\section{Potential Plugin Projects}

\begin{itemize}

\item[Data grid]
Extend the data-grid to 
allow color-coding the rows, identification,
editing, etc.

\item[Categorical variable data plots]

\end{itemize}

\section{Input Plugins}
It is simply a fact that data will be stored in a variety of different
formats. Since GGobi reads data only in a couple of specific formats,
the onus is on the user to translate their data into one of these
formats and then run GGobi. This can be, at the least, tedious and at
worst infeasible if the data is available only as dynamic stream.  To
deal with this, we provide an input plugin mechanism that allows one
to extend the data sources from which GGobi can read its input.
Essentially, one can write a small amount of code that reads
data in a particular manner and add have GGobi use this 
by registering it as an input plugin.

The basic idea of the input plugin mechanism is as follows.  One
registers the plugin within the \XMLTag{plugins} tag in the
initialization file.  The format of the XML entry for an input plugin
is defined in the DTD for the initialization file and illustrated in
figure \ref{fig:input}.

\begin{figure}[htbp]
  \begin{center}
    \leavevmode
\begin{verbatim}
    
\end{verbatim}
    \caption{Input plugin specification}
  \end{center}
\end{figure}

The simplest thing to do is copy the \file{plugin.xml} file from one
of the existing input plugin directories and edit that.

There are currently three input plugins available for GGobi.  One is a
simple test of the mechanism that generates a dataset with $3$
variables and $10$ observations.  The values are generated by the C
routine \Croutine{rand} just for variety.

The more useful plugins are the Postgres and MySQL input plugins.
Each of these allows the user to connect to a relational database
management server, either running locally or remotely on another
machine, and issue an SQL query to get the data for GGobi to display.
The information about the location of the database server, the name of
the database, the user login name and password, the SQL query, etc.
are typically entered interactively via a simple GUI provided by
GGobi.  Alternatively, if the \SharedLib{Properties} library is
available, some or all of these values can be specified in a file.
More information is available in \file{DBMS.pdf}.


It would be useful to have a plugin for reading 
\begin{itemize}
\item Gnumeric spreadsheets,
\item Excel spreadsheets,
\item HDF5 files,
\item S-Plus and R data frames,
\item Oracle databases,
\item data serialized by other applications.
\end{itemize}

\subsection{Developing an Input Plugin}

The \dir{Postgres} and \dir{TestInput} directories in the
\dir{plugins} directory provide examples of two different styles of
input plugin. The Postgres plugin is more complex because it is
event-driven, because it presents a dialog looking for input from the
user before reading the data.  In this way, the GGobi instance is
created and displayed with no data and then populated after the data
is read. This is a little more indirect than the TestInput plugin.
For that plugin, the data is read before the GGobi instance is
displayed and this behaves just like reading data from an XML or ASCII
file.


\subsection{Technical Issues about Input Plugins.}
When GGobi starts, it processes the command line arguments and then the
initialization file.  It is at this point that we register the
plugins, and specifically the input plugins.  Next we attempt to load
the data.  The heart of this from the perspective of identifying the
plugin is \Croutine{fileset_generate} in \file{make_ggobi.c}.  This is
responsible for creating an instance of the \CStruct{InputDescription}
with the appropriate data for reading the data.  The user identifies
the plugin by providing a value for the \flag{-datamode}.
\Croutine{fileset_generate} reads this value (stored in the session
options) by looking through the known input formats.




\section{Issues}
Configuration

Debugging dynamically loaded code.

The plugin mechanism requires XML.

\end{document}
