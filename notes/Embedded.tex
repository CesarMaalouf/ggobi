This describes the basic setup for embedding GGobi/XGobi in another
application.  It relates specifically to R and S, but should be of
some value for other applications.

The document describes the necessary structural support for creating
an embeddable facility.  Next, it describes the API for communicating
with this embedded application.  The API allows the user to query the
current state of the ggobi session, and also programmatically set much
of the state.


\section{Embedding Structure}
The first thing we need is the ability to simply create the interface.
Having GGobi allow creation of the interface without any data (either
a file or actual values) allows us to create the interface and then
specify the data. This allows us to treat the specification
of the data as a second step in the initialization
and implement that stage using a user-level (in the R/S language)
function. Hence we don't have to tie the initialization
to a file name or dataset.

The ggobi session is initialized via the routine \Croutine{init()}.
This takes the name of a file.  Alternatively, we can pass a matrix of
data and variable names to the routine \Croutine{}.


Ideally we would be able to use the different elements of ggobi
independently. For example, we might create an ash display and
separately a scatterplot.  This requires the separation of global
variables.

\section{Event-Loop Integration}
One of the key aspects of embedding a GUI tool into an environment
such as R or S is that we can merge the event models for the two.  R
and S are interactive environments which wait for input from the user
and operate within a read-eval command loop.  The X11 device and all
other sources of events are merged with this via the system
\Croutine{select} routine. To allow this, the event operations must
support the basic operations of 
\begin{itemize}
\item providing a file descriptor on which input can be detected
to indicate the existence of events of interest for that 
source
\item consuming all the available events without blocking
waiting for more.
\end{itemize}
The X11 library provides these facilities via
the \CPPMacro{ConnectionNumber} macro
and \Croutine{XNextEvent},
\Croutine{XtDispatchEvent}

For GTK+ and GDK, the following snippet of code
can be used as an event handler procedure with
the R input source management.
\begin{verbatim}
  while(gdk_events_pending()) {
    gtk_main_iteration_do(false);
    ctr++;
  }
\end{verbatim}
The routine is registered for the file descriptor computed from
\CPPMacro{ConnectionNumber} called with the value of
\Cvariable{gdk_display}. This latter variable is available by
including \file{gdk/gdkx.h}. ({\red Something will need to be done for
windows.})


At present, the above code does not quite work to handle all events.
Specifically, when one sets the dataset programmatically,
the variable selection panel is not updated appropriately.
The widgets are created, but now exposed.


Timer functions need to be added to the R, not Glib's, event loop.  (R
needs to handle these timers along with the select call.)


\section{Warnings}
Output that goes to standard error in GGobi should now go through
\Croutine{GGobi_Warning}.  This allows R/S to report it in its
traditional way, namely via the \SFunction{warnings}.

\Croutine{g_printerr} and \Croutine{g_print} need to be changed.


\section{Installation}
The makefile contains a rule for creating a shared library,
\SharedLibrary{libGGobi.so}.


\section{Calling R functions}
Example for smoothing,
identify, etc.

Closures for mutable state and local variables.




\section{API Routines}

\subsection{getData}
Since the user can load data in a non-programmatic way, there is an
opportunity for XGobi to have data that has not been introduced to the
R/S session.  As a result, we need a mechanism to retrieve the current
values of the active data set.  This is especially important if we
allow the data to be edited in any way.

The return value is a matrix of numeric values containing the data
values.  The names of the rows and columns are the XGobi row labels
and variable names respectively.


\subsection{getColors}


\subsection{set}

\subsection{getGlyphs}


\subsection{getSelectedIndices}
This needs attention to access the correct
variable in the xgobi structure.
