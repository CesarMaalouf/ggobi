\documentclass{article}
\input{WebMacros}
\usepackage{fullpage}
\usepackage{pstricks}
\input{pst-beta}

\def\SFunction#1{{\texttt{\red #1}}}

\def\note#1{\textsl{\red #1}}

\title{Using the R-GGobi Link}
\author{Andreas Buja \\
Di Cook \\
Deborah Swayne \\
Duncan Temple Lang}
\begin{document}
\begin{abstract}
  In this document, we describe some of the features of the R-GGobi
  link. We illustrate some of the common uses and the different
  functions to both query and modify the state of the GGobi.  This
  serves as a form of a tutorial.
\end{abstract}

\maketitle{}


\section{Getting Started}
The first thing to do is create a ggobi instance.
Each instance is associated with a particular dataset.
There are two ways to create this.
One specifies the name of the file to read
and the other takes a data frame or matrix in R.
The first takes a string, such as
\begin{verbatim}
 > ggobi("../data/flea")
\end{verbatim}
The second form passes the data frame as the first argument.
\begin{verbatim}
 > data(mtcars)
 > ggobi(mtcars)
\end{verbatim}
Both of these create ggobi in the same manner as the stand-alone
application via the command line.  One can pass a vector of strings as
arguments which are processed as command line arguments.  When
specifying the name of a file, one can specify whether this is XML,
ASCII or binary.

\begin{verbatim}
> ggobi()
> ggobi.setData(data.frame(a=rnorm(100), b=runif(100))
\end{verbatim}

We can create a ggobi instance with no data and set the data in a
later command.
\begin{verbatim}
 > ggobi()
\end{verbatim}


The opposite of creating a ggobi instance is closing its displays and
removing it from the session.  This is done via
\SFunction{ggobi.close}.  As usual, the particular instance to operate
on is identified by the \SArg{.gobi} argument and defaults to the
default instance.

\note{I have seen this crash, but can't yet see why.}


At any point, the dataset can be augmented or reduced by
adding or removing variables.
\begin{verbatim}
 ggobi.addVariable()
 ggobi.removeVariable()
\end{verbatim}

\section{}


\section{System Values}
The representation of points or observations within a plot is
controlled by its glyph.  Each observation has its own glyph
setting. This controls the type  and size of glyph.
(In the near future, these may be indepdently settable across
sub-plots.)
The possible values for the glyph type and size
are fixed for a ggobi session.
They can be queried via the functions
\SFunction{ggobi.getGlyphTypes}
and 
\SFunction{ggobi.getGlyphSizes}

\begin{verbatim}
> ggobi.getGlyphTypes()
 +  x or fr oc fc  . 
 1  2  3  4  5  6  7 
> ggobi.getGlyphSizes()
[1] 0 1 2 3 4 5 6 7 8
\end{verbatim}

Each ggobi instance has its own color map.  The color of each
observation is specified as a row index into this colormap.  Each row
of this map or table is an RGB color value.

\begin{verbatim}
> ggobi.getColorMap()
         Red        Green      Blue
1  1.0000000 0.0008697642 0.0000000
2  1.0000000 0.2699931334 0.0000000
3  1.0000000 0.5499961852 0.0000000
4  1.0000000 0.8399938964 0.0000000
5  1.0000000 1.0000000000 0.0000000
6  0.0000000 0.7499961852 1.0000000
7  0.5099870 0.4399938964 1.0000000
8  0.6000000 0.8000000000 0.2000000
9  0.0000000 0.9799954223 0.6000000
10 0.7299916 0.3299916075 0.8299992
\end{verbatim}

One can set the color map with the function
\SFunction{ggobi.setColorMap}.  To change, for example, the second row
to the values $.8, .2. 3$, we can use the following steps
\begin{verbatim}
 mp <- ggobi.getColorMap()
 mp[2,] <- c(.8,.2,.3)
 ggobi.setColorMap(mp)
\end{verbatim}



\section{Brushing}
One can determine which observations are contained within the current
brushing region with the function
\SFunction{ggobi.getSelectedIndices}.  This returns a vector
containing the (unordered) indices of the observations in the dataset
that have been selected.  
(For efficiency purposes, the labels of the observations
are not returned with the vector. This can be easily changed.)

The function \SFunction{ggobi.isObservationSelected} returns a logical
vector with as many elements as there are observations in the dataset.
Each element indicates whether the observation is within the current
brushing region.




\section{Programmatically Configuring a View} 
One can (will be able to) set the brush location and size directly via
a function call.  Additionally, one can control the glyph type, size
and color for the points under the brush.

One can use the programmatic interface to capture views and replay
them.  For example, we might want to display the effect of identifying
different groups of observations.
\begin{verbatim}
 views <- list(c(20,20, 100,100), c(400,300), c(300,150,40,40))
 ggobi.setMode("Brush")
 for(i in views) {
   ggobi.setBrush(i)
   print(ggobi.getSelectedIndices())
   prompt()
 }
\end{verbatim}


\section{Managing Windows}
Because one can easily create multiple ggobi instances and many
displays within each instance, managing the display windows can be
difficult. Accordingly, we provide some facilities for
programmatically controlling them.  The first set work on the
displays.  The functions \SFunction{ggobi.getActivePlot} and
\SFunction{ggobi.setActivePlot} operate on either a display or a
display and sub-plot object.

Firstly, one can move one or all of the windows within a ggobi
instance to the background or foreground.  This uses the function
\SFunction{ggobi.raisePlot} and the argument \SArg{raise} indicates
whether the windows should be lowered or raised.  The former pushes
them below all the other windows on the desktop.  The latter raises
them above the other windows. The location of each window remains
unaltered, and merely its ``depth'' or stacking order is changed.

Similarly, one can iconify and de-iconify one or more windows.  The
function \SFunction{ggobi.iconify} provides this functionality via the
\SArg{icon} argument.




\section{Callbacks}

Associating R function calls with events in GGobi
is a valuable way to allow customization of the existing interactivity
provided by GGobi.  Consider an example where we have a scatterplot of
two variables X and Y.  As we identify individual points in the
scatterplot, we might want to examine the result of fitting the
regression of Y on X with that point omitted.  GGobi does not
currently provide such a facility.  However, it is trivial in R.  By
allowing one to register an R function to be called when a particular
event (the identification) occurs, we can easily arrange to update
other plots.  Given the available primitives with which we can control
ggobi or other graphics devices, we can



Clustering or model selection might serve as other examples.  The
basic idea is that we would have some data that represents the fits
for different models.  The data frame is made up of, say, 2 columns -
Model identifier (an integer) and the fit statistic (e.g. Cp, etc.).
As we identify or brush over one or more points, we want to link with
a plot in another ggobi using the indeces of the other model.  For
example, we might want to show the residuals resulting from that fit.
This is non-trivial in GGobi since the data does not correspond to the
model it employs which is a rectangular array of data.  (Again, an
object oriented approach would be convenient, but still difficult.)
Thus, we need two ggobi instances, with different but related data.
Additionally, we need a mechanism to specify linking between plots and
displays within and between ggobi instances.

Covering all such cases is not feasible in GGobi both from a
programming perspective and additionally as an issue of complexity in
the user interface.  Instead, a programmatic mechanism for ``linking''
or associating/connecting displays and or plots within displays both
between and within ggobi instances is necessary.  Furthermore, while
many of the common linking actions can be performed efficiently in
GGobi itself, allowing arbitrary R functions to be invoked for these
connection events is important to allow new styles of linking to be
explored and implemented easily.


The basic functions for performing these types of actions
is \SFunction{ggobi.setIdentifyHandler}.
\begin{verbatim}
ggobi.setIdentifyHandler(function(i) {print(i)})
\end{verbatim}
More arguments should be supplied to this function. 

We may also want to make this plot specific, thus allowing the data to
be stored in the function rather than having to be determined at
evaluation time. For example, suppose we want to know what variables
are being identified and in what ggobi.  We can create a closure with
that information in the environment.
\begin{verbatim}
 handlerTemplate <- function(x,y, ggobi) {
   handler <- function(which) {
     cat("Observation", which, "in", ggobi,"\n")    
   }

   return(handler);
 }
\end{verbatim}
Of course, we can do this for the ggobi instance
as it stands now.

To remove the handler
\begin{verbatim}
 ggobi.setIdentifyHandler(NULL)
\end{verbatim}

See IdentifyProc in ggobi.h and add the appropriate set and get for
the ggobid specific instance.  Already arrange to do callback.

We can make this slightly more flexible and efficient.  The
\SFunction{ggobi.setIdentifyHandler} can specify how many arguments
the function wants to receive.  This can be stored with the function
reference in the \Escape{user_data} field of the ggobi handler
structure. Then, when we go to invoke the function, we can determine
how many arguments to pass.  This allows some functions to avoid the
overhead of creating unecessary arguments that will never be used.  It
would be ideal if there was an easy way for the R function to access
the ``environment'' of the C-level calling routine (as is possible in
Omegahat due to the seamless access between the interpreted and native
language).


Bad things happen when we get an error in the R functions.  We must
handle this with a better jumping mechanism.


\section{API Routines}
In this section we describe the different R/S functions that one can
invoke to query and modify the state of the GGobi session.  There are
some common concepts shared between most of these functions.

Firstly, there are some global variables that are properties of the
entire ggobi system.  These are things such as the color table, the
glyph types and sizes.  These can be considered fixed, but queryable.

Within a ggobi session, one can view different datasets
simultaneously. Each dataset corresponds to its own ggobi data
instance within the single session.  (Note that this is different from
xgobi in which only one dataset could be introduced into the a
process.)

Within each ggobi instance, one can have multiple windows, also known
as displays.  Each display has one or more plots within it.  The plots
can be a
\begin{itemize}
\item $1$ variable plot
such as ASH plots,
\item  scatterplot of two variables
\item scatter matrix of 2 or more variables
\item parallel coordinates plot of $k$ variables.
\end{itemize}

This hierarchical setup is displayed in the following
figure.
\begin{center}
\pstree{\Tr{Session}}{%
 \pstree{\Tr{dataset}}{%
    \pstree{\Tr{display}}{
      \Tr{plot}
      \Tr{$\vdots$}
      \Tr{plot}
    }
 }
 \Tr{$\ldots$}
 \pstree{\Tr{dataset}}{%
    \pstree{\Tr{display}}{
      \Tr{plot}
      \Tr{$\vdots$}
      \Tr{plot}
    }
 }
}  
\end{center}

When operating with multiple datasets in the ggobi session at any one
time, it is important to identify to which instance a command should
be directed.  For example, if we wish to get information on the
variables within a particular instance of a ggobi instance, we can
call \SFunction{ggobi.getVariableNames}. However, we must
specify the ggobi instance in question. All the functions
that operate on a ggobi instance have an optional argument,
\SArg{.ggobi}, which is an integer.
If omitted, this defaults to the currently active
ggobi instance.

This allows us to send repeated commands easily to a ggobi instance.
\begin{verbatim}
> ggobi(args="../data/tes") 
> ggobi(args="../data/flea") #
> ggobi.getVariableNames()
[1] "tars1" "tars2" "head"  "aede1" "aede2" "aede3"
> setDefaultGGobi(1)
> ggobi.getVariableNames(.gobi=2)
\end{verbatim}
Additionally, commands intended for another can be directed without
setting that instance to the default.

By default, this is 
This identifies 


have multiple ggobi
instances in existence at any one time.
Each ggobi has its own


\subsection{getData}
Since the user can load data in a non-programmatic way, there is an
opportunity for XGobi to have data that has not been introduced to the
R/S session.  As a result, we need a mechanism to retrieve the current
values of the active data set.  This is especially important if we
allow the data to be edited in any way.

The return value is a matrix of numeric values containing the data
values.  The names of the rows and columns are the XGobi row labels
and variable names respectively.

Note that subsetting on a ggobi instance reference (basically an
integer returned by \SFunction{getDefaultGGobi} and \SFunction{ggobi})
works in a manner consistent with R.
\begin{verbatim}
 g <- ggobi(mtcars)
 g[1:10,]
 g[1:10, c("mpg","cyl")]
 g[1:10, 1:2]
\end{verbatim}
For large datasets and situations where one wants to extract
relatively few columns, it might be more efficient to use the
\SFunction{ggobi.getVariable} function.
This avoids copying the entire dataset into an R structure,
and works only on the specified variables.

Similarly, we have defined ggobi specific
versions of \SFunction{dim}, \SFunction{ncol},
\SFunction{nrow}, \SFunction{dimnames},
\SFunction{names}.


\subsection{getColors}


\subsection{getSelectedIndices}
This needs attention to access the correct
variable in the xgobi structure.


\subsection{getNumGGobis}
Returns the number of ggobi instances within this session.  Each ggobi
instance has its own data set. Of course, two instances may have the
same dataset, but they are independent.  We may allow them to be
linked in the future.  Again, the ability to specific which displays
and even plots within them inter- and intra- ggobi instance is most
useful in a programmatic interface.

\subsection{getDefaultGGobi}
\subsection{setDefaultGGobi}
Since there can be multiple ggobi instances, one must identify the
instance to which instructions are directed.  To simplify this, R
supports the notion of an active or default ggobi.  All functions that
refer to a ggobi instance use the default ggobi if the \SArg{.gobi}
argument is not specified.  This value is obtained via the function
\SFunction{getDefaultGGobi}.

When a new ggobi instance is created (see \SFunction{ggobi}), it
becomes the default ggobi.  One can switch the active instance to
another using the function \SFunction{setDefaultGGobi}.

The return value from \SFunction{getDefaultGGobi} is an integer which
is $1$-based.  This has class \texttt{"ggobi"}.

The value can be passed directly to the functions \SFunction{.GGobiC}
and \SFunction{.GGobiCall}.  It is automatically decremented by these
to be $0$-based, corresponding to the C routines.


\subsection{ggobi.getRowNames}
Returns the observation labels for the specified ggobi instance.

See also \SFunction{ggobi.setRowNames}.

\subsection{getSmootherFunction.ggobi}
\subsection{ggobi.setSmootherFunction}
GGobi provides different smoothing algorithms.  However, it is
impossible for it to provide all possible implementations.
To allow others to provide their own, we allow
an R function to be registered with the ggobi session
so that 


\subsection{ggobi}
This is the function that creates a ggobi instance.
One specifies the name of a file or a data frame (or matrix).
The newly created ggobi instance becomes the default

See \SFunction{setDefaultGGobi}.


\subsection{ggobi.getActivePlot}
\subsection{ggobi.setActivePlot}
Each ggobi instance has one display that is considered active and
within that display, a sub-plot on which brush and identify operations
will take effect.  This is the active plot.  These two functions
maniuplate the currently active plot.  The first returns an integer
vector identifying the display and within-display plot that is
considered active.  The second sets the active plot to the one
identified by the integer pair.  In this case, the second element can
be omitted or NA.


\subsection{ggobi.getCurrentDisplayType}
Each ggobi has a concept of an active window or display. Within each
of these displays, there is one or more sub-plots.  This function
returns the name of this active plot.  See
\SFunction{ggobi.getViewTypes}.  Also, see
\SFunction{ggobi.getActivePlot}.

At present, the sub-plots in a display are all of the same type. As a
result, the plot type is taken from the display.  When and if we allow
non-homegeneous plot types within a display, we will have to modify
how this routine is implemented.

\subsection{ggobi.getDescription}
This gives a brief description of the specified ggobi instance.  This
gives the name of the file from which the data was read, the type of
file format (e.g. xml, ascii, binary) and the dimensions of the data.

See also \SFunction{getNumGGobis}.

\subsection{ggobi.getDisplayOptions}
This returns the current settings of the values that control how new
plots are displayed.  Each ggobi instance has a set of options which
are used to create new plots.  These are logical values that govern
the appearance of these plots.  This function returns a named vector
of those values currently in existence.



\subsection{ggobi.getDisplays}
Returns a list describing each display (or window) of plots within the
specified ggobi instance.  Each element in the list identifies a
display and gives the title of the window, the type of the plot(s)
contained in the display (since they are currently homogeneous) and a
list describing each of the plots.  The plot description depends on
the type of plot. Generally it contains a list of the variables within
that plot.  This is an integer vector giving the indeces of the
variables. The names of the elements in this vector are the names of
the variables. 


What about subsets in effect when the display was created, etc.  This
doesn't really apply as the plots are updated when the set of hidden
observations is modified.  If one wanted to display different views of
the same data with a different collection of hidden variables, one
could open multiple ggobi instances.

Some of this might change when we experiment with moving these types
of attributes (color, hidden, etc.) to sub-plot instances rather than
having them globally in the ggobi instance.

\subsection{ggobi.getFileName}
Returns the name of the file from which the data in ggobi was read. If
the data was explicitly set from an R object, this returns a
description supplied to the ggobi instance. The mode
\SFunction{ggobi.getDescription()[["Data mode"]]} of the data can be
used to determine whether the

See also \SFunction{ggobi.getDescription}.

\subsection{ggobi.getGlyphs}
Return a description of the glyph
being used for each of the observations.

Unimplemented.

\subsection{ggobi.getLineSegments}
\subsection{ggobi.setLineSegments}
The first of these obtains an $r \times 2$ matrix where $r$ is the
number of line segments in the ggobi instance.  Each element contains
the indices of the observations which are connected.  The second
function sets the connected observations.  The format is similar to
the return value of \SFunction{ggobi.getLineSegments}.  A matrix with
2 columns can be supplied to identify the observations to be connected
by each line segment.  Alternatively, two integer vectors can be
supplied.  One has the option to add the specified segments to the
existing ones or replace the latter with the specified connections.

\subsection{ggobi.getVariableIndex}
This is used to map one or more names into the corresponding variable
indices used by the ggobi instance.  It uses
\SFunction{ggobi.getVariableNames} and matches each of the elements
passed to it.
The resulting values are based on a $1$-based
counting scheme and must be decremented by $1$ for
use in a \SFunction{.Call}.

\subsection{ggobi.getVariableNames}
Returns  a character vector 
containing the names of the variables
in the specified ggobi.

\subsection{ggobi.getViewTypes}
The Ggobi system supports several different plot types. This function
returns a named integer vector. The names are descriptions of the
types of plots.  The values in the vector are the symbolic constants
used within the C code to identify the plot type.  These values are
rarely used since functions to create instances of the different plot
types are available.  See \SFunction{ggobi.scatmat},
\SFunction{ggobi.scatterplot}, \SFunction{ggobi.parcoords}.

\subsection{ggobi.parcoords}
\subsection{ggobi.scatmat}
\subsection{ggobi.scatterplot}
Each of these functions creates a new display/window and adds it to
the specified ggobi instance.  Each provides a mechanism for
specifying what variables should be contained in the plot and this
provides greater specifiability than with the graphical interface.
The specification of the variables can be done either by 
name or by index.
If using names, these should match
\begin{itemize}
\item{parcoords}
This creates a Parallel Coordinates plot.
The variable
\end{itemize}





\subsection{ggobi.setData}
Specify a data frame or the name of a file

\subsection{ggobi.setDataFile}
\subsection{ggobi.setDataFrame}
This sets the dataset for the particular ggobi instance to the
contents of the dataframe.  Each column in the data frame corresponds
to an observations. The row names of the data frame are used as the
observation labels in the ggobi displays.

\subsection{ggobi.setDisplayOptions}
This controls the characteristics
of plots that are subsequently
created within the specified ggobi instance.
These control issues such as 
\begin{itemize}
\item whether lines are drawn, 
\item lines are directed or undirected
\item missing values are displayed,
\item grid lines are drawn on the plot(s),
\item axes are shown and/or centered,
\item double buffering is used,
\item the plot(s) are linked to others.
\end{itemize}



\subsection{ggobi.setRowNames}
This sets the observation identifiers for the 
specified rows in the ggobi instance dataset.
These are used in identifying points within 
plots.

The return value is a vector of the previous labels for the
specified rows/observations.





\subsection{\SFunction{ggobi.getBrushSize},
\SFunction{ggobi.setBrushSize},
\SFunction{ggobi.getBrushLocation} \&
\SFunction{ggobi.setBrushLocation}}


\subsection{\SFunction{ggobi.close}}
This destroys the specified ggobi instance, closing all its
windows/displays and the main control-panel window.


\section{Developer Functions}

\subsection{.ggobi.symbol}
This is of little or no interest to the regular user.  It is merely a
function that takes the name of a C routine and maps it to the name of
a routine in the GGobi chapter.  It does so by prefixing the name with
the ``unique'' identifier \Escape{RS_GGOBI} in an effort to avoid
symbol conflicts with other libraries.

\subsection{\SFunction{.GGobiCall} \& \SFunction{.GGobiC}}

There is an interesting ``bug'' in the \SFunction{.C} and
\SFunction{.Call} functions. If one creates a wrapper as with
\SFunction{.GGobiCall} and \SFunction{.GGobiC} and pass a named
argument, the gets symbol name of the routine being invoke becomes
corrupted.

\end{document}
