\documentclass{article}
\input{WebMacros}
\usepackage{fullpage}
\usepackage{pstricks}
\input{pst-beta}

\title{Using the R-GGobi Link}
\author{Andreas Buja \\
Di Cook \\
Deborah Swayne \\
Duncan Temple Lang}
\begin{document}
\begin{abstract}
  In this document, we describe some of the features of the R-GGobi
  link. We illustrate some of the common uses and the different
  functions to both query and modify the state of the GGobi.  This
  serves as a form of a tutorial.
\end{abstract}

\maketitle{}


\section{Getting Started}
The first thing to do is create a ggobi instance.
Each instance is associated with a particular dataset.
There are two ways to create this.
One specifies the name of the file to read
and the other takes a data frame or matrix in R.
The first takes a string, such as
\begin{verbatim}
 > ggobi("../data/flea")
\end{verbatim}
The second form passes the data frame as the first argument.
\begin{verbatim}
 > data(mtcars)
 > ggobi(mtcars)
\end{verbatim}
Both of these create ggobi in the same manner as the stand-alone
application via the command line.  One can pass a vector of strings as
arguments which are processed as command line arguments.  When
specifying the name of a file, one can specify whether this is XML,
ASCII or binary.

We can create a ggobi instance with no data and set the data in a
later command.
\begin{verbatim}
 > ggobi()
\end{verbatim}


The opposite of creating a ggobi instance is closing its displays and
removing it from the session.  This is done via
\SFunction{ggobi.close}.  As usual, the particular instance to operate
on is identified by the \SArg{.gobi} argument and defaults to the
default instance.

\note{I have seen this crash, but can't yet see why.}


At any point, the dataset can be augmented or reduced by
adding or removing variables.
\begin{verbatim}
 ggobi.addVariable()
 ggobi.removeVariable()
\end{verbatim}

\section{}


\section{System Values}
The representation of points or observations within a plot is
controlled by its glyph.  Each observation has its own glyph
setting. This controls the type  and size of glyph.
(In the near future, these may be indepdently settable across
sub-plots.)
The possible values for the glyph type and size
are fixed for a ggobi session.
They can be queried via the functions
\SFunction{ggobi.getGlyphTypes}
and 
\SFunction{ggobi.getGlyphSizes}

\begin{verbatim}
> ggobi.getGlyphTypes()
 +  x or fr oc fc  . 
 1  2  3  4  5  6  7 
> ggobi.getGlyphSizes()
[1] 0 1 2 3 4 5 6 7 8
\end{verbatim}

Each ggobi instance has its own color map.  The color of each
observation is specified as a row index into this colormap.  Each row
of this map or table is an RGB color value.

\begin{verbatim}
> ggobi.getColorMap()
         Red        Green      Blue
1  1.0000000 0.0008697642 0.0000000
2  1.0000000 0.2699931334 0.0000000
3  1.0000000 0.5499961852 0.0000000
4  1.0000000 0.8399938964 0.0000000
5  1.0000000 1.0000000000 0.0000000
6  0.0000000 0.7499961852 1.0000000
7  0.5099870 0.4399938964 1.0000000
8  0.6000000 0.8000000000 0.2000000
9  0.0000000 0.9799954223 0.6000000
10 0.7299916 0.3299916075 0.8299992
\end{verbatim}

One can set the color map with the function
\SFunction{ggobi.setColorMap}.  To change, for example, the second row
to the values $.8, .2. 3$, we can use the following steps
\begin{verbatim}
 mp <- ggobi.getColorMap()
 mp[2,] <- c(.8,.2,.3)
 ggobi.setColorMap(mp)
\end{verbatim}



\section{Brushing}
One can determine which observations are contained within the current
brushing region with the function
\SFunction{ggobi.getSelectedIndices}.  This returns a vector
containing the (unordered) indices of the observations in the dataset
that have been selected.  
(For efficiency purposes, the labels of the observations
are not returned with the vector. This can be easily changed.)

The function \SFunction{ggobi.isObservationSelected} returns a logical
vector with as many elements as there are observations in the dataset.
Each element indicates whether the observation is within the current
brushing region.




\section{Programmatically Configuring a View} 
One can (will be able to) set the brush location and size directly via
a function call.  Additionally, one can control the glyph type, size
and color for the points under the brush.


\section{Callbacks}

Associating R function calls with events in GGobi
is a valuable way to allow customization of the existing interactivity
provided by GGobi.  Consider an example where we have a scatterplot of
two variables X and Y.  As we identify individual points in the
scatterplot, we might want to examine the result of fitting the
regression of Y on X with that point omitted.  GGobi does not
currently provide such a facility.  However, it is trivial in R.  By
allowing one to register an R function to be called when a particular
event (the identification) occurs, we can easily arrange to update
other plots.  Given the available primitives with which we can control
ggobi or other graphics devices, we can



Clustering or model selection might serve as other examples.  The
basic idea is that we would have some data that represents the fits
for different models.  The data frame is made up of, say, 2 columns -
Model identifier (an integer) and the fit statistic (e.g. Cp, etc.).
As we identify or brush over one or more points, we want to link with
a plot in another ggobi using the indeces of the other model.  For
example, we might want to show the residuals resulting from that fit.
This is non-trivial in GGobi since the data does not correspond to the
model it employs which is a rectangular array of data.  (Again, an
object oriented approach would be convenient, but still difficult.)
Thus, we need two ggobi instances, with different but related data.
Additionally, we need a mechanism to specify linking between plots and
displays within and between ggobi instances.

Covering all such cases is not feasible in GGobi both from a
programming perspective and additionally as an issue of complexity in
the user interface.  Instead, a programmatic mechanism for ``linking''
or associating/connecting displays and or plots within displays both
between and within ggobi instances is necessary.  Furthermore, while
many of the common linking actions can be performed efficiently in
GGobi itself, allowing arbitrary R functions to be invoked for these
connection events is important to allow new styles of linking to be
explored and implemented easily.


The basic functions for performing these types of actions
is \SFunction{ggobi.setIdentifyHandler}.
\begin{verbatim}
ggobi.setIdentifyHandler(function(i) {print(i)})
\end{verbatim}
More arguments should be supplied to this function. 

We may also want to make this plot specific, thus allowing the data to
be stored in the function rather than having to be determined at
evaluation time. For example, suppose we want to know what variables
are being identified and in what ggobi.  We can create a closure with
that information in the environment.
\begin{verbatim}
 handlerTemplate <- function(x,y, ggobi) {
   handler <- function(which) {
     cat("Observation",which,"in", ggobi,"\n")    
   }

   return(handler);
 }
\end{verbatim}
Of course, we can do this for the ggobi instance
as it stands now.


To remove the handler
\begin{verbatim}
ggobi.setIdentifyHandler(NULL)
\end{verbatim}

See IdentifyProc in ggobi.h and add the appropriate set and get for
the ggobid specific instance.  Already arrange to do callback.

We can make this slightly more flexible and efficient.  The
\SFunction{ggobi.setIdentifyHandler} can specify how many arguments
the function wants to receive.  This can be stored with the function
reference in the \Escape{user_data} field of the ggobi handler
structure. Then, when we go to invoke the function, we can determine
how many arguments to pass.  This allows some functions to avoid the
overhead of creating unecessary arguments that will never be used.  It
would be ideal if there was an easy way for the R function to access
the ``environment'' of the C-level calling routine (as is possible in
Omegahat due to the seamless access between the interpreted and native
language).


Bad things happen when we get an error in the R functions.  We must
handle this with a better jumping mechanism.


\section{API Routines}
In this section we describe the different R/S functions that one can
invoke to query and modify the state of the GGobi session.  There are
some common concepts shared between most of these functions.

Firstly, there are some global variables that are properties of the
entire ggobi system.  These are things such as the color table, the
glyph types and sizes.  These can be considered fixed, but queryable.

Within a ggobi session, one can view different datasets
simultaneously. Each dataset corresponds to its own ggobi data
instance within the single session.  (Note that this is different from
xgobi in which only one dataset could be introduced into the a
process.)

Within each ggobi instance, one can have multiple windows, also known
as displays.  Each display has one or more plots within it.  The plots
can be a
\begin{itemize}
\item $1$ variable plot
such as ASH plots,
\item  scatterplot of two variables
\item scatter matrix of 2 or more variables
\item parallel coordinates plot of $k$ variables.
\end{itemize}

This hierarchical setup is displayed in the following
figure.
\begin{center}
\pstree{\Tr{Session}}{%
 \pstree{\Tr{dataset}}{%
    \pstree{\Tr{display}}{
      \Tr{plot}
      \Tr{$\vdots$}
      \Tr{plot}
    }
 }
 \Tr{$\ldots$}
 \pstree{\Tr{dataset}}{%
    \pstree{\Tr{display}}{
      \Tr{plot}
      \Tr{$\vdots$}
      \Tr{plot}
    }
 }
}  
\end{center}

When operating with multiple datasets in the ggobi session at any one
time, it is important to identify to which instance a command should
be directed.  For example, if we wish to get information on the
variables within a particular instance of a ggobi instance, we can
call \SFunction{ggobi.getVariableNames}. However, we must
specify the ggobi instance in question. All the functions
that operate on a ggobi instance have an optional argument,
\SArg{.ggobi}, which is an integer.
If omitted, this defaults to the currently active
ggobi instance.

This allows us to send repeated commands easily to a ggobi instance.
\begin{verbatim}
> ggobi(args="../data/tes") 
> ggobi(args="../data/flea") #
> ggobi.getVariableNames()
[1] "tars1" "tars2" "head"  "aede1" "aede2" "aede3"
> setDefaultGGobi(1)
> ggobi.getVariableNames(.gobi=2)
\end{verbatim}
Additionally, commands intended for another can be directed without
setting that instance to the default.

By default, this is 
This identifies 


have multiple ggobi
instances in existence at any one time.
Each ggobi has its own


\subsection{getData}
Since the user can load data in a non-programmatic way, there is an
opportunity for XGobi to have data that has not been introduced to the
R/S session.  As a result, we need a mechanism to retrieve the current
values of the active data set.  This is especially important if we
allow the data to be edited in any way.

The return value is a matrix of numeric values containing the data
values.  The names of the rows and columns are the XGobi row labels
and variable names respectively.

Note that subsetting on a ggobi instance reference (basically an
integer returned by \SFunction{getDefaultGGobi} and \SFunction{ggobi})
works in a manner consistent with R.
\begin{verbatim}
 g <- ggobi(mtcars)
 g[1:10,]
 g[1:10, c("mpg","cyl")]
 g[1:10, 1:2]
\end{verbatim}
For large datasets and situations where one wants to extract
relatively few columns, it might be more efficient to use the
\SFunction{ggobi.getVariable} function.
This avoids copying the entire dataset into an R structure,
and works only on the specified variables.

\subsection{getColors}


\subsection{set}


\subsection{getGlyphs}


\subsection{getSelectedIndices}
This needs attention to access the correct
variable in the xgobi structure.


\subsection{getNumGGobis}
Returns the number of ggobi instances within this session.  Each ggobi
instance has its own data set. Of course, two instances may have the
same dataset, but they are independent.  We may allow them to be
linked in the future.  Again, the ability to specific which displays
and even plots within them inter- and intra- ggobi instance is most
useful in a programmatic interface.

\subsection{getDefaultGGobi}
Return the index of the currently active or default ggobi instance.
This is the ggobi instance which receives the commands by default.


\subsection{setDefaultGGobi}

\subsection{ggobi.getRowNames}
Returns the observation labels for
the specified ggobi instance.

See also \SFunction{ggobi.setRowNames}.

\subsection{getSmootherFunction.ggobi}
\subsection{ggobi}
This is the function that creates a ggobi instance.
One specifies the name of a file or a data frame (or matrix).
The newly created ggobi instance becomes the default

See \SFunction{setDefaultGGobi}

\subsection{ggobi.getActivePlot}
\subsection{ggobi.getCurrentDisplayType}
\subsection{ggobi.getDescription}
This gives a brief description of the specified ggobi instance.  This
gives the name of the file from which the data was read, the type of
file format (e.g. xml, ascii, binary) and the dimensions of the data.

See also \SFunction{getNumGGobis}.

\subsection{ggobi.getDisplayOptions}
This returns the current settings of the values that control how new
plots are displayed.  Each ggobi instance has a set of options which
are used to create new plots.  These are logical values that govern
the appearance of these plots.  This function returns a named vector
of those values currently in existence.



\subsection{ggobi.getDisplays}
Returns a list describing each display (or window) of plots within the
specified ggobi instance.  Each element in the list identifies a
display and gives the title of the window, the type of the plot(s)
contained in the display (since they are currently homogeneous) and a
list describing each of the plots.  The plot description depends on
the type of plot. Generally it contains a list of the variables within
that plot.  This is an integer vector giving the indeces of the
variables. The names of the elements in this vector are the names of
the variables. 


What about subsets in effect when the display was
created, etc.

\subsection{ggobi.getFileName}
Returns the name of the file
from which the data in ggobi
was read. If the data was explicitly
set from 

See also \SFunction{ggobi.getDescription}.

\subsection{ggobi.getGlyphs}
\subsection{ggobi.getSegments}
\subsection{ggobi.getVariableIndex}
\subsection{ggobi.getVariableNames}
\subsection{ggobi.getViewTypes}
\subsection{ggobi.parcoords}
\subsection{ggobi.scatmat}
\subsection{ggobi.scatterplot}
\subsection{ggobi.setActivePlot}
\subsection{ggobi.setData}
\subsection{ggobi.setDataFile}
\subsection{ggobi.setDataFrame}
This sets the dataset for the particular ggobi instance to the
contents of the dataframe.  Each column in the data frame corresponds
to an observations. The row names of the data frame are used as the
observation labels in the ggobi displays.

\subsection{ggobi.setDisplayOptions}
This controls the characteristics
of plots that are subsequently
created within the specified ggobi instance.
These control issues such as 
\begin{itemize}
\item whether lines are drawn, 
\item lines are directed or undirected
\item missing values are displayed,
\item grid lines are drawn on the plot(s),
\item axes are shown and/or centered,
\item double buffering is used,
\item the plot(s) are linked to others.
\end{itemize}



\subsection{ggobi.setRowNames}
This sets the observation identifiers for the 
specified rows in the ggobi instance dataset.
These are used in identifying points within 
plots.

The return value is a vector of the previous labels for the
specified rows/observations.

\subsection{setSmootherFunction.ggobi}




\subsection{ggobi.symbol}
This is of little or no interest to the regular user.  It is merely a
function that takes the name of a C routine and maps it to the name of
a routine in the GGobi chapter.  It does so by prefixing the name with
the ``unique'' identifier \Escape{RS_GGOBI} in an effort to avoid
symbol conflicts with other libraries.

\end{document}
