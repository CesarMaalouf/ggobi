void
set_sph_tform_tp ()
{
   int j;
   for (j=0; j<xg->nsph_vars; j++)
    tform_tp[xg->sph_vars[j]].tform2 = SPHERE;
}

int
check_sph_on (int nsphvars, int *sphvars)
{
   int j, indic=1;
   for (j=0; j<nsphvars; j++) {
      if (tform_tp[sphvars[j]].tform2 != SPHERE)
        indic=0;
   }
   return(indic);
}

void
get_sph_vars (xgobidata *xg)
{
  int j, k;
  Boolean state;

  xg->nsph_vars = 0;
  for (j=0; j<xg->ncols-1; j++) {
    XtVaGetValues (var_cbox[j], XtNstate, &state, NULL);
    if (state)
      xg->sph_vars[xg->nsph_vars++] = j;
  }
}

void
set_sph_labs (int numpcs) {
  int j;

  for (j=0; j<numpcs; j++)
  {
    (void) sprintf(xg->collab_tform2[j], "PC(%s)%d", xg->collab_tform1[j],j+1);
    XtVaSetValues(varlabel[j], XtNlabel, xg->collab_tform2[j], NULL);
  }
  for (j=numpcs; j<xg->nsph_vars; j++)
  {
    sprintf(xg->collab_tform2[j], "not used PC(%s)%d", xg->collab_tform1[j],j+1);
    XtVaSetValues(varlabel[j], XtNlabel, xg->collab_tform2[j], NULL);
  }
}

/* sphere.c */

static gboolean is_sphere_mapped = false;
static GdkPixmap *scree_plot_pixmap;
static gfloat *evals;
static gint numpcs = 0;
static gchar *snumpcs;
static gchar str[20];

close_sphere_cback (Widget w, xgobidata *xg, XtPointer callback_data)
{
  XtDestroyWidget (spopup);
  spopup = NULL;
  is_sphere_mapped = False;
}

scree_expose_cback(Widget w, xgobidata *xg, XtPointer callback_data)
{
  XCopyArea(display, scree_plot_pixmap, scree_plot_window, copy_GC,
    0, 0, scree_wksp.width, scree_wksp.height, 0, 0);
}
   
select_npc_cback(Widget w, xgobidata *xg, XtPointer callback_data)
{
  int j;
  float ftmp1=0.0, ftmp2=0.0;
  char message[MSGLENGTH];

  XtVaGetValues(npc, XtNstring, (String) &snumpcs, NULL);
  numpcs = atoi(snumpcs);

  if (numpcs<1) {
     quick_message ("Need to choose at least 1 PC.", false);
     XtVaSetValues(do_sph, XtNsensitive, False, NULL);
  } else if (numpcs > xg->nsph_vars) {
     sprintf (message, "Need to choose at most %d PCs.\n",xg->nsph_vars);
     quick_message (message, false);
     XtVaSetValues(do_sph, XtNsensitive, False, NULL);
  } else {
     
    for (j=0; j<numpcs; j++)
      ftmp1 += evals[j];
    for (j=0; j<xg->nsph_vars; j++)
      ftmp2 += evals[j];

    sprintf(str, "Tot. Var.: %5.1f ", ftmp1/ftmp2);
    XtVaSetValues(totvar, XtNlabel, str, NULL);

    sprintf(str, "Cond. Num.: %.2e ", evals[0]/evals[numpcs-1]);
    XtVaSetValues(condnum, XtNlabel, str, NULL);

    XtVaSetValues(do_sph, XtNsensitive, True, NULL);
  }
}

do_sph_cback (Widget w, xgobidata *xg, XtPointer callback_data)
{
  int j, n;
  char message[MSGLENGTH];

  if ((numpcs > 0) && (numpcs <= xg->nsph_vars))
  {
    if (evals[numpcs-1] == 0.0 || evals[0]/evals[numpcs-1] > 10000.0) {
      quick_message ("Need to choose fewer PCs. Var-cov close to singular.",
        false);
    }
    else {
      spherize_data (numpcs, xg->nsph_vars, xg->sph_vars);

      for (j=0; j<numpcs; j++)
        recalc_vc(j, xg);

      set_sph_labs(xg, numpcs);

      xg->is_princ_comp = true;
      XtVaSetValues(xg->princ_comp_cmd, XtNstate, True, NULL);
      setToggleBitmap(xg->princ_comp_cmd, True);

      set_sens_pc_axes (True, xg);

      update_lims ();
      update_world ();
      world_to_plane ();
      plane_to_screen ();

      if (xg->is_brushing) {
        assign_points_to_bins(xg);
        if (xg->brush_mode == transient)
          reinit_transient_brushing(xg);
      }

      plot_once(xg);
    }
  }
}

open_sphere_popup_cback(Widget w, xgobidata *xg, XtPointer callback_data)
{
  register int j, k;
  Boolean do_svd = false;
  char npc_lab[5], tickmk[5];
  int xstrt, ystrt, xpos, ypos;
  char message[MSGLENGTH];
  
  Dimension maxwidth = 0;

  if (!is_sphere_mapped) {
     
    if (spopup == NULL) {

      spopup = XtVaCreatePopupShell("Sphere Selected Variables",
        XtNtitle,    "Sphere variables",
        XtNiconName, "Sphere",
        NULL);
      if (mono) set_mono(spopup);

      select_npc = (Widget) CreateCommand(xg, "Select Num PCs",
        True, NULL, NULL, box[0], "Sphere");
      XtAddCallback(select_npc, XtNcallback,
        (XtCallbackProc) select_npc_cback, (XtPointer) xg);

      sprintf(npc_lab,"%d %",xg->nsph_vars);
      npc = XtVaCreateManagedWidget("Inference",
        XtNstring, (String) npc_lab,
        NULL);

      (void) sprintf(str, "Tot. Var: %5.1f ", 100.0);
      (void) sprintf(str, "Cond. Num.: %.2e  ", 0.0);

      do_sph = (Widget) CreateCommand(xg, "Do Sphering",
        NULL);

    }

    is_sphere_mapped = True;

    scree_plot_window = XtWindow(scree_plot_wksp);
    scree_plot_pixmap = XCreatePixmap(display, scree_plot_window,
      scree_wksp.width, scree_wksp.height, depth);
    XFillRectangle(display, scree_plot_pixmap, clear_GC,
      0, 0, scree_wksp.width, scree_wksp.height);
  }

  /* Now calculate the svd and display results */
  get_sph_vars ();
  set_sph_tform_tp ();
  compute_vc_matrix ();
  
   /* If xg->nsph_vars > 1 use svd routine, otherwise just standardize */
  if (xg->nsph_vars > 1) {
    do_svd = update_vc_active_and_do_svd(xg, xg->nsph_vars, xg->sph_vars);
    if (!do_svd) {
       sprintf(message,"Variance-covariance is identity already!\n");
       show_message (message,xg);
    } else {
      evals = (int *) XtMalloc((Cardinal) (xg->nsph_vars) * sizeof(float));
      get_evals(xg->nsph_vars, evals);
      for (j=0; j<xg->nsph_vars; j++) {
         evals[j] = sqrt((double)evals[j]);
      }
      XDrawLine(display, scree_plot_pixmap, copy_GC, 10, 90, 190, 90);
      XDrawLine(display, scree_plot_pixmap, copy_GC, 10, 90, 10, 10);
      for (j=0; j<xg->nsph_vars; j++) {
        sprintf(tickmk,"%d", j+1);
        xpos = (int) (180./(float)(xg->nsph_vars-1)*j+10);
        ypos = (int) (90.-evals[j]/evals[0]*80.);
        XDrawString(display, scree_plot_pixmap, copy_GC,
          xpos, 95, tickmk, strlen(tickmk));
        if (j>0) 
          XDrawLine(display, scree_plot_pixmap, copy_GC, xstrt, ystrt,
            xpos, ypos);
        xstrt = xpos;
        ystrt = ypos;
      }
      XCopyArea(display, scree_plot_pixmap, scree_plot_window, copy_GC,
        0, 0, scree_wksp.width, scree_wksp.height, 0, 0);
      XFillRectangle(display, scree_plot_pixmap, clear_GC,
                     0, 0, scree_wksp.width, scree_wksp.height);
    }
  } else {
    /*scale to variance=1*/
  }
}

/*-- from tour_pp.c --*/

void
spherize_data (int num_pcs, int nsvars, int *svars)
{
  int i, j, k, m;
  float tmpf;

/* spherize data */
  for (i=0; i<num_pcs; i++) {
    a[i] = sqrt((double) eigenval[i]);
  }
  
  for (m=0; m<xg->nrows_in_plot; m++) {
    i = xg->rows_in_plot[m];

    for (j=0; j<num_pcs; j++) {
      tmpf = 0.;
      for (k=0; k<nsvars; k++) {
        tmpf = tmpf +
          vc_active[k][j] * (xg->tform1[i][svars[k]] - mean[svars[k]]);
      }
      tmpf /= (a[j]);
      b[0][j] = tmpf;
    }
    for (j=0; j<num_pcs; j++)
      xg->tform2[i][svars[j]] = b[0][j];
  }
}

void
compute_vc_matrix ()
{
  float tmpf;
  int i, j, k;
  int n = xg->nlinkable_in_plot, p = xg->ncols_used; 

/* calculate mean vector */
  for (i=0; i<p; i++) {
    tmpf = 0.;
    for (j=0; j<n; j++) {
      tmpf += xg->tform2[xg->rows_in_plot[j]][i];
    }
    tmpf /= n;
    mean[i] = tmpf;
  }

/* calculate variance-covariance matrix */
  for (i=0; i<p; i++)
    for (j=i; j<p; j++) {
      tmpf = 0.;
      for (k=0; k<n; k++) {
        tmpf = tmpf +
             (xg->tform2[xg->rows_in_plot[k]][i] - mean[i]) *
             (xg->tform2[xg->rows_in_plot[k]][j] - mean[j]);
      }
      tmpf /= (n-1);
      vc[i][j] = tmpf;
      vc[j][i] = vc[i][j];
    }
}

/* this routine overwrites the var-cov matrix of the old active variables
 * with the new active variables. then this matrix is put through
 * singular value decomposition and overwritten with the matrix of
 * eigenvectors, and the eigenvalues are returned in a.
*/
int
update_vc_active_and_do_svd (int nsvars, int *svars)
{
  int i, j;
  int vc_equals_I;
  char message[5*MSGLENGTH], str[100];

  for (i=0; i<nsvars; i++)
    for (j=0; j<nsvars; j++)
      vc_active[i][j] = vc[svars[i]][svars[j]];

  zero_ab(xg);
  vc_equals_I = check_for_sphd_data(vc_active,nsvars);
  singular_vc = False;
  if (!vc_equals_I) {
    dsvd (vc_active, nsvars, nsvars, a, b);
    for (i=0; i<nsvars; i++)
    {
      eigenval[i] = a[i];
    }
    
  return (!vc_equals_I);
}
