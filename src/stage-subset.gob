/*
 Performs filtering operations specific to the GGobi subset dialog.
 Right now the dialog acts solely as a controller, not a view, of the filter,
 so there is no need to store the high-level rules that it applies.
*/

%h{
  #include "ggobi-stage-filter.h"
%}
%{
  #include "vars.h"
  #include "externs.h"
%}

enum GGOBI_MATCH {
  IDENTICAL,
  INCLUDES,
  STARTS_WITH,
  ENDS_WITH,
  EXCLUDES
} GGobi:Match:Method;
  
class GGobi:Stage:Subset from GGobi:Stage:Filter {

  /**
   * new:
   * @parent: the parent stage
   *
   * Create a new stage subset stage with the given parent.
   *
   * Returns: #GObject
   */
public GObject *
new(GGobiStage *parent)
{
  GObject *obj = (GObject *)GET_NEW_VARG("parent", parent, NULL);
  return G_OBJECT(obj);
}

// FIXME: this will go away

  /**
   * apply:
   * @self: a #GGobiStageSubset
   *
   * Update the filter and perform a few other tasks. This function will
   * disappear soon.
   *
   */
public void
apply (self) {
  ggobi_stage_filter_update(GGOBI_STAGE_FILTER(self));
  if (GGOBI_STAGE(self)->gg->cluster_ui.window != NULL)
    cluster_table_update (GGOBI_STAGE(self), GGOBI_STAGE(self)->gg);
}

  /**
   * reset:
   * @self: a #GGobiStageSubset
   *
   * Convenience function that includes all parent rows and applies the changes.
   *
   */
public void
reset(self)
{
  ggobi_stage_filter_set_included_all(GGOBI_STAGE_FILTER(self), TRUE);
  self_apply(self);
}

/*
 * This algorithm taken from Knuth, Seminumerical Algorithms;
 * Vol 2 of his series.
*/
  /**
   * random:
   * @self: a #GGobiStageSubset
   * @n: the size of the random sample
   *
   * Takes a random subset of size @n.
   *
   * Returns: %TRUE if subset changed
   */
public gboolean
random (self, gint n) {
  gint t, m, top = GGOBI_STAGE(self)->n_rows;
  gfloat rrand;
  gboolean *included = g_new0(gboolean, top);

  ggobi_stage_filter_set_included_all(GGOBI_STAGE_FILTER(self), false);
  
  if (n < 0 || n > top) 
    return false;

  for (t=0, m=0; t < top && m < n; t++) {
    rrand = (gfloat) randvalue ();
    if (((top - t) * rrand) < (n - m) && !included[t]) {
      ggobi_stage_filter_set_included(GGOBI_STAGE_FILTER(self), t, true);
      included[t] = true;
      m++;
    }
  }

  g_free(included);
  
  return true;
}

  /**
   * block:
   * @self: a #GGobiStageSubset
   * @bstart: starting index of block
   * @bsize: size of block
   *
   * Subsets a contiguous block of the data
   *
   * Returns: %TRUE if subset changed
   */
public gboolean
block (self, gint bstart, gint bsize)
{
  gint i, k;
  gboolean subsetsize = 0;

  if (bstart >= 0 && bstart < GGOBI_STAGE(self)->n_rows && bsize > 0) {
    ggobi_stage_filter_set_included_all(GGOBI_STAGE_FILTER(self), false);
    for (i=bstart, k=1; i < GGOBI_STAGE(self)->n_rows && k <= bsize; i++, k++) {
      ggobi_stage_filter_set_included(GGOBI_STAGE_FILTER(self), i, true);
      subsetsize++;
    }
  }

  if (subsetsize == 0)
    quick_message ("The limits aren't correctly specified.", false);
 
  return (subsetsize > 0);
}

// FIXME: This range used to apply to the transformed values, but subset
// comes before transform in the pipeline, so it now works on its own
// values (the raw values, by default).
/*
public gboolean
range (self)
{
  gint i, j;
  gint subsetsize = 0;
  GGobiVariable *var;
  gboolean add;

  ggobi_stage_filter_set_included_all(GGOBI_STAGE_FILTER(self), false);

  for (i=0; i < GGOBI_STAGE(self)->n_rows; i++) {
    add = true;
    for (j=0; j < GGOBI_STAGE(self)->n_cols; j++) {
      var = ggobi_stage_get_variable(GGOBI_STAGE(self), j);
      if (var->lim_specified_p) {
        if (ggobi_stage_get_raw_value(GGOBI_STAGE(self), i, j) < var->lim_specified.min ||
            ggobi_stage_get_raw_value(GGOBI_STAGE(self), i, j) > var->lim_specified.max)
        {
          add = false;
        }
      }
    }
    if (add) {
      ggobi_stage_filter_set_included(GGOBI_STAGE_FILTER(self), i, true);
      subsetsize++;
    }
  }

  if (subsetsize == 0)
    quick_message ("Use the variable manipulation panel to set ranges.", false);
 
  return (subsetsize > 0);
  return false;
}*/

  /**
   * everyn:
   * @self: a #GGobiStageSubset
   * @estart: first included row
   * @estep: number of steps till next included row
   *
   * This subset includes every @estep point, starting from @estart.
   *
   * Returns: %TRUE if subset changed
   */
public gboolean
everyn (self, gint estart, gint estep)
{
  gint i;
  gint top = GGOBI_STAGE(self)->n_rows;

  if (!(estart >= 0 && estart < top-1 && estep >= 0 && estep < top)) {
    quick_message ("Interval not correctly specified.", false);
    return(false);
  }
  
  ggobi_stage_filter_set_included_all(GGOBI_STAGE_FILTER(self), false);

  for(i = estart; i < top; i += estep)
    ggobi_stage_filter_set_included(GGOBI_STAGE_FILTER(self), i, true);
  
  return true;
}

/*-- create a subset of only the points with sticky ids --*/
/*-- Added by James Brook, Oct 1994 --*/
/*public gboolean
sticky (self)
{
  gint id;
  GSList *l;
  GGobiStage *last = ggobi_stage_find(GGOBI_STAGE(self), GGOBI_MAIN_STAGE_TRANSFORM);

  if (g_slist_length (last->sticky_ids) == 0)
    return false;
    
  ggobi_stage_filter_set_included_all(GGOBI_STAGE_FILTER(self), false);

  for (l = last->sticky_ids; l; l = l->next) {
    id = GPOINTER_TO_INT (l->data);
    if (id < GGOBI_STAGE(self)->n_rows)
      ggobi_stage_filter_set_included(GGOBI_STAGE_FILTER(self), id, true);
  }

  return true;
}*/

  /**
   * rowlab:
   * @self: a #GGobiStageSubset
   * @substr: substring matched against rownames
   * @method: matching method
   * @ignore_case: %TRUE for case insensitive matching
   *
   * Subsets records by their row id, according to @method.
   *
   * Returns: %TRUE if subset changed
   */
public gboolean
rowlab (self, gchar *substr, GGobiMatchMethod method, gboolean ignore_case)
{
  gint i;
  gssize slen;
  
  if (substr == NULL || (slen = g_utf8_strlen(substr, -1)) == 0)
    return false;

  ggobi_stage_filter_set_included_all(GGOBI_STAGE_FILTER(self), false);

  if (ignore_case)
    substr = g_utf8_strdown(substr, -1);
  else 
    substr = g_strdup(substr);

  for (i=0; i < GGOBI_STAGE(self)->n_rows; i++) {
    gchar *label = ggobi_stage_get_row_id(GGOBI_STAGE(self), i);
    
    if (!label)
      continue;
    
    gint llen = g_utf8_strlen(label, -1);
    gint start = method == GGOBI_MATCH_ENDS_WITH ? llen - slen : 0;
    gint safe_len = llen < slen ? llen : slen;

    if (start < 0)
      continue;
    if (ignore_case)
      label = g_utf8_strdown(label, method == GGOBI_MATCH_STARTS_WITH ? safe_len : llen);
    else 
      label = g_strndup(label, method == GGOBI_MATCH_STARTS_WITH ? safe_len : llen);

    if (method == GGOBI_MATCH_INCLUDES || method == GGOBI_MATCH_EXCLUDES) {
      gchar *inside = strstr(label, substr);
      if ((inside && method == GGOBI_MATCH_INCLUDES) || 
          (!inside && method == GGOBI_MATCH_EXCLUDES))
        ggobi_stage_filter_set_included(GGOBI_STAGE_FILTER(self), i, true);
    } else if (!g_utf8_collate(g_utf8_offset_to_pointer(label, start), substr))
        ggobi_stage_filter_set_included(GGOBI_STAGE_FILTER(self), i, true);
    g_free(label);
  }
  g_free(substr);
  return true;
}

} // end class definition
