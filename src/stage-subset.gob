/*
 Performs filtering operations specific to the GGobi subset dialog.
 Right now the dialog acts solely as a controller, not a view, of the filter,
 so there is no need to store the high-level rules that it applies.
*/

%h{
  #include "ggobi-stage-filter.h"
%}
%{
  #include "vars.h"
  #include "externs.h"
%}

class GGobi:Stage:Subset from GGobi:Stage:Filter {

public GObject *
new(GGobiStage *parent)
{
  GObject *obj = (GObject *)GET_NEW_VARG("parent", parent, NULL);
  return G_OBJECT(obj);
}

// FIXME: this will go away
public void
apply (self) {
  ggobi_stage_filter_update(GGOBI_STAGE_FILTER(self));
  if (GGOBI_STAGE(self)->gg->cluster_ui.window != NULL)
    cluster_table_update (GGOBI_STAGE(self), GGOBI_STAGE(self)->gg);
}

public void
reset(self)
{
  ggobi_stage_filter_set_included_all(GGOBI_STAGE_FILTER(self), TRUE);
  self_apply(self);
}

/*
 * This algorithm taken from Knuth, Seminumerical Algorithms;
 * Vol 2 of his series.
*/
public gboolean
random (self, gint n) {
  gint t, m, top = GGOBI_STAGE(self)->n_rows;
  gfloat rrand;
  gboolean *included = g_new0(gboolean, top);

  ggobi_stage_filter_set_included_all(GGOBI_STAGE_FILTER(self), false);
  
  if (n < 0 || n > top) 
    return false;

  for (t=0, m=0; t < top && m < n; t++) {
    rrand = (gfloat) randvalue ();
    if (((top - t) * rrand) < (n - m) && !included[t]) {
      ggobi_stage_filter_set_included(GGOBI_STAGE_FILTER(self), t, true);
      included[t] = true;
      m++;
    }
  }

  g_free(included);
  
  return true;
}

public gboolean
block (self, gint bstart, gint bsize)
{
  gint i, k;
  gboolean subsetsize = 0;

  if (bstart >= 0 && bstart < GGOBI_STAGE(self)->n_rows && bsize > 0) {
    ggobi_stage_filter_set_included_all(GGOBI_STAGE_FILTER(self), false);
    for (i=bstart, k=1; i < GGOBI_STAGE(self)->n_rows && k <= bsize; i++, k++) {
      ggobi_stage_filter_set_included(GGOBI_STAGE_FILTER(self), i, true);
      subsetsize++;
    }
  }

  if (subsetsize == 0)
    quick_message ("The limits aren't correctly specified.", false);
 
  return (subsetsize > 0);
}

// FIXME: This range used to apply to the transformed values, but subset
// comes before transform in the pipeline, so it now works on its own
// values (the raw values, by default).
public gboolean
range (self)
{
  /*gint i, j;
  gint subsetsize = 0;
  GGobiVariable *var;
  gboolean add;

  ggobi_stage_filter_set_included_all(GGOBI_STAGE_FILTER(self), false);

  for (i=0; i < GGOBI_STAGE(self)->n_rows; i++) {
    add = true;
    for (j=0; j < GGOBI_STAGE(self)->n_cols; j++) {
      var = ggobi_stage_get_variable(GGOBI_STAGE(self), j);
      if (var->lim_specified_p) {
        if (ggobi_stage_get_raw_value(GGOBI_STAGE(self), i, j) < var->lim_specified.min ||
            ggobi_stage_get_raw_value(GGOBI_STAGE(self), i, j) > var->lim_specified.max)
        {
          add = false;
        }
      }
    }
    if (add) {
      ggobi_stage_filter_set_included(GGOBI_STAGE_FILTER(self), i, true);
      subsetsize++;
    }
  }

  if (subsetsize == 0)
    quick_message ("Use the variable manipulation panel to set ranges.", false);
 
  return (subsetsize > 0);*/
  return false;
}

public gboolean
everyn (self, gint estart, gint estep)
{
  gint i;
  gint top = GGOBI_STAGE(self)->n_rows;

  if (!(estart >= 0 && estart < top-1 && estep >= 0 && estep < top)) {
    quick_message ("Interval not correctly specified.", false);
    return(false);
  }
  
  ggobi_stage_filter_set_included_all(GGOBI_STAGE_FILTER(self), false);

  for(i = estart; i < top; i += estep)
    ggobi_stage_filter_set_included(GGOBI_STAGE_FILTER(self), i, true);
  
  return true;
}

/*-- create a subset of only the points with sticky ids --*/
/*-- Added by James Brook, Oct 1994 --*/
public gboolean
sticky (self)
{
  gint id;
  GSList *l;
  GGobiStage *last = ggobi_stage_find(GGOBI_STAGE(self), GGOBI_MAIN_STAGE_TRANSFORM);

  if (g_slist_length (last->sticky_ids) == 0)
    return false;
    
  ggobi_stage_filter_set_included_all(GGOBI_STAGE_FILTER(self), false);

  for (l = last->sticky_ids; l; l = l->next) {
    id = GPOINTER_TO_INT (l->data);
    if (id < GGOBI_STAGE(self)->n_rows)
      ggobi_stage_filter_set_included(GGOBI_STAGE_FILTER(self), id, true);
  }

  return true;
}

public gboolean
rowlab (self, gchar *substr, gint substr_pos, gboolean ignore_case)
{
  gint i;
  gssize slen;
  
  if (substr == NULL || (slen = g_utf8_strlen(substr, -1)) == 0)
    return false;

  ggobi_stage_filter_set_included_all(GGOBI_STAGE_FILTER(self), false);

  if (ignore_case)
    substr = g_utf8_strdown(substr, -1);
  else 
    substr = g_strdup(substr);

  for (i=0; i < GGOBI_STAGE(self)->n_rows; i++) {
    gchar *label = ggobi_stage_get_row_id(GGOBI_STAGE(self), i);
    
    if (!label)
      continue;
    
    gint llen = g_utf8_strlen(label, -1);
    gint start = substr_pos == 3 ? llen - slen : 0;
    gint safe_len = llen < slen ? llen : slen;

    if (start < 0)
      continue;
    if (ignore_case)
      label = g_utf8_strdown(label, substr_pos == 2 ? safe_len : llen);
    else 
      label = g_strndup(label, substr_pos == 2 ? safe_len : llen);

    if (substr_pos == 1 || substr_pos == 4) {
      gchar *inside = strstr(label, substr);
      if ((inside && substr_pos == 1) || (!inside && substr_pos == 4))
        ggobi_stage_filter_set_included(GGOBI_STAGE_FILTER(self), i, true);
    } else if (!g_utf8_collate(g_utf8_offset_to_pointer(label, start), substr))
        ggobi_stage_filter_set_included(GGOBI_STAGE_FILTER(self), i, true);
    g_free(label);
  }
  g_free(substr);
  return true;
}

} // end class definition
