def attr_accessor(name, type, type_name):
  return("""/**
 * reset_attr_%(name)s:
 * @self: #GGobiData 
 * @i: row index
 * @brush: persistent or transient
 *
 * Resets %(name)s attribute to previous value
**/
public gboolean
reset_attr_%(name)s(self, guint i, GGobiDataAttrSetMethod brush)
{
  %(type)s value;
  // This code is autogenerated, do not edit by hand
  switch(brush) {
    case ATTR_SET_PERSISTENT:
      value = self_get_%(type_name)s_value_for_col_name(self, i, "_%(name)s_prev");
    default:
      value = self_get_%(type_name)s_value_for_col_name(self, i, "_%(name)s");
  }
  
  return self_set_attr_%(name)s(self, i, value, brush);

}

/**
 * set_attr_%(name)s:
 * @self: #GGobiData
 * @i: row index
 * @brush: persistent or transient
 *
 * Sets %(name)s attribute to new value.
 * Returns: true if value has changed, false otherwise
**/
public gboolean
set_attr_%(name)s(self, guint i, %(type)s value, GGobiDataAttrSetMethod brush)
{
  // This code is autogenerated, do not edit by hand
  if (brush == ATTR_SET_TRANSIENT ?
    (self_get_%(type_name)s_value_for_col_name(self, i, "_%(name)s_now") == value) :
    (self_get_%(type_name)s_value_for_col_name(self, i, "_%(name)s") == value))
    return false;

  if (brush == ATTR_SET_PERSISTENT) {
    self_set_%(type_name)s_value_for_col_name(self, i, "_%(name)s_prev", 
      self_get_%(type_name)s_value_for_col_name(self, i, "_%(name)s"));
    self_set_%(type_name)s_value_for_col_name(self, i, "_%(name)s", value);
  }

  self_set_%(type_name)s_value_for_col_name(self, i, "_%(name)s_now", value);
  return true;
}

/**
 * get_attr_%(name)s:
 * @self: #GGobiData
 * @i: row index
 * 
 * Retrieve current %(name)s
**/
public %(type)s
get_attr_%(name)s(self, guint i)
{
  // This code is autogenerated, do not edit by hand
  return self_get_%(type_name)s_value_for_col_name(self, i, "_%(name)s_now");
}""" % locals())


def column_accessor(name, type):
 return("""/** 
 * get_%(name)s_value:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 *
 * Convenience method for getting %(name)s value.
 **/
public %(type)s
get_%(name)s_value(self, guint i, guint j)
{
  // This code is autogenerated, do not edit by hand
  return (%(type)s) ggobi_stage_get_raw_value(GGOBI_STAGE(self), i, j);
}


/** 
 * get_%(name)s_values:
 * @self: #GGobiData
 * @i: row index
 *
 * Convenience method for creating a new array of type %(type)s
 * from the specified column.
 **/
public %(type)s*
get_%(name)s_values(self, guint j)
{
  // This code is autogenerated, do not edit by hand
  %(type)s* values = g_new(%(type)s, GGOBI_STAGE(self)->n_rows);
  for (guint i = 0; i < GGOBI_STAGE(self)->n_rows; i++)
    values[i] = self_get_%(name)s_value(self, i, j);
  return(values);
}

/** 
 * set_%(name)s_value:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 * @value: new value
 *
 * Convenience method for setting %(name)s value.
 **/
public void
set_%(name)s_value(self, guint i, guint j, %(type)s value)
{
  // This code is autogenerated, do not edit by hand
  ggobi_stage_set_raw_value(GGOBI_STAGE(self), i, j, (gdouble) value);
}

/** 
 * set_%(name)s_values:
 * @self: #GGobiData
 * @i: row index
 * @value: array of %(name)s of length self->nrows
 *
 * Convenience method for setting entire column of %(name)ss.
 * Emits self_col_data_changed() signal.
 **/
public void
set_%(name)s_values(self, guint j, %(type)s *values)
{
  // This code is autogenerated, do not edit by hand
  for (guint i = 0; i < GGOBI_STAGE(self)->n_rows; i++) {
    self_set_%(name)s_value(self, i, j, values[i]);
  }
  ggobi_stage_col_data_changed(GGOBI_STAGE(self), j);
}


/** 
 * get_%(name)s_value_for_col_name:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 *
 * Convenience method for getting %(name)s value.
 **/
public %(type)s
get_%(name)s_value_for_col_name(self, guint i, gchar* name)
{
  // This code is autogenerated, do not edit by hand
  guint j = ggobi_stage_get_col_index_for_name(GGOBI_STAGE(self), name);
  g_assert(j != -1);
  
  return self_get_%(name)s_value(self, i, j);
}


/** 
 * get_%(name)s_values_for_col_names:
 * @self: #GGobiData
 * @i: row index
 *
 * Convenience method for creating a new array of type %(type)s
 * from the specified column.
 **/
public %(type)s*
get_%(name)s_values_for_col_name(self, gchar* name)
{
  // This code is autogenerated, do not edit by hand
  guint j = ggobi_stage_get_col_index_for_name(GGOBI_STAGE(self), name);
  g_assert(j != -1);
  
  return self_get_%(name)s_values(self, j);
}

/** 
 * set_%(name)s_value_for_col_name:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 * @value_for_col_name: new value_for_col_name
 *
 * Convenience method for setting %(name)s value.
 **/
public void
set_%(name)s_value_for_col_name(self, guint i, gchar* name, %(type)s value)
{
  // This code is autogenerated, do not edit by hand
  guint j = ggobi_stage_get_col_index_for_name(GGOBI_STAGE(self), name);
  g_assert(j != -1);
  
  self_set_%(name)s_value(self, i, j, value);
}

/** 
 * set_%(name)s_values_for_col_name:
 * @self: #GGobiData
 * @i: row index
 * @value_for_col_name: array of %(name)s of length self->nrows
 *
 * Convenience method for setting entire column of %(name)ss.
 * Emits self_col_data_changed() signal.
 **/
public void
set_%(name)s_values_for_col_name(self, gchar* name, %(type)s *values)
{
  // This code is autogenerated, do not edit by hand
  guint j = ggobi_stage_get_col_index_for_name(GGOBI_STAGE(self), name);
  g_assert(j != -1);
  
  self_set_%(name)s_values(self, j, values);
}
""" % locals())