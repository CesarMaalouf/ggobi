%h{
  #include "ggobi-input-source.h"
  #include "ggobi-data-factory.h"
%}
%{
  #include <gsf/gsf-input-textline.h>
  
    /* Error conditions */
  #define ERR_GARBAGE_AROUND_QUOTE -1
  #define ERR_NO_ENTRY             -2
  #define ERR_NON_ENCLOSED_QUOTE   -3
  #define ERR_DANGLING_QUOTE       -4
  #define ERR_STREAM_READ          -5
  
  #ifdef DISALLOW_PARADOX_QUOTE_ERRORS
  #define crpStrictAssert(cond,error) g_return_val_if_fail (cond, error)
  #else
  #define crpStrictAssert(cond,error)
  #endif

  #define fastIsSpace(x) (isSpaceTable[128+(x)])
  static gchar isSpaceTable[128+256];
  
  struct RowEntry {
    gint ofs, len;
  };

  typedef struct Row {
    GString *src;
    gint rIdx;
    struct RowEntry * entry;
  } Row;
%}

class GGobi:Data:Factory:CSV from GGobi:Data:Factory
{
  override (GGobi:Data:Factory) GSList *
  get_supported_modes(GGobi:Data:Factory *self (check null type)) 
  {
    return g_slist_append(NULL, g_strdup("csv"));
  }  
  
  override (GGobi:Data:Factory) GSList *
  get_base_file_exts_for_mode(GGobi:Data:Factory *self (check null type), const gchar *mode) 
  {
    GSList *exts = NULL;
    if (!mode || !strcmp(mode, "csv")) {
      exts = g_slist_append(exts, g_utf8_casefold("csv", -1));
      exts = g_slist_append(exts, g_utf8_casefold("txt", -1));
      exts = g_slist_append(exts, g_utf8_casefold("asc", -1));
    }
    return exts;
  }
  
  override (GGobi:Data:Factory) GSList *
  create(GGobi:Data:Factory *self (check null type), 
    GGobi:Input:Source *source (check null type))
  {
    GsfInput *input, *lines;
    GGobiStage *d;
    gint ret = 1;
    GList *rows = NULL;
    GSList *ds = NULL;
    gchar *name = ggobi_input_source_get_display_name(source);

    /* create the ricer isSpaceTable */
    memset (isSpaceTable, 0, sizeof (isSpaceTable));
    fastIsSpace ((gchar) ' ') = 1;
    fastIsSpace ((gchar) '\f') = 1;
    fastIsSpace ((gchar) '\t') = 1;
    fastIsSpace ((gchar) '\v') = 1;
    fastIsSpace ((guchar) ' ') = 1;
    fastIsSpace ((guchar) '\f') = 1;
    fastIsSpace ((guchar) '\t') = 1;
    fastIsSpace ((guchar) '\v') = 1;

    /* Open the file */
    input = ggobi_input_source_get_input(source, NULL);
    lines = gsf_input_textline_new(input);
    g_object_unref(G_OBJECT(input));

    do {
      Row *cur = g_new0(Row, 1);
      ret = self_parse_row(cur, GSF_INPUT_TEXTLINE(lines), 1);
      if (ret >= 0) {
        self_tokenize_row(cur);
        rows = g_list_append(rows, cur);
      } else self_row_free (cur);
    } while (ret >= 0);

    g_object_unref(G_OBJECT(lines));

    /* Load the parsed data into the GGobiStage */
    d = self_create_data(rows, name);
    ggobi_data_set_source(GGOBI_DATA(d), source);

    /* Cleanup */
    g_list_foreach(rows, (GFunc) self_row_free, NULL);
    g_list_free(rows);
    g_free(name);

    ds = g_slist_append(ds, d);
    return (ds);
  }

/* Heuristic: If the first row has an empty in the first column and
   and all the values in the first column are unique, we have row names.
*/
  private gboolean has_row_labels (GList * rows)
  {
    GHashTable *hash =
      g_hash_table_new ((GHashFunc) g_str_hash, (GEqualFunc) g_str_equal);
    Row *first = (Row *) rows->data;

    if (first->entry[0].len != 0)
      return false;

    while (rows)
      {
        Row *row = (Row *) rows->data;
        gchar *str = row->src->str + row->entry[0].ofs;
        if (g_hash_table_lookup (hash, str))
          {
            g_warning ("Duplicate row name: %s - treating rownames as data",
                       str);
            g_hash_table_destroy (hash);
            return false;
          }
        g_hash_table_insert (hash, str, str);
        rows = g_list_next (rows);
      }
    g_hash_table_destroy (hash);
    return true;
  }

  private void
    load_column_labels (Row * row, GGobi:Stage * d, gboolean row_labels)
  {
    gint offset = (row_labels ? 1 : 0);
    GGOBI_STAGE_VARIABLES_ITERATE (d)
    {
      if (row->entry[j + offset].len == 0)
        ggobi_stage_set_col_name (d, j, NULL);
      else
        ggobi_stage_set_col_name (d, j,
                                  row->src->str + row->entry[j + offset].ofs);
    }
  }

  private void
    load_row_labels (GList * rows, GGobi:Stage * d, gboolean has_labels)
  {
    if (!has_labels)
      return;

    for (gint i = 0; rows; rows = g_list_next (rows), i++)
      {
        Row *row = (Row *) rows->data;
        ggobi_stage_set_row_id (d, i, row->src->str + row->entry[0].ofs);
      }
  }

  private void
    load_row_values (GList * rows, GGobi:Stage * d, gboolean row_labels)
  {
    gint i, offset = (row_labels ? 1 : 0);
    GList *cur;

    GGOBI_STAGE_VARIABLES_ITERATE (d)
    {
      for (cur = rows, i = 0; cur; cur = cur->next, i++)
        {
          Row *row = (Row *) cur->data;
          gchar *str = row->src->str + row->entry[j + offset].ofs;

          ggobi_stage_set_string_value (d, i, j, str);
        }
    }
  }

  private GGobiStage *create_data (GList * rows, gchar * name)
  {
    GGobiStage *d;
    guint nrows = g_list_length (rows), ncols = 0;

    gboolean row_labels = self_has_row_labels (rows);

    if (nrows > 0)
      ncols = ((Row *) rows->data)->rIdx;
    if (row_labels)
      ncols--;

    d = GGOBI_STAGE (ggobi_data_new (nrows - 1, ncols));
    ggobi_data_add_attributes (GGOBI_DATA (d));
    ggobi_stage_set_name (d, name);

    self_load_column_labels ((Row *) rows->data, d, row_labels);
    rows = g_list_next (rows);  /* skip the column labels */

    self_load_row_labels (rows, d, row_labels);
    self_load_row_values (rows, d, row_labels);

    return (d);
  }

/* BEGIN BCSV Code */

/* This file contains code written by Paul Hsieh (specifically the csv_row_parse()
 * function and related code). His license demands the inclusion of the below 
 * copyright notice, conditions, and disclaimer. It also probably contains some 
 * code by Dongshin Kim, a student who worked with Di Cook at ISU and original 
 * author of the GGobi csv parsing code. 
*/

/* bcsv - read comma separated value format
 * Copyright (c) 2003 Paul Hsieh <qed@pobox.com>
 * Modified by GGobi team to depend on GLib instead of bstring
 * and to work across major platforms
 * 
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions are met:
 * 
 *     Redistributions of source code must retain the above copyright notice, 
 *     this list of conditions and the following disclaimer. 
 * 
 *     Redistributions in binary form must reproduce the above copyright 
 *     notice, this list of conditions and the following disclaimer in the 
 *     documentation and/or other materials provided with the distribution. 
 * 
 *     Neither the name of bcsv nor the names of its contributors may be 
 *     used to endorse or promote products derived from this software without 
 *     specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 */
  private gint parse_row (Row * row, GsfInputTextline *lines, gint trim)
  {
    gint i = 0, startOfs = 0, k, QuoteAfterQuote = 0;
    gint rowMlen;
    guchar *line;

    if (row == NULL)
      return 0;

    row->rIdx = 0;
    
    line = gsf_input_textline_utf8_gets(lines);
    if (line == NULL)
      return ERR_STREAM_READ;
    row->src = g_string_new(line);
    
    g_string_append_c (row->src, '\r');

    rowMlen = 4;                /* Set smaller if this leads to too much memory usage */
    row->entry = g_new (struct RowEntry, rowMlen);
    if (row->entry == NULL)
      {
        return 0;
      }

    goto LParseNewEntry;

  LPostProcessQuote:           /* Post-process quote enclosed strings */
    {
      gint ll, l, m;
      gchar *v;
      ll = l = row->entry[row->rIdx].len;
      v = row->src->str + row->entry[row->rIdx].ofs;
      m = k = 1;
      for (m = k = 1; m < l; k++, m++)
        {
          if (v[m] == '"' && v[m - 1] == '"')
            {
              /* Skip the second of two consecutive " characters */
              ll--;
              m++;
            }
          v[k] = v[m];
        }
      row->entry[row->rIdx].len = ll;
    }

    /* Check for pending exit condition */
    if (row->src->str[i] == '\r' || row->src->str[i] == '\n')
      {
        goto LDoneLast;
      }

    QuoteAfterQuote = 0;

  LCommaEncountered:           /* , encountered */

    i++;
    row->rIdx++;                /* New row entry */

    if (row->rIdx >= rowMlen)
      {
        struct RowEntry *t;
        rowMlen += rowMlen;
        t = g_renew (struct RowEntry, row->entry, rowMlen);
        if (t == NULL)
          {
            g_free (row->src);
            row->rIdx = 0;
            g_free (row->entry);
            return 0;
          }
        row->entry = t;
      }

  LParseNewEntry:              /* End of , or beginning */

    k = i;
    while (fastIsSpace (row->src->str[i]))
      i++;

    if (row->src->str[i] == '"')
      {
        /* Single quote encountered */
        i++;
        startOfs = i;           /* Will be useful for the triple quote case. */
        row->entry[row->rIdx].ofs = i;
        g_return_val_if_fail (i < row->src->len, ERR_DANGLING_QUOTE);
        goto LAfterOpenQuote;
      }

    /* If there is no trimming, then consumption is obvious */

    if (!trim)
      {
        row->entry[row->rIdx].ofs = k;
        while (row->src->str[i] != ',')
          {
            crpStrictAssert (row->src->str[i] != '"',
                             ERR_GARBAGE_AROUND_QUOTE);
            i++;
            if (row->src->str[i] == '\r' || row->src->str[i] == '\n')
              {
                row->entry[row->rIdx].len = i - k;
                goto LDoneLast;
              }
          }
        row->entry[row->rIdx].len = i - k;
        goto LCommaEncountered;
      }

    row->entry[row->rIdx].ofs = i;
    if (row->src->str[i] == ',')
      {
        row->entry[row->rIdx].len = 0;
        goto LCommaEncountered;
      }

    startOfs = i;
    k = i;

    /* Middle unquoted characters */

    while (row->src->str[i] != ',')
      {
        if (row->src->str[i] == '\r' || row->src->str[i] == '\n')
          {
            row->entry[row->rIdx].len = k - startOfs;
            /* A single empty entry should be explicitely given in quotes */
            if (row->rIdx == 0 && k == startOfs)
              return 1;
            goto LDoneLast;
          }
        i++;
        k = i;
        /* Consume whatever spaces there are */
        while (fastIsSpace (row->src->str[i]))
          i++;
        crpStrictAssert (row->src->str[i] != '"', ERR_NON_ENCLOSED_QUOTE);
      }
    row->entry[row->rIdx].len = k - startOfs;
    goto LCommaEncountered;

  LAfterOpenQuote:             /* Characters after an open quote */

    while (1)
      {

        while (row->src->str[i] != '"')
          {

          LInsideQuote:
            i++;

            /* Go by length, and potentially read in more lines, since
               the \r character may be embedded in the quoted string */
            if (i >= row->src->len)
              {
                GString *tmp_str = NULL;
                if (!(line = gsf_input_textline_utf8_gets(lines)))
                  return ERR_STREAM_READ;
                tmp_str = g_string_new(line);
                if (tmp_str->len <= 0)
                  return ERR_DANGLING_QUOTE;
                g_string_append(row->src, tmp_str->str);
                g_string_free(tmp_str, TRUE);
              }
          }

        /* Quote after characters after an open quote */

        k = i;
        i++;
        if (row->src->str[i] == '\r' || row->src->str[i] == '\n')
          {
            row->entry[row->rIdx].len = k - startOfs;
            if (QuoteAfterQuote)
              goto LPostProcessQuote;
            goto LDoneLast;
          }

        if (row->src->str[i] == '"')
          {
            QuoteAfterQuote = 1;
            goto LInsideQuote;
          }

        while (fastIsSpace (row->src->str[i]))
          i++;
        crpStrictAssert (row->src->str[i] == ',', ERR_GARBAGE_AROUND_QUOTE);
        if (row->src->str[i] == ',')
          {
            row->entry[row->rIdx].len = k - startOfs;
            if (QuoteAfterQuote)
              goto LPostProcessQuote;
            goto LCommaEncountered;
          }
      }
  LDoneLast:
    row->rIdx++;
    return 1;
  }

/* END BCSV CODE */

/* some utilities to help out bcsv */

/* This makes things a lot easier - Michael */
  private void tokenize_row (Row * row)
  {
    gint i;
    for (i = 0; i < row->rIdx; i++)
      {
        row->src->str[row->entry[i].ofs + row->entry[i].len] = '\0';
      }
  }

  private void row_free (Row * row)
  {
    if (row->src)
      g_string_free (row->src, true);
    if (row->entry)
      g_free (row->entry);
    g_free (row);
  }


}
