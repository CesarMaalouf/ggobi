%h{
  #include <gsf/gsf-input-impl.h>
  #include <gsf/gsf-input.h>
  /* apparently the GSF guys don't like this convention */
  #define GSF_TYPE_INPUT gsf_input_get_type()
%}
%{
  #include <libxml/nanoftp.h>
%}
class GGobi:Gsf:Input:FTP from Gsf:Input
{
  private gchar *url destroywith g_free;
  property STRING url
    (nick = "URL", blurb = "FTP(S) URL accessed by this stream", link, export);
  
  private gpointer ctx destroywith xmlNanoFTPFreeCtxt;
  private guint8 *buf destroywith g_free;
  private gsize buf_size;
  
  public GsfInput *
  new(const gchar *url, GError **error)
  {
    GObject *obj = (GObject *)GET_NEW_VARG("url", url, NULL);
    GGobiGsfInputFTP *input = SELF(obj);
    gpointer ctx;
    gchar *filename = g_path_get_basename(url);
    gint list_ret;
    
    ctx = SELF(obj)->_priv->ctx = xmlNanoFTPNewCtxt(input->_priv->url);
    if (!ctx) /* no meaningful errors provided by nanoftp */
      return NULL;
    
    /* to get the size we need to list the file */
    list_ret = xmlNanoFTPList(ctx, self_ftp_list_cb, obj, filename);
    g_free(filename);
    if (list_ret < 0)
      return NULL;
    
    return GSF_INPUT(obj);
  }
  
  private void
  ftp_list_cb(void *data, const char * filename, const char * attrib, 
    const char * owner, const char * group, unsigned long size, int links, 
		int year, const char * month,	 int day, int hour, int minute)
  {
    gsf_input_set_size(GSF_INPUT(data), size);
  }
  
  override (Gsf:Input) GsfInput *
  Dup(GsfInput *src, GError **err)
  {
    return ggobi_gsf_input_ftp_new(SELF(src)->_priv->url, err);
  }
  
  override (Gsf:Input) const guint8 *
  Read(GsfInput *input, size_t num_bytes, guint8 *buffer)
  {
    int nread;
    gsize total_read;
    gpointer ctx = SELF(input)->_priv->ctx;
    GGobiGsfInputFTP *self = SELF(input);
    
    if (xmlNanoFTPGetConnection(ctx) < 0)
      return NULL;
      
    if (buffer == NULL) {
      if (selfp->buf_size < num_bytes) {
        selfp->buf_size = num_bytes;
        g_free (selfp->buf);
        selfp->buf = g_new (guint8, selfp->buf_size);
      }
      buffer = selfp->buf;
    }
  
    for (total_read = 0; total_read < num_bytes; total_read += nread) {
      nread = xmlNanoFTPRead(ctx, buffer, num_bytes - total_read);
      if (nread <= 0)
        return NULL;
    }
    return buffer;
  }
  
  override (Gsf:Input) gboolean
  Seek(GsfInput *input, gsf_off_t offset, GSeekType whence)
  {
    return FALSE;
  }
  
}
