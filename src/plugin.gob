%h{
  // FIXME: should be temporary - need to clean up the "GGobi context"
  #include "ggobi.h"
%}
class GGobi:Plugin from G:Type:Module {
  
  /* The underlying library object */
  private GModule *library;
  
  /* GObject does not really support G(S)List properties */
  
  /* Plugins on which this one depends */
  private GSList *dependencies;
  
  private GSList *args destroywith g_slist_free; /* All the arguments passed the plugin */
  private GHashTable *arg_table = /* If an arg has a name, this maps it to the arg */
    { g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free); }
    destroywith g_hash_table_destroy; 
  
  /* The critical routine called to tell the plugin that it's showtime */
  private gchar *on_load_name destroywith g_free;
  property STRING on_load_name 
    (nick = "on_load", blurb = "Name of symbol called upon load", link, export);
  
  /* May be useful for freeing resources when the plugin is unused */
  private gchar *on_unload_name destroywith g_free;
  property STRING on_unload_name 
    (nick = "on_unload", blurb = "Name of symbol called upon unload", link, export);
    
  /* These two could become on_activate and on_deactivate if activation is ever supported */
  private gchar *on_create_name destroywith g_free;
  property STRING on_create_name 
    (nick = "on_create", blurb = "Name of symbol called upon GGobi context creation", 
      link, export);
      
  private gchar *on_close_name destroywith g_free;
  property STRING on_close_name 
    (nick = "on_close", blurb = "Name of symbol called upon GGobi context closure", 
      link, export);
    
  private gchar *author destroywith g_free;
  property STRING author 
    (nick = "hacker", blurb = "Name(s) of people responsible for this plugin", 
      link, export);
  
  private gchar *description destroywith g_free;
  property STRING description 
    (nick = "desc", blurb = "Details regarding this plugin's purpose", 
      link, export);
      
  private gchar *dll_name destroywith g_free;
  property STRING dll_name 
    (nick = "dll", blurb = "The file name of this plugin's library file (if it has one)", 
      link, export);
   
  private GHashTable *instances = 
   { g_hash_table_new_full(NULL, NULL, NULL, g_free) }
   destroywith g_hash_table_destroy;
   
  public GGobiPlugin *
  new(void)
  {
    GObject *plugin = (GObject *)GET_NEW;
    return GGOBI_PLUGIN(plugin);
  }
  
  public gboolean
  has_dependencies(self)
  {
    return g_slist_length(selfp->dependencies) > 0;
  }
  public GSList *
  get_dependencies(self)
  {
    return g_slist_copy(selfp->dependencies);
  }
  public void
  add_dependency(self, GGobi:Plugin *plugin (check null type))
  {
    g_object_ref(G_OBJECT(plugin));
    selfp->dependencies = g_slist_append(selfp->dependencies, plugin);
  }
  
  public GSList *
  get_arguments(self) 
  {
    return g_slist_copy(selfp->args);
  }
  public const gchar *
  get_argument_for_name(self, const gchar *name (check null))
  {
    return g_hash_table_lookup(selfp->arg_table, name);
  }
  public void
  add_argument(self, const gchar *name, const gchar *arg (check null))
  {
    gchar *tmp_arg = g_strdup(arg);
    if (name)
      g_hash_table_insert(selfp->arg_table, g_strdup(name), tmp_arg);
    selfp->args = g_slist_append(selfp->args, tmp_arg);
  }
  
  // FIXME: This obviously needs to become a signal handler
  virtual gboolean
  ggobi_created(self, ggobid *gg)
  {
    OnCreateFunc f;
    gboolean success = TRUE;
    GGobiPluginInstance *instance = self_create_instance(self, gg);
    g_hash_table_insert(selfp->instances, gg, instance);
    if (selfp->on_create_name) {
      if (self_get_symbol(self, selfp->on_create_name, &f))
        success = f(instance);
      else {
        g_critical("Could not find onCreate symbol: %s for plugin %s", 
          selfp->on_create_name, G_TYPE_MODULE(self)->name);
        success = FALSE;
      }
    }
    return success;
  }
  
  virtual gboolean
  ggobi_destroyed(self, ggobid *gg)
  {
    gboolean success = TRUE;
    GGobiPluginInstance *instance = g_hash_table_lookup(selfp->instances, gg);
    if (selfp->on_close_name) {
      OnCloseFunc f;
      if (self_get_symbol (self, selfp->on_close_name, &f))
        success = f(instance);
      else {
        g_critical("Could not find onClose symbol: %s for plugin %s",
          selfp->on_close_name, G_TYPE_MODULE(self)->name);
        success = FALSE;
      }
    }
    g_hash_table_remove(selfp->instances, gg);
    return success;
  }
  
  private GGobiPluginInstance *
  create_instance(self, ggobid *gg)
  {
    GGobiPluginInstance *inst = g_new0(GGobiPluginInstance, 1);
    inst->gg = gg;
    return inst;
  }
  
  virtual gboolean
  get_symbol(self, const gchar *symbol_name (check null), gpointer symbol (check null))
  {
    g_return_val_if_fail(selfp->library != NULL, FALSE);
    return g_module_symbol(selfp->library, symbol_name, symbol);
  }
  
  override (G:Type:Module) gboolean
  load(G:Type:Module *self (check null type)) 
  {
    GModule *library;
    GGobiPlugin *plugin = SELF(self);
    /* Load any plugins on which this one depends. Make certain they 
     are fully loaded and initialized. Potential for inter-dependencies
     that would make this an infinite loop. Hope the user doesn't get this
     wrong as there are no checks at present.
    */
    if (self_has_dependencies(plugin)) {
      GSList *el = plugin->_priv->dependencies;
      while (el) {
        GTypeModule *module = G_TYPE_MODULE(el->data);
        // FIXME: verbosity should be handled by a GLogFunc callback
        if (sessionOptions->verbose == GGOBI_VERBOSE) {
          g_message("Loading dependent plugin %s\n", module->name);
        }
        if (!g_type_module_use(module)) {
          g_object_unref(G_OBJECT(module));
          return (FALSE);
        }
        g_type_module_unuse(module);
        el = el->next;
      }
    }

    library = self_load_library(plugin);
    plugin->_priv->library = library;

    if (library && self_check_plugin(plugin)) {
      if (plugin->_priv->on_load_name) {
        OnLoadFunc f;
        if (self_get_symbol(plugin, plugin->_priv->on_load_name, &f)) {
          f (plugin);
        } else {
          g_critical("error loading plugin %s: %s", plugin->_priv->dll_name, 
            g_module_error());
          return(FALSE);
        }
      }
      return(TRUE);
    }
    
    return (FALSE);
  }
  
  private GModule *
  load_library(self)
  {
    GModule *module = NULL;
    gchar *filename = ggobi_find_data_file(selfp->dll_name);
    if (filename) {
      module = g_module_open(filename, 0);
      g_free(filename);
      if (!module)
        g_critical("Error on loading plugin library %s: %s", filename, g_module_error());
    } else g_critical("Could not find dll '%s'", selfp->dll_name);
    return (module);
  }
  
  public gboolean
  check_plugin(self)
  {
    gboolean (*f) (const GGobiPlugin *);
    gboolean ok = true;
    if (g_module_symbol(selfp->library, "checkGGobiStructSizes", (gpointer)&f)) {
      if (!(ok = f(self)))
        g_warning("Problems with plugin %s. Incosistent view of ggobi's data structures.",
          G_TYPE_MODULE(self)->name);
      else if (sessionOptions->verbose == GGOBI_VERBOSE)
        g_message("plugin %s appears consistent with ggobi structures.",
          G_TYPE_MODULE(self)->name);
    }
    else if (sessionOptions->verbose == GGOBI_VERBOSE)
      g_message("plugin %s has no validation mechanism", G_TYPE_MODULE(self)->name);
    return (ok);
  }
}
%h{
  typedef struct _GGobiPluginInstance {
    GGobiPlugin *plugin;
    ggobid *gg;
    void *data;
  } GGobiPluginInstance;
  typedef gboolean (*OnLoadFunc)(GGobiPlugin *plugin);
  typedef gboolean (*OnCreateFunc)(GGobiPluginInstance *inst);
  typedef gboolean (*OnCloseFunc)(GGobiPluginInstance *inst);
  typedef gboolean (*OnUnloadFunc)(GGobiPlugin *plugin);
%}
