%h{
  // FIXME: should be temporary - need to clean up the "GGobi context"
  #include "session.h"
%}

/** Comments:
    Need to refactor plugin framework to move beyond XML metadata.
    
    Refactorings:

    Plugin -> interface Plugin

    Plugin should be an abstract class or interface that allows plugin
    modules to report metadata to GGobi. It should also help with
    loading the plugins, synchronizing them with GGobi state,
    etc. Implementations will handle a particular type of module. The
    default implementation will be GModulePlugin (loading using GModule).
    
    PluginFactory -> interface PluginRegistry

    Lists plugins available at a given source and creates Plugin
    objects from them. XMLPluginRegistry will be one implementation.
*/

class GGobi:Plugin from G:Type:Module {
  
  /* The underlying library object */
  private GModule *library;
  
  /* GObject does not really support G(S)List properties */
  
  /* Plugins on which this one depends */
  private GSList *dependencies;
  
  private GSList *args destroywith g_slist_free; /* All the arguments passed the plugin */
  private GHashTable *arg_table = /* If an arg has a name, this maps it to the arg */
    { g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free); }
    destroywith g_hash_table_destroy; 
  
  /* The critical routine called to tell the plugin that it's showtime */
  private gchar *on_load_name destroywith g_free;
  property STRING on_load_name 
    (nick = "on_load", blurb = "Name of symbol called upon load", link, export);
  
  /* May be useful for freeing resources when the plugin is unused */
  private gchar *on_unload_name destroywith g_free;
  property STRING on_unload_name 
    (nick = "on_unload", blurb = "Name of symbol called upon unload", link, export);
    
  /* These two could become on_activate and on_deactivate if activation is ever supported */
  private gchar *on_create_name destroywith g_free;
  property STRING on_create_name 
    (nick = "on_create", blurb = "Name of symbol called upon GGobi context creation", 
      link, export);
      
  private gchar *on_close_name destroywith g_free;
  property STRING on_close_name 
    (nick = "on_close", blurb = "Name of symbol called upon GGobi context closure", 
      link, export);
    
  private gchar *author destroywith g_free;
  property STRING author 
    (nick = "hacker", blurb = "Name(s) of people responsible for this plugin", 
      link, export);
  
  private gchar *description destroywith g_free;
  property STRING description 
    (nick = "desc", blurb = "Details regarding this plugin's purpose", 
      link, export);
      
  private gchar *dll_name destroywith g_free;
  property STRING dll_name 
    (nick = "dll", blurb = "The file name of this plugin's library file (if it has one)", 
      link, export);
   
  private GHashTable *instances = 
   { g_hash_table_new_full(NULL, NULL, NULL, g_free) }
   destroywith g_hash_table_destroy;
   
  /**
   * new:
   *
   * Normally plugins are created from an XML description with #GGobiPluginFactory.
   *
   * Returns: a new #GGobiPlugin
   */
  public GGobiPlugin *
  new(void)
  {
    GObject *plugin = (GObject *)GET_NEW;
    return GGOBI_PLUGIN(plugin);
  }
  
  /**
   * has_dependencies:
   * @self: a #GGobiPlugin
   *
   * Does this plugin have any dependencies on other pluginns?
   *
   * Returns: TRUE if it has dependencies
   */
  public gboolean
  has_dependencies(self)
  {
    return g_slist_length(selfp->dependencies) > 0;
  }
  /**
   * get_dependencies:
   * @self: a #GGobiPlugin
   *
   * Lists the #GGobiPlugin objects on which this plugin depends. They are
   * loaded automatically when this plugin is loaded.
   *
   * Returns: #GSList of #GGobiPlugin objects.
   */
  public GSList *
  get_dependencies(self)
  {
    return g_slist_copy(selfp->dependencies);
  }
  /**
   * add_dependency:
   * @self: a #GGobiPlugin
   * @plugin: a plugin on which this plugin depends
   *
   * The dependency will be loaded when this plugin is loaded.
   */
  public void
  add_dependency(self, GGobi:Plugin *plugin (check null type))
  {
    g_object_ref(G_OBJECT(plugin));
    selfp->dependencies = g_slist_prepend(selfp->dependencies, plugin);
  }
  
  /**
   * get_argument_for_name:
   * @self: a #GGobiPlugin
   * @name: the name of an argument (option)
   *
   * Gets the value of an argument (or option) specified for this plugin.
   *
   * Returns: argument value
   */
  public const gchar *
  get_argument_for_name(self, const gchar *name (check null))
  {
    return g_hash_table_lookup(selfp->arg_table, name);
  }
  /**
   * add_argument:
   * @self: a #GGobiPlugin
   * @name: name of argument
   * @arg: value of argument
   *
   * Adds a new argument setting for this plugin. These usually control
   * optional behavior of a plugin.
   *
   */
  public void
  add_argument(self, const gchar *name, const gchar *arg (check null))
  { // FIXME: maybe this should be "set_argument"..
    gchar *tmp_arg = g_strdup(arg);
    if (name)
      g_hash_table_insert(selfp->arg_table, g_strdup(name), tmp_arg);
    selfp->args = g_slist_prepend(selfp->args, tmp_arg);
  }
  
  // FIXME: This obviously needs to become a signal handler
  // FIXME: Shouldn't the plugin library return a custom GGobiPluginInstance,
  // where GGobiPluginInstance is a GObject class?
  
  /**
   * ggobi_created:
   * @self: a #GGobiPlugin
   * @gg: GGobi session
   *
   * Informs this plugin that a new session has been created. The plugin should
   * then associate itself with the session. This will go away in the future.
   *
   * Returns: %TRUE if succeeded
   */
  virtual gboolean
  ggobi_created(self, GGobiSession *gg)
  {
    OnCreateFunc f;
    gboolean success = TRUE;
    GGobiPluginInstance *instance = self_create_instance(self, gg);
    g_hash_table_insert(selfp->instances, gg, instance);
    if (selfp->on_create_name) {
      if (self_get_symbol(self, selfp->on_create_name, &f))
        success = f(instance);
      else {
        g_critical("Could not find onCreate symbol: %s for plugin %s", 
          selfp->on_create_name, G_TYPE_MODULE(self)->name);
        success = FALSE;
      }
    }
    return success;
  }
  
  /**
   * ggobi_destroyed:
   * @self: a #GGobiPlugin
   * @gg: a GGobi session
   *
   * Informs a plugin that a GGobi session has been closed. The plugin should
   * then relinquish all of its resources for that session. This function is
   * only temporary.
   *
   * Returns: %TRUE if succeeded
   */
  virtual gboolean
  ggobi_destroyed(self, GGobiSession *gg)
  {
    gboolean success = TRUE;
    GGobiPluginInstance *instance = g_hash_table_lookup(selfp->instances, gg);
    if (selfp->on_close_name) {
      OnCloseFunc f;
      if (self_get_symbol (self, selfp->on_close_name, &f))
        success = f(instance);
      else {
        g_critical("Could not find onClose symbol: %s for plugin %s",
          selfp->on_close_name, G_TYPE_MODULE(self)->name);
        success = FALSE;
      }
    }
    g_hash_table_remove(selfp->instances, gg);
    return success;
  }
  
  private GGobiPluginInstance *
  create_instance(self, GGobiSession *gg)
  {
    GGobiPluginInstance *inst = g_new0(GGobiPluginInstance, 1);
    inst->gg = gg;
    return inst;
  }
  
  /**
   * get_symbol:
   * @self: a #GGobiPlugin
   * @symbol_name: name of symbol in foreign library
   * @symbol: return location of value for symbol
   *
   * This function is on its way out.
   *
   * Returns: %TRUE for success
   */
  virtual gboolean
  get_symbol(self, const gchar *symbol_name (check null), gpointer symbol (check null))
  {
    g_return_val_if_fail(selfp->library != NULL, FALSE);
    return g_module_symbol(selfp->library, symbol_name, symbol);
  }
  
  override (G:Type:Module) gboolean
  load(G:Type:Module *self (check null type)) 
  {
    GModule *library;
    GGobiPlugin *plugin = SELF(self);
    /* Load any plugins on which this one depends. Make certain they 
     are fully loaded and initialized. Potential for inter-dependencies
     that would make this an infinite loop. Hope the user doesn't get this
     wrong as there are no checks at present.
    */
    if (self_has_dependencies(plugin)) {
      GSList *el = plugin->_priv->dependencies;
      while (el) {
        GTypeModule *module = G_TYPE_MODULE(el->data);
        // FIXME: verbosity should be handled by a GLogFunc callback
        if (sessionOptions->verbose == GGOBI_VERBOSE) {
          g_message("Loading dependent plugin %s\n", module->name);
        }
        if (!g_type_module_use(module)) {
          g_object_unref(G_OBJECT(module));
          return (FALSE);
        }
        g_type_module_unuse(module);
        el = el->next;
      }
    }

    library = self_load_library(plugin);
    plugin->_priv->library = library;

    if (library && self_check_plugin(plugin)) {
      if (plugin->_priv->on_load_name) {
        OnLoadFunc f;
        if (self_get_symbol(plugin, plugin->_priv->on_load_name, &f)) {
          f (plugin);
        } else {
          g_critical("error loading plugin %s: %s", plugin->_priv->dll_name, 
            g_module_error());
          return(FALSE);
        }
      }
      return(TRUE);
    }
    
    return (FALSE);
  }
  
  private GModule *
  load_library(self)
  {
    GModule *module = NULL;
    gchar *filename = ggobi_find_data_file(selfp->dll_name);
    if (filename) {
      module = g_module_open(filename, 0);
      g_free(filename);
      if (!module)
        g_critical("Error on loading plugin library %s: %s", filename, g_module_error());
    } else g_critical("Could not find dll '%s'", selfp->dll_name);
    return (module);
  }
  
  /**
   * check_plugin:
   * @self: a #GGobiPlugin
   *
   * This function is probably not necessary and will be removed soon.
   *
   * Returns: %TRUE if the plugin is linked against this version of GGobi
   */
  public gboolean
  check_plugin(self)
  {
    gboolean (*f) (const GGobiPlugin *);
    gboolean ok = true;
    if (g_module_symbol(selfp->library, "checkGGobiStructSizes", (gpointer)&f)) {
      if (!(ok = f(self)))
        g_warning("Problems with plugin %s. Inconsistent view of ggobi's data structures.",
          G_TYPE_MODULE(self)->name);
      else if (sessionOptions->verbose == GGOBI_VERBOSE)
        g_message("plugin %s appears consistent with ggobi structures.",
          G_TYPE_MODULE(self)->name);
    }
    else if (sessionOptions->verbose == GGOBI_VERBOSE)
      g_message("plugin %s has no validation mechanism", G_TYPE_MODULE(self)->name);
    return (ok);
  }
}
%h{
  typedef struct _GGobiPluginInstance {
    GGobiPlugin *plugin;
    GGobiSession *gg;
    void *data;
  } GGobiPluginInstance;
  typedef gboolean (*OnLoadFunc)(GGobiPlugin *plugin);
  typedef gboolean (*OnCreateFunc)(GGobiPluginInstance *inst);
  typedef gboolean (*OnCloseFunc)(GGobiPluginInstance *inst);
  typedef gboolean (*OnUnloadFunc)(GGobiPlugin *plugin);
%}
