/*
 
  
*/

%h{
  #include "ggobi-stage.h"
}

%{
  
  /* signal handlers */
  static void
  col_data_changed_cb(GGobiVariable *var, const gchar *name, GGobiStage self)
  {
    // FIXME: check to make sure one of the relevant columns changed
    // like sampled and excluded - but those aren't attributes yet
    set_rows_in_plot (self);
  }

  static void
  rows_added_cb(self, guint n) 
  {
    // FIXME: we can do this more efficiently by only looking at the last n
    set_rows_in_plot (self);
  }

%}

class GGobi:Stage:Filter from GGobi:Stage {

  // parent is GGobi:Data; it is itself the parent of GGobi:Transform

  // These are the indices to be used; n_rows_in_plot is just n_rows.
  protected guint *rows_in_plot;

  private guint
  get_raw_index (self, guint i (check < N_ROWS)) {
    return (self->rows_in_plot[i]);
  }

/**
 * set_missing:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 **/
override (GGobi:Stage) void
set_missing(GGobi:Stage *self (check null type), guint i (check < N_ROWS), 
  guint j (check < N_COLS))
{
  PARENT_HANDLER(self, self_get_raw_index(SELF(self), i), j);
}

/**
 * is_missing:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 *
 * Returns: if value at specified position is missing or not
 **/
override (GGobi:Stage) gboolean
is_missing(GGobi:Stage *self (check null type), guint i (check < N_ROWS), 
  guint j (check < N_COLS)) 
{
  PARENT_HANDLER(self, self_get_raw_index(SELF(self), i), j);  
}

/*  Other virtual methods that may need to be overridden.

  /* I don't know how this should be set, but this filter's
     value may differ from its parent's. 
     -- You will need to check at the beginning and upon each change in data
     for missings.
     */
     
/*
override (GGobi:Stage) gboolean
has_missings(GGobiStage self)
{
  return SELF(self)->missings;
}
*/

override (GGobi:Stage) gchar*
get_row_id(GGobi:Stage *self (check null type), guint i (check < N_ROWS)) {
  PARENT_HANDLER(self, self_get_raw_index(SELF(self), i));  
}

/* 
   This will return the raw row number, not the row number
   for this stage.  That's probably the right thing to do, but
   we need to work through a case where it's used.
   
   HW: I think it should return the row index for this stage.  eg.
   Imagine looking up a rowid and then going to modify that row.
 */
 // FIXME: This should return the row number after the filter. There needs
 // to be a reverse mapping from raw -> filtered OR we need to hash the labels
override (GGobi:Stage) gint
get_row_for_id(GGobi:Stage *self (check null type), gchar *id (check null)) {
  PARENT_HANDLER(self, self_get_raw_index(SELF(self), i));  
}

/**
 * set_raw_value:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 * @values: vector of new values, of length self->n_rows
 **/
override (GGobi:Stage) void
set_raw_value(GGobi:Stage *self, guint i (check < N_ROWS), guint j (check < N_COLS), gdouble value)
{
  PARENT_HANDLER(self, self_get_raw_index(SELF(self), i), j, value);
}

/*
 set_string_value and set_categorical_value shouldn't need to be
 overridden, because they call set_raw_value.
*/

/** 
 * get_raw_value:
 * @self: #GGobiStage
 * @i: row index
 * @j: column index
 **/
override (GGobi:Stage) gdouble
get_raw_value(GGobi:Stage *self, guint i (check < N_ROWS), guint j (check < N_COLS))
{
  return PARENT_HANDLER(self, self_get_raw_index(SELF(self), i), j);
}

/**
 * set_rows_in_plot:
 * @self: #GGobiStageFilter object
 *
 * Combine the values in two arrays:
 *   excluded[] (which comes from the exclusion panel or from linking)
 *   sampled[] (which come from the subset panel)
 * to determine which cases should be plotted.
 *
 * rows_in_plot = sampled && !excluded
 **/
private void
set_rows_in_plot(self)
{
  GGobiStage *parent = GGOBI_STAGE(self)->parent;
  guint i;
  guint n_rows_prev = GGOBI_STAGE(self)->n_rows;
  GGOBI_STAGE(self)->n_rows = 0;
  guint *rows_in_plot_prev = g_malloc(n_rows_prev * sizeof(guint));

  for (i=0; i<n_rows_prev; i++)
    rows_in_plot_prev = self->rows_in_plot;

  rows_in_plot = g_realloc(self->n_rows_in_plot, parent->n_rows);
  for (i = 0; i < parent->n_rows; i++)
    if (parent->sampled.els[i] && !parent->excluded.els[i])
      self->rows_in_plot[GGOBI_STAGE(self)->n_rows++] = i;
  rows_in_plot = g_realloc(self->rows_in_plot, GGOBI_STAGE(self)->n_rows);
  
  /* This may need some more thought. If we do not preserve the order of
    the rows, then we can simply add the newly passing rows to the end, allowing
    us to just emit rows_added for them. When rows come to no longer pass
    the filter, rows_deleted will work, if we make it communicate the specific
    rows that were "deleted." Thus, any change in the filter can be expressed
    as rows_added and/or rows_deleted, but we don't need col_data_changed. */
  if (GGOBI_STAGE(self)->n_rows > n_rows_prev)
    ggobi_stage_rows_added(GGOBI_STAGE(self), n);
  else if (GGOBI_STAGE(self)->n_rows < n_rows_prev)
    ggobi_stage_rows_deleted(GGOBI_STAGE(self), n);
  else {
    gboolean changed = false;
    for (i=0; i<GGOBI_STAGE(self)->n_rows; i++) {
      if (rows_in_plot_prev[i] != self->rows_in_plot[i]) {
        changed = true;
        break;
      }
    }
    if (changed) {
      for(guint j = 0; j < self_get_n_data_cols(self); j++) 
        ggobi_stage_col_data_changed(GGOBI_STAGE(self), j);
    }
  }

  g_free(rows_in_plot_prev);
}

} // end class definition
