/*
 
  
*/

%h{
  #include "ggobi-stage.h"
}

%{
  
  /* signal handlers */
  
  static void
  rows_in_plot_changed_cb(GGobi:Stage *stage, guint n)
  {
    ggobi_stage_filter_update_included(SELF(stage), included);
  }
  
  static void
  col_data_changed_cb(GGobiVariable *var, const gchar *name, GGobiStage self)
  {
    // FIXME: check to make sure one of the relevant columns changed
    // like sampled and excluded - but those aren't attributes yet
    set_rows_in_plot (self);
  }

  static void
  rows_added_cb(self, guint n) 
  {
    // FIXME: we can do this more efficiently by only looking at the last n
    set_rows_in_plot (self);
  }

%}

class GGobi:Stage:Filter from GGobi:Stage {

  // parent is GGobi:Data; it is itself the parent of GGobi:Transform

  // These are the indices to be used; n_rows_in_plot is just n_rows.
  protected guint *rows_in_plot;

  private guint
  get_raw_index (self, guint i (check < N_ROWS)) {
    return (self->rows_in_plot[i]);
  }

/**
 * set_missing:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 **/
override (GGobi:Stage) void
set_missing(GGobi:Stage *self (check null type), guint i (check < N_ROWS), 
  guint j (check < N_COLS))
{
  PARENT_HANDLER(self, self_get_raw_index(SELF(self), i), j);
}

/**
 * is_missing:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 *
 * Returns: if value at specified position is missing or not
 **/
override (GGobi:Stage) gboolean
is_missing(GGobi:Stage *self (check null type), guint i (check < N_ROWS), 
  guint j (check < N_COLS)) 
{
  PARENT_HANDLER(self, self_get_raw_index(SELF(self), i), j);  
}

override (GGobi:Stage) gchar*
get_row_id(GGobi:Stage *self (check null type), guint i (check < N_ROWS)) {
  PARENT_HANDLER(self, self_get_raw_index(SELF(self), i));  
}

 // FIXME: This should return the row number after the filter. There needs
 // to be a reverse mapping from raw -> filtered OR we need to hash the labels
override (GGobi:Stage) gint
get_row_for_id(GGobi:Stage *self (check null type), gchar *id (check null)) {
  PARENT_HANDLER(self, self_get_raw_index(SELF(self), i));  
}

/**
 * set_raw_value:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 * @values: vector of new values, of length self->n_rows
 **/
override (GGobi:Stage) void
set_raw_value(GGobi:Stage *self, guint i (check < N_ROWS), guint j (check < N_COLS), gdouble value)
{
  PARENT_HANDLER(self, self_get_raw_index(SELF(self), i), j, value);
}

/** 
 * get_raw_value:
 * @self: #GGobiStage
 * @i: row index
 * @j: column index
 **/
override (GGobi:Stage) gdouble
get_raw_value(GGobi:Stage *self, guint i (check < N_ROWS), guint j (check < N_COLS))
{
  return PARENT_HANDLER(self, self_get_raw_index(SELF(self), i), j);
}

/** 
 * calc_included:
 * @self: #GGobiStageFilter object
 *
 * Combine the values in two arrays:
 *   excluded[] (which comes from the exclusion panel or from linking)
 *   sampled[] (which come from the subset panel)
 * to determine which cases should be plotted.
 **/
private gboolean *
calc_included(self)
{
  gboolean *included = g_new(gboolean, GGOBI_STAGE(self)->parent->n_rows);
  for (guint i = 0; i < GGOBI_STAGE(self)->parent->n_rows; i++)
    included[i] = self->sampled.els[i] && !self->excluded.els[i];
  return(included);
}

/**
 * update_included:
 * @self: #GGobiStageFilter object
 *
 **/
private void
update_included(self)
{
  guint deleted_rows[GGOBI_STAGE(self)->n_rows];
  guint added_rows[GGOBI_STAGE(self)->parent->n_rows];
  guint n_included = 0, n_deleted = 0, n_added = 0;
  guint *included_rows = g_new(guint, GGOBI_STAGE(self)->parent->n_rows);
  gboolean *included = calc_included(self);
  
  for (guint i = 0; i < GGOBI_STAGE(self)->parent->n_rows; i++) {
    if (in_plot[i]) {
      if (!self->included[i])
        added_rows[n_added++] = i;
      else included_rows[n_included++] = i;
    } else if (self->included[i])
      deleted_rows[n_deleted++] = i;
  }
  
  included_rows = g_renew(guint, included_rows, n_included + n_added);
  for (guint i = 0; i < n_added; i++)
    included_rows[n_included + i] = added_rows[i];
  
  if (n_added)
    ggobi_stage_rows_added(self, n_added);
  if (n_deleted)
    ggobi_stage_rows_deleted(self, deleted_rows, n_deleted);
  
  self->included = included;
  self->included_rows = included_rows;
  GGOBI_STAGE(self)->n_rows = n_included;
}

} // end class definition
