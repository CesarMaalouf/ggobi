/*
 
Questions:

gboolean missing and nmissing (does that exist for each variable?)
  could have different values after the filter stage than they had
  before it.

  -- The stage has virtuals for accessing missings, I think you have this right

Signal handling -- need to respond to changes in the values of the
  sampled and excluded vectors (or whatever the precise filter is to
  be) in the parent, as well as to changes in the number of rows.

  -- Listen to col-data-changed and the property for n_rows
  
*/

%{

  // FIXME: temporary
  #include "ggobi-data.h"
  
  /* signal handlers */
  static void
  col_data_changed_cb(GGobiVariable *var, const gchar *name, GGobiStage self)
  {
    set_rows_in_plot (self);
  }

  static void
  rows_added_cb() 
  {
    set_rows_in_plot (self);
  }

%}

class GGobi:Filter from GGobi:Stage {

  // parent is GGobi:Data; it is itself the parent of GGobi:Transform

  // These are the indices to be used; n_rows_in_plot is just n_rows.
  // Initialize null; self_set_rows_in_plot as part of construction?
  // It will always be of dimension parent->n_rows.
  
  // -- I suggest using g_renew() in the notify signal for n_rows OR override
  // the n_rows property setter. I do this in GGobiStage for n_cols and the
  // array of variables.
  private guint *rows_in_plot;

  /* I see that data.gob has missings but stage doesn't;
     filter needs its own value.  Actually, I also don't see
     how data->missings is set.
     
     -- The missings are stored in GGobiData, but accessed through GGobiStage.
     You shouldn't need this field.

     I'm still not clear about this.
  */
  public gboolean missings;

  private guint
  get_raw_index (self, guint i (check < N_ROWS)) {
    return (self->rows_in_plot[i]);
  }

/**
 * set_missing:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 **/
override (GGobi:Stage) void
set_missing(GGobiStage self, guint i (check < N_ROWS), guint j (check < N_ROWS))
{
  SELF me = SELF(self);
  PARENT_HANDLER(self->_priv->parent, self_get_raw_index(me, i), j);
}

/**
 * is_missing:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 *
 * Returns: if value at specified position is missing or not
 **/
override (GGobi:Stage) gboolean
is_missing(GGobiStage self, guint i (check < N_ROWS), guint j (check < N_ROWS)) 
{
  SELF me = SELF(self);
  PARENT_HANDLER(self->_priv->parent, self_get_raw_index(me, i), j);  
}

/*  Other virtual methods that may need to be overridden.

  /* I don't know how this should be set, but this filter's
     value may differ from its parent's. 
     -- You will need to check at the beginning and upon each change in data
     for missings.
     */
     
/*
override (GGobi:Stage) gboolean
has_missings(GGobiStage self)
{
  return SELF(self)->missings;
}
*/

override (GGobi:Stage) gchar*
get_row_id(GGobiStage self, guint i (check < N_ROWS)) {
  SELF me = SELF(self);
  PARENT_HANDLER(self->_priv->parent, self_get_raw_index(me, i));  
}

/* 
   This will return the raw row number, not the row number
   for this stage.  That's probably the right thing to do, but
   we need to work through a case where it's used.
 */
override (GGobi:Stage) gint
get_row_for_id(self, gchar *id) {
  SELF me = SELF(self);
  PARENT_HANDLER(self->_priv->parent, self_get_raw_index(me, i));  
}

/**
 * set_raw_value:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 * @values: vector of new values, of length self->n_rows
 **/
override (GGobi:Stage) void
set_raw_value(GGobiStage self, guint i (check < N_ROWS), guint j (check < N_ROWS), gdouble value)
{
  SELF me = SELF(self);
  self_set_raw_value(self->_priv->parent, 
    self_get_raw_index(me, i), j, value);
}

/*
 set_string_value and set_categorical_value shouldn't need to be
 overridden, because they call set_raw_value.
*/

/** 
 * get_raw_value:
 * @self: #GGobiStage
 * @i: row index
 * @j: column index
 **/
override (GGobi:Stage) gdouble
get_raw_value(GGobiStage self, guint i (check < N_ROWS), guint j (check < N_ROWS))
{
  SELF me = SELF(self);
  return self_get_raw_value(self->_priv->parent, 
    self_get_raw_index(me, i), j);
}

/**
 * set_rows_in_plot:
 * @self: #GGobiData object
 *
 * Combine the values in two arrays:
 *   excluded[] (which comes from the exclusion panel or from linking)
 *   sampled[] (which come from the subset panel)
 * to determine which cases should be plotted.
 *
 * rows_in_plot = sampled && !excluded
 **/
private void
set_rows_in_plot(GGobiStage self)
{
  SELF me = SELF(self);
  GGobiStage *parent = self->_priv->parent;
  guint i;
  guint n_rows_prev = self->n_rows;
  self->n_rows = 0;
  guint *rows_in_plot_prev = g_malloc(n_rows_prev * sizeof(guint));

  for (i=0; i<n_rows_prev; i++)
    rows_in_plot_prev = me->rows_in_plot(

  rows_in_plot = g_realloc(me->n_rows_in_plot, parent->n_rows);
  for (i = 0; i < parent->n_rows; i++)
    if (parent->sampled.els[i] && !parent->excluded.els[i])
      me->rows_in_plot[me->n_rows++] = i;
  rows_in_plot = g_realloc(me->rows_in_plot, me->n_rows);
  
  if (self->n_rows > n_rows_prev)
    ggobi_stage_rows_added(self, n);
  else if (self->n_rows < n_rows_prev)
    ggobi_stage_rows_deleted(self, n);
  else {
    gboolean changed = false;
    for (i=0; i<self->n_rows; i++) {
      if (rows_in_plot_prev[i] != self->rows_in_plot[i]) {
        changed = true;
        break;
      }
    }
    if (changed) {
      for(guint j = 0; j < self_get_n_data_cols(self); j++) 
        ggobi_stage_col_data_changed(self, j);
    }
  }

  g_free(rows_in_plot_prev);
}

} // end class definition
