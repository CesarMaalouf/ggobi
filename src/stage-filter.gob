/*
 
  
*/

%h{
  #include "ggobi-stage.h"
%}

class GGobi:Stage:Filter from GGobi:Stage {

  /* filtered index ==> raw index */
  protected guint *included_rows;
  /* raw index ==> filtered index */
  protected gint *included_rows_rev;
  /* whether a (raw) row passes the filter */
  private gboolean *included;

  // FIXME: we want to override col_data_changed and update when certain
  // columns change.
  override (GGobi:Stage) void
  rows_in_plot_changed(GGobi:Stage *stage, guint n)
  {
    ggobi_stage_filter_update_included(SELF(stage));
  }

  public GObject *
  new(GGobiStage *parent)
  {
    return G_OBJECT(GET_NEW_VARG("parent", parent, NULL));
  }
  
/**
 * set_missing:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 **/
override (GGobi:Stage) void
set_missing(GGobi:Stage *self (check null type), guint i (check < N_ROWS), 
  guint j (check < N_COLS))
{
  PARENT_HANDLER(self, SELF(self)->included_rows[i], j);
}

/**
 * is_missing:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 *
 * Returns: if value at specified position is missing or not
 **/
override (GGobi:Stage) gboolean
is_missing(GGobi:Stage *self (check null type), guint i (check < N_ROWS), 
  guint j (check < N_COLS)) 
{
  return(PARENT_HANDLER(self, SELF(self)->included_rows[i], j));  
}

override (GGobi:Stage) gchar*
get_row_id(GGobi:Stage *self (check null type), guint i (check < N_ROWS)) {
  return(PARENT_HANDLER(self, SELF(self)->included_rows[i]));  
}

override (GGobi:Stage) gint
get_row_for_id(GGobi:Stage *self (check null type), gchar *id (check null)) {
  gint row = PARENT_HANDLER(self, id);
  return(SELF(self)->included_rows_rev[row]);
}

/**
 * set_raw_value:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 * @values: vector of new values, of length self->n_rows
 **/
override (GGobi:Stage) void
set_raw_value(GGobi:Stage *self, guint i (check < N_ROWS), guint j (check < N_COLS), gdouble value)
{
  PARENT_HANDLER(self, SELF(self)->included_rows[i], j, value);
}

/** 
 * get_raw_value:
 * @self: #GGobiStage
 * @i: row index
 * @j: column index
 **/
override (GGobi:Stage) gdouble
get_raw_value(GGobi:Stage *self, guint i (check < N_ROWS), guint j (check < N_COLS))
{
  return PARENT_HANDLER(self, SELF(self)->included_rows[i], j);
}

/** 
 * calc_included:
 * @self: #GGobiStageFilter object
 *
 * Combine the values in two arrays:
 *   excluded[] (which comes from the exclusion panel or from linking)
 *   sampled[] (which come from the subset panel)
 * to determine which cases should be plotted.
 **/
 /* something like this function could probably become virtual eventually,
  allowing subclasses to redefine the filter rules */
private gboolean *
calc_included(self)
{
  gboolean *included = g_new(gboolean, GGOBI_STAGE(self)->parent->n_rows);
  GGOBI_STAGE_ATTR_INIT_ALL(GGOBI_STAGE(self));
  for (guint i = 0; i < GGOBI_STAGE(self)->parent->n_rows; i++)
    included[i] = GGOBI_STAGE_GET_ATTR_VISIBLE(self, i);
  return(included);
}

/**
 * update_included:
 * @self: #GGobiStageFilter object
 *
 **/
private void
update_included(self)
{
  guint deleted_rows[GGOBI_STAGE(self)->n_rows];
  guint added_rows[GGOBI_STAGE(self)->parent->n_rows];
  guint n_included, n_both = 0, n_deleted = 0, n_added = 0;
  guint *included_rows = g_new(guint, GGOBI_STAGE(self)->parent->n_rows);
  gint *included_rows_rev = g_new(gint, GGOBI_STAGE(self)->parent->n_rows);
  gboolean *included = self_calc_included(self);
  
  for (guint i = 0; i < GGOBI_STAGE(self)->parent->n_rows; i++) {
    if (included[i]) {
      if (!selfp->included[i])
        added_rows[n_added++] = i;
      else {
        included_rows_rev[i] = n_both;
        included_rows[n_both++] = i;
      }
    } else {
      included_rows_rev[i] = -1;
      if (selfp->included[i])
        deleted_rows[n_deleted++] = i;
    }
  }
  
  n_included = n_both + n_added;
  included_rows = g_renew(guint, included_rows, n_included);
  for (guint i = 0; i < n_added; i++) {
    included_rows[n_both + i] = added_rows[i];
    included_rows_rev[added_rows[i]] = n_both + i;
  }
  
  if (n_added)
    ggobi_stage_rows_added(GGOBI_STAGE(self), n_added);
  if (n_deleted)
    ggobi_stage_rows_deleted(GGOBI_STAGE(self), deleted_rows, n_deleted);
  
  selfp->included = included;
  self->included_rows = included_rows;
  self->included_rows_rev = included_rows_rev;
  GGOBI_STAGE(self)->n_rows = n_included;
}

} // end class definition
