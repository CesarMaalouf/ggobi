/*
 A simple filter based on a specified boolean column in the data matrix.
 For custom filters, just insert a stage before this one that modifies
 the filter column.
*/

%h{
  #include "ggobi-stage.h"
%}

class GGobi:Stage:Filter from GGobi:Stage {

/* A boolean column that specifies the filter */
private gint filter_column;
property INT filter_column  
  (nick = "fc", blurb = "The index of a boolean column that specifies the included rows",
   flags = CONSTRUCT, minimum = -1, maximum = INT_MAX, default_value = -1, export)
  set { 
    gint filter_column = g_value_get_int(VAL);
    g_return_if_fail(filter_column >= -1 && filter_column < (gint)GGOBI_STAGE(self)->n_cols);
    selfp->filter_column = filter_column;
    /*self_update(self);*/ /* leave this to the user */
  }
  get { g_value_set_int(VAL, selfp->filter_column); };

/* filtered index ==> raw index */
protected guint *included_rows destroywith g_free;
/* raw index ==> filtered index, -1 = filtered */
protected gint *included_rows_rev destroywith g_free;
/* whether a (raw) row passes the filter */
private gboolean *included destroywith g_free;
private guint included_len;

/* incoming */
override (GGobi:Stage) void
process_incoming(GGobi:Stage *stage, GGobiPipelineMessage *msg)
{
  GSList *changed_cols = ggobi_pipeline_message_get_changed_cols(msg);
  guint filter_col = SELF(stage)->_priv->filter_column;
  guint rows_changed = ggobi_pipeline_message_get_n_added_rows(msg) + 
    ggobi_pipeline_message_get_n_removed_rows(msg);
  ggobi_pipeline_message_consume_rows(msg); /* we ignore any row changes */
  PARENT_HANDLER(stage, msg);
  // FIXME: need to check whether filter column has been shifted or removed
  /* rows added, rows removed, or filter column changed: update filter */
  if (rows_changed || g_slist_find(changed_cols, GINT_TO_POINTER(filter_col)))
    self_process_filter(SELF(stage));
  g_slist_free(changed_cols);
}

public GObject *
new(GGobiStage *parent)
{
  GObject *obj = G_OBJECT(GET_NEW_VARG("parent", parent, NULL));
  return obj;
}

public gboolean
is_included(self, guint i)
{
  return selfp->included[i];
}

/* for convenience */
public void
set_included(self, guint i, gboolean val)
{
  g_return_if_fail(selfp->filter_column != -1);
  ggobi_stage_set_raw_value(GGOBI_STAGE(self)->parent, i, selfp->filter_column, (gboolean)val);
}

/* for extra convenience */
public void
set_included_all(self, gboolean value) {
  gint i;
  for (i = 0; i < GGOBI_STAGE(self)->n_rows; i++)
    self_set_included(self, i, value);
}

/**
 * set_missing:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 **/
override (GGobi:Stage) void
set_missing(GGobi:Stage *self (check null type), guint i  (check < N_ROWS), 
  guint j (check < N_COLS))
{
  PARENT_HANDLER(self, SELF(self)->included_rows[i], j);
}

/**
 * is_missing:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 *
 * Returns: if value at specified position is missing or not
 **/
override (GGobi:Stage) gboolean
is_missing(GGobi:Stage *self (check null type), guint i  (check < N_ROWS), 
  guint j (check < N_COLS)) 
{
  return(PARENT_HANDLER(self, SELF(self)->included_rows[i], j));  
}

override (GGobi:Stage) gchar*
get_row_id(GGobi:Stage *self (check null type), guint i  (check < N_ROWS)) {
  return(PARENT_HANDLER(self, SELF(self)->included_rows[i]));  
}

override (GGobi:Stage) gint
get_row_for_id(GGobi:Stage *self (check null type), gchar *id  (check null)) {
  gint row = PARENT_HANDLER(self, id);
  if (row == -1)
    return -1;
  return(SELF(self)->included_rows_rev[row]);
}

/**
 * set_raw_value:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 * @values: vector of new values, of length self->n_rows
 **/
override (GGobi:Stage) void
set_raw_value(GGobi:Stage *self, guint i  (check < N_ROWS), guint j  (check < N_COLS), gdouble value)
{
  PARENT_HANDLER(self, SELF(self)->included_rows[i], j, value);
}

/** 
 * get_raw_value:
 * @self: #GGobiStage
 * @i: row index
 * @j: column index
 **/
override (GGobi:Stage) gdouble
get_raw_value(GGobi:Stage *self, guint i  , guint j  (check < N_COLS))
{
  return PARENT_HANDLER(self, SELF(self)->included_rows[i], j);
}

/** 
 * included:
 * @self: #GGobiStageFilter object
 *
 **/
virtual gboolean *
included(self)
{
  guint parent_nrows = GGOBI_STAGE(self)->parent ? GGOBI_STAGE(self)->parent->n_rows : 0;
  gboolean *included = g_new(gboolean, parent_nrows);
  /*GGOBI_STAGE_ATTR_INIT_ALL(GGOBI_STAGE(self));*/
  for (guint i = 0; i < parent_nrows; i++)
    included[i] = selfp->filter_column == -1 ? TRUE : 
      (gboolean) ggobi_stage_get_raw_value(GGOBI_STAGE(self)->parent, 
        i, selfp->filter_column);
    /*included[i] = GGOBI_STAGE_GET_ATTR_VISIBLE(self, i);*/
  
  return(included);
}

/**
 * update:
 * Convenience method that refreshes the filter and
 * and flushes the queued changes.
 *
 * @self: #GGobiStageFilter object
 *
 **/
public void
update(self)
{
  self_process_filter(SELF(self));
  ggobi_stage_flush_changes_here(GGOBI_STAGE(self));
}

public void
process_filter(self)
{
  guint parent_nrows = GGOBI_STAGE(self)->parent ? GGOBI_STAGE(self)->parent->n_rows : 0;
  GSList *removed_rows = NULL;
  guint added_rows[parent_nrows];
  guint n_included, n_both = 0, n_added = 0;
  guint *included_rows = g_new(guint, parent_nrows);
  gint *included_rows_rev = g_new(gint, parent_nrows);
  gboolean *included = self_included(self);
  
  for (guint i = 0; i < parent_nrows; i++) {
    if (included[i]) {
      if (i >= selfp->included_len || !selfp->included[i])
        added_rows[n_added++] = i;
      else {
        included_rows_rev[i] = n_both;
        included_rows[n_both++] = i;
        //g_debug("included: %d => %d", n_both-1, i);
      }
    } else {
      included_rows_rev[i] = -1;
      if (i < selfp->included_len && selfp->included[i])
        removed_rows = g_slist_prepend(removed_rows, GINT_TO_POINTER(i));
    }
  }
  
  for (guint i = parent_nrows; i < selfp->included_len; i++)
    removed_rows = g_slist_prepend(removed_rows, GINT_TO_POINTER(i));
  
  n_included = n_both + n_added;
  included_rows = g_renew(guint, included_rows, n_included);
  for (guint i = 0; i < n_added; i++) {
    included_rows[n_both + i] = added_rows[i];
    //g_debug("included (added): %d => %d", n_both+i, added_rows[i]);
    included_rows_rev[added_rows[i]] = n_both + i;
  }

  selfp->included_len = parent_nrows;
  selfp->included = included;
  self->included_rows = included_rows;
  self->included_rows_rev = included_rows_rev;
  
  ggobi_stage_rows_removed(GGOBI_STAGE(self), removed_rows);
  g_slist_free(removed_rows);
  ggobi_stage_rows_added(GGOBI_STAGE(self), n_added);
  
  //g_debug("included: %d", n_included);
}

} // end class definition
