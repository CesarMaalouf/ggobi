%h{
  #include <gsf/gsf.h>
  #include "ggobi-data.h"
  #include "ggobi-input-source.h"
%}
%{
  #include <libxml/uri.h>
  #include "ggobi-input-decoder.h"
%}

class GGobi:Data:Factory from G:Object (abstract) {
  
  virtual GSList *
  create(self, GGobi:Input:Source *source  (check null type));
  
  private gint
  is_ext(const gchar *ext, const gchar *path)
  {
    gchar *dot_ext = g_strconcat(".", ext, NULL);
    gint ret = !g_str_has_suffix(path, dot_ext);
    g_free(dot_ext);
    return ret;
  }
  
  virtual gboolean
  supports_source(self, GGobi:Input:Source *source  (check null)) {
    gchar *mode = ggobi_input_source_get_logical_mode(source);
    gchar *p_mode = ggobi_input_source_get_physical_mode(source);
    gboolean supports = FALSE;
    if (mode || p_mode) {
      GSList *modes = self_get_supported_modes(self);
      supports = g_slist_find_custom(modes, mode ? mode : p_mode, (GCompareFunc)strcmp) != NULL;
      g_slist_foreach(modes, (GFunc)g_free, NULL);
      g_slist_free(modes);
      g_free(mode);
    }
    if (!mode && !supports) { /* check file extensions for NULL mode */
      gchar *uri = ggobi_input_source_get_uri(source);
      xmlURIPtr parsed_uri = xmlParseURI(uri);
      if (parsed_uri && parsed_uri->path) {
        GSList *exts = self_get_file_exts_for_mode(self, mode);
        char *unescaped = xmlURIUnescapeString(parsed_uri->path, 0, NULL);
        gint len;
        gchar *utf8_path = g_locale_to_utf8(unescaped, -1, NULL, &len, NULL);
        if (utf8_path) {
          gchar *path = g_utf8_casefold(utf8_path, -1);
          supports = g_slist_find_custom(exts, path, (GCompareFunc)self_is_ext) != NULL;
          g_free(path);
          g_free(utf8_path);
        } else g_warning("Could not convert path '%s' to UTF8", unescaped);
        free(unescaped);
        g_slist_foreach(exts, (GFunc)g_free, NULL);
        g_slist_free(exts);
      }
      if (parsed_uri)
        xmlFreeURI(parsed_uri);
      else g_warning("Could not parse URI: %s", uri);
      g_free(uri);
    }
    return supports;
  }
  
  virtual GSList *
  get_supported_modes(self);
  
  public GSList *
  get_file_exts_for_mode(self, const gchar *mode)
  {
    GType *decoder_types;
    gint i, n_decoder_types;
    GSList *decoded_exts = NULL, *factory_exts, *exts = NULL;
    
    decoder_types = g_type_children(GGOBI_TYPE_INPUT_DECODER, &n_decoder_types);
    
    for (i = 0; i < n_decoder_types; i++) {
      GObject *decoder = g_object_new(decoder_types[i], NULL);
      GSList *d_exts = ggobi_input_decoder_get_decoded_file_exts(GGOBI_INPUT_DECODER(decoder));
      decoded_exts = g_slist_concat(decoded_exts, d_exts);
      g_object_unref(decoder);
    }
    
    factory_exts = self_get_base_file_exts_for_mode(self, mode);
    for (GSList *f_exts = factory_exts; f_exts; f_exts = f_exts->next) {
      exts = g_slist_append(exts, g_strdup(f_exts->data));
      for (GSList *d_exts = decoded_exts; d_exts; d_exts = d_exts->next)
        exts = g_slist_append(exts, g_strconcat(f_exts->data, ".", d_exts->data, NULL));
    }
    
    g_slist_foreach(decoded_exts, (GFunc)g_free, NULL);
    g_slist_free(decoded_exts);
    
    return exts;
  }
  
  virtual GSList *
  get_base_file_exts_for_mode(self, const gchar *mode);
}
