%h{
  #include <gsf/gsf.h>
  #include "ggobi-data.h"
  #include "ggobi-input-source.h"
%}
%{
  #include <libxml/uri.h>
  #include "ggobi-input-decoder.h"
%}

class GGobi:Data:Factory from G:Object (abstract) {
  
  /**
   * create:
   * @self: a #GGobiDataFactory
   * @source: the source from which to retrieve the data
   *
   * Creates a list of #GGobiData objects from the input source. This means that
   * multiple datasets may exist at the source, such as in a GGobi XML file.
   *
   * Returns: #GSList of #GGobiData objects
   */
  virtual GSList *
  create(self, GGobi:Input:Source *source  (check null type));
  
  private gint
  is_ext(const gchar *ext, const gchar *path)
  {
    gchar *dot_ext = g_strconcat(".", ext, NULL);
    gint ret = !g_str_has_suffix(path, dot_ext);
    g_free(dot_ext);
    return ret;
  }
  
  /**
   * supports_source:
   * @self: a #GGobiDataFactory
   * @source: the source to check for compatibility with this factory
   *
   * This checks whether this factory can successfully create a #GGobiData
   * from the input source. This includes checking whether the
   * format of the data makes sense to this factory.
   *
   * Returns: TRUE if this factory supports the input source.
   */
  virtual gboolean
  supports_source(self, GGobi:Input:Source *source  (check null)) {
    gchar *mode = ggobi_input_source_get_logical_mode(source);
    gchar *p_mode = ggobi_input_source_get_physical_mode(source);
    gboolean supports = FALSE;
    if (mode || p_mode) {
      GSList *modes = self_get_supported_modes(self);
      supports = g_slist_find_custom(modes, mode ? mode : p_mode, (GCompareFunc)strcmp) != NULL;
      g_slist_foreach(modes, (GFunc)g_free, NULL);
      g_slist_free(modes);
      g_free(mode);
    }
    if (!mode && !supports) { /* check file extensions for NULL mode */
      gchar *uri = ggobi_input_source_get_uri(source);
      xmlURIPtr parsed_uri = xmlParseURI(uri);
      if (parsed_uri && parsed_uri->path) {
        GSList *exts = self_get_file_exts_for_mode(self, mode);
        char *unescaped = xmlURIUnescapeString(parsed_uri->path, 0, NULL);
        gint len;
        gchar *utf8_path = g_locale_to_utf8(unescaped, -1, NULL, &len, NULL);
        if (utf8_path) {
          gchar *path = g_utf8_casefold(utf8_path, -1);
          supports = g_slist_find_custom(exts, path, (GCompareFunc)self_is_ext) != NULL;
          g_free(path);
          g_free(utf8_path);
        } else g_warning("Could not convert path '%s' to UTF8", unescaped);
        free(unescaped);
        g_slist_foreach(exts, (GFunc)g_free, NULL);
        g_slist_free(exts);
      }
      if (parsed_uri)
        xmlFreeURI(parsed_uri);
      else g_warning("Could not parse URI: %s", uri);
      g_free(uri);
    }
    return supports;
  }
  
  /**
   * get_supported_modes:
   * @self: a #GGobiDataFactory
   *
   * Lists the supported logical "modes" for this factory. Modes are character
   * strings that should uniquely identify a mode or format of data. If the
   * client is aware of the data mode, it does not have to rely on heuristics
   * like file extensions and other magic when finding a compatible factory.
   *
   * Returns: #GSList of mode names
   */
  virtual GSList *
  get_supported_modes(self);
  
  /**
   * get_file_exts_for_mode:
   * @self: a #GGobiDataFactory
   * @mode: a string identifier of a logical data mode
   *
   * Lists the file extensions that correspond to a given mode. This is useful
   * for filtering in file browsers, when the desired mode is known, and for
   * heuristically searching for a compatible factory based on the file extension.
   * This method differs from ggobi_data_factory_get_base_file_exts_for_mode() in
   * that this method also returns extensions concatenated with extensions
   * supported by the available input decoders (such as .gz for gzip compression).
   *
   * Returns: #GSList of file extension strings
   */
  public GSList *
  get_file_exts_for_mode(self, const gchar *mode)
  {
    GType *decoder_types;
    gint i, n_decoder_types;
    GSList *decoded_exts = NULL, *factory_exts, *exts = NULL;
    
    decoder_types = g_type_children(GGOBI_TYPE_INPUT_DECODER, &n_decoder_types);
    
    for (i = 0; i < n_decoder_types; i++) {
      GObject *decoder = g_object_new(decoder_types[i], NULL);
      GSList *d_exts = ggobi_input_decoder_get_decoded_file_exts(GGOBI_INPUT_DECODER(decoder));
      decoded_exts = g_slist_concat(decoded_exts, d_exts);
      g_object_unref(decoder);
    }
    
    factory_exts = self_get_base_file_exts_for_mode(self, mode);
    for (GSList *f_exts = factory_exts; f_exts; f_exts = f_exts->next) {
      exts = g_slist_append(exts, g_strdup(f_exts->data));
      for (GSList *d_exts = decoded_exts; d_exts; d_exts = d_exts->next)
        exts = g_slist_append(exts, g_strconcat(f_exts->data, ".", d_exts->data, NULL));
    }
    
    g_slist_foreach(decoded_exts, (GFunc)g_free, NULL);
    g_slist_free(decoded_exts);
    
    return exts;
  }
  
  /**
   * get_base_file_exts_for_mode:
   * @self: a #GGobiDataFactory
   * @mode: a string identifier of a logical data mode 
   *
   * Lists the file extensions that correspond to a given mode. Normally you
   * should use ggobi_data_factory_get_file_exts_for_mode() above, because
   * it also considers input decoders.
   *
   * Returns: #GSList of file extension strings
   */
  virtual GSList *
  get_base_file_exts_for_mode(self, const gchar *mode);
}
