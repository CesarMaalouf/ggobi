%{
  #include <math.h>
  /* Takes 1/64 degrees to radians and reverses */
  #define CAIRO_ANGLE(x) ((360 - (x/64.)) * M_PI / 180)
  /* millimeters per inch */
  #define MM_PER_INCH 25.4
%}
%h{
  #include "ggobi-renderer.h"
  #include <cairo/cairo-pdf.h>
  #include <cairo/cairo-ps.h>
  #include <cairo/cairo-svg.h>
  #if CAIRO_HAS_GLITZ_SURFACE
  #include <cairo/cairo-glitz.h>
  #ifndef WIN32
  #include <glitz-glx.h>
  #include <gdk/gdkx.h>
  #else
  #include <glitz-wgl.h>
  #endif
  #endif
%}

enum GGOBI_CAIRO_SURFACE {
  DEFAULT, IMAGE, PDF, PS, GLITZ, SVG
} GGobi:Cairo:Surface:Type;

class GGobi:Renderer:Cairo from GGobi:Renderer
{
  private cairo_t *cr destroywith cairo_destroy;
  private cairo_surface_t *surface destroywith cairo_surface_destroy;
  private glitz_surface_t *glitz destroywith glitz_surface_destroy;
  
  private GGobiCairoSurfaceType surface_type;
  property ENUM surface_type
  (nick = "backend", blurb = "The type of cairo surface to use",
   enum_type = GGobi:Cairo:Surface:Type, 
   default_value = GGOBI_CAIRO_SURFACE_DEFAULT, link, flags = CONSTRUCT_ONLY);
  
  private gchar *filename destroywith g_free;
  property STRING filename
  (nick = "fn", blurb = "When using file backends, the output filename",
   link, flags = CONSTRUCT_ONLY);
   
  override (GGobi:Renderer) GdkDrawable *
  create_buffer(GGobi:Renderer *self, guint width, guint height)
  {
    GdkDrawable *buffer = PARENT_HANDLER(self, width, height);
    if (SELF(self)->_priv->cr)
      cairo_destroy(SELF(self)->_priv->cr);
    SELF(self)->_priv->cr = self_create_cairo(SELF(self), buffer);
    g_return_val_if_fail(SELF(self)->_priv->cr != NULL, NULL);
    return buffer;
  }
  
  private virtual cairo_t *
  create_cairo(self, GdkDrawable *buffer)
  {
    cairo_t *cr;
    if (selfp->surface_type == GGOBI_CAIRO_SURFACE_DEFAULT)
      cr = gdk_cairo_create(buffer);
    else {
      cairo_surface_t *surf = NULL;
      gint width, height;
      gdk_drawable_get_size(buffer, &width, &height);
      if (selfp->surface_type == GGOBI_CAIRO_SURFACE_IMAGE)
        surf = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, width, height);
      #if CAIRO_HAS_GLITZ_SURFACE
      else if (selfp->surface_type == GGOBI_CAIRO_SURFACE_GLITZ) {
        /* first get the glitz surface and save a reference */
        selfp->glitz = self_create_glitz(buffer);
        /* wrap a cairo surface around the glitz surface */
        surf = cairo_glitz_surface_create(selfp->glitz);
      }
      #endif
      else {
        width = 72.*width*gdk_screen_width_mm()/gdk_screen_width()/MM_PER_INCH;
        height = 72.*width*gdk_screen_height_mm()/gdk_screen_height()/MM_PER_INCH;
        #if CAIRO_HAS_PDF_SURFACE
        if (selfp->surface_type == GGOBI_CAIRO_SURFACE_PDF)
          surf = cairo_pdf_surface_create(selfp->filename, width, height);
        #endif
        #if CAIRO_HAS_PS_SURFACE
        if (!surf && selfp->surface_type == GGOBI_CAIRO_SURFACE_PS)
          surf = cairo_ps_surface_create(selfp->filename, width, height);
        #endif
        #if CAIRO_HAS_SVG_SURFACE
        if (!surf && selfp->surface_type == GGOBI_CAIRO_SURFACE_SVG)
          surf = cairo_svg_surface_create(selfp->filename, width, height);
        #endif
      }
      g_return_val_if_fail(surf != NULL, NULL);
      selfp->surface = surf;
      cr = cairo_create(surf);
    }
    return cr;
  }
  
  override (GGobi:Renderer) void
  flush(GGobi:Renderer *self, GdkGC *gc, gint xsrc, gint ysrc, 
    gint xdest, gint ydest, gint width, gint height)
  {
    switch(SELF(self)->_priv->surface_type) {
      case GGOBI_CAIRO_SURFACE_PDF:
      case GGOBI_CAIRO_SURFACE_PS:
      case GGOBI_CAIRO_SURFACE_SVG:
        cairo_show_page(SELF(self)->_priv->cr);
      break;
      case GGOBI_CAIRO_SURFACE_IMAGE:
        cairo_surface_write_to_png(SELF(self)->_priv->surface, SELF(self)->_priv->filename);
      break;
      default:
        PARENT_HANDLER(self, gc, xsrc, ysrc, xdest, ydest, width, height);
    }
  }
  
  private void
  line_type(self, GdkGCValues *values)
  {
    cairo_line_cap_t cap = CAIRO_LINE_CAP_ROUND;
    cairo_line_join_t join = CAIRO_LINE_JOIN_ROUND;
    /*static double dashes[8];
    gint i;*/
    
    cairo_set_line_width(selfp->cr, values->line_width+1);
    
    switch(values->cap_style) {
      case GDK_CAP_ROUND:
        cap = CAIRO_LINE_CAP_ROUND;
      break;
      case GDK_CAP_BUTT:
      case GDK_CAP_NOT_LAST:
        cap = CAIRO_LINE_CAP_BUTT;
      break;
      case GDK_CAP_PROJECTING:
        cap = CAIRO_LINE_CAP_SQUARE;
      break;
    }
    cairo_set_line_cap(selfp->cr, cap);
    
    switch(values->join_style) {
      case GDK_JOIN_ROUND:
        join = CAIRO_LINE_JOIN_ROUND;
      break;
      case GDK_JOIN_MITER:
        join = CAIRO_LINE_JOIN_MITER;
        //cairo_set_miter_limit(selfp->cr, gc->lmitre);
      break;
      case GDK_JOIN_BEVEL:
        join = CAIRO_LINE_JOIN_BEVEL;
      break;
    }
    cairo_set_line_join(selfp->cr, join);
    // FIXME: Don't know how to get the dashes out of the GdkGC
    // Perhaps we could extend GdkGC
    /*
    for(i = 0; i < 8 && gc->lty & 15; i++) {
      dashes[i] = gc->lty & 15;
      gc->lty = gc->lty >> 4;
    }
  
    
    cairo_set_dash(cr, dashes, i, 0);*/
  }
  
  private void
  stroke(self, GdkGC *gc, gboolean filled)
  {
    GdkColor color;
    GdkGCValues values;
    GdkColormap *colors = gdk_gc_get_colormap(gc);
    gdk_gc_get_values(gc, &values);
    gdk_colormap_query_color(colors, values.foreground.pixel, &color);
    //g_debug("color: %d %d %d", color.red, color.green, color.blue);
    gdk_cairo_set_source_color(selfp->cr, &color);
    if (filled) {
      /*gdk_colormap_query_color(colors, values.background.pixel, &color);
      g_debug("background color: %d %d %d", color.red, color.green, color.blue);
      gdk_cairo_set_source_color(selfp->cr, &color);*/
      cairo_fill_preserve(selfp->cr);
    }
    self_line_type(self, &values);
    cairo_stroke(selfp->cr);
  }
  private void
  polypath(self, guint npoints, GdkPoint *points)
  {
    gint i;
    cairo_move_to(selfp->cr, points[0].x, points[0].y);
    for (i = 1; i < npoints; i++)
      cairo_line_to(selfp->cr, points[i].x, points[i].y);
  }
  
  override (Gdk:Drawable) void 
  draw_rectangle (GdkDrawable  *self, GdkGC *gc, gboolean filled,
    gint x, gint y, gint width, gint height)
  {
    //g_debug("drawing rect: %d %d %d %d", x, y, width, height);
    cairo_rectangle(SELF(self)->_priv->cr, x, y, width, height);
    self_stroke(SELF(self), gc, filled);
  }
  override (Gdk:Drawable) void 
  draw_arc(GdkDrawable  *self, GdkGC *gc, gboolean filled, gint x, gint y, 
    gint width, gint height, gint angle1, gint angle2)
  {
    //cairo_move_to(cr, x+r, y);
    cairo_t *cr = SELF(self)->_priv->cr;
    cairo_save(cr);
    cairo_translate (cr, x + width / 2., y + height / 2.);
    cairo_scale (cr, (width / 2.), (height / 2.));
    //g_debug("drawing arc from: %f to %f", CAIRO_ANGLE(angle2), CAIRO_ANGLE(angle1));
    cairo_arc_negative (cr, 0., 0., 1., CAIRO_ANGLE(angle1), CAIRO_ANGLE(angle2));
    self_stroke(SELF(self), gc, filled);
    cairo_restore(cr);
  }
  override (Gdk:Drawable) void 
  draw_polygon(GdkDrawable  *self, GdkGC *gc, gboolean filled, 
    GdkPoint *points, gint npoints)
  {
    //g_debug("POLYGON");
    self_polypath(SELF(self), npoints, points);
    cairo_close_path(SELF(self)->_priv->cr);
    self_stroke(SELF(self), gc, filled);
  }
  override (Gdk:Drawable) void 
  draw_points(GdkDrawable  *self, GdkGC *gc, GdkPoint *points, gint npoints)
  {
    guint i;
    //g_debug("POINTS");
    cairo_t *cr = SELF(self)->_priv->cr;
    for (i = 0; i < npoints; i++)
      cairo_rectangle(cr, points[i].x - 0.5, points[i].y - 0.5, 1., 1.);
    self_stroke(SELF(self), gc, FALSE);
  }
  override (Gdk:Drawable) void 
  draw_segments(GdkDrawable  *self, GdkGC *gc, GdkSegment *segs, gint nsegs)
  {
    guint i;
    //g_debug("SEGMENTS");
    cairo_t *cr = SELF(self)->_priv->cr;
    for (i = 0; i < nsegs; i++) {
      cairo_move_to(cr, segs[i].x1, segs[i].y1);
      cairo_line_to(cr, segs[i].x2, segs[i].y2);
    }
    self_stroke(SELF(self), gc, FALSE);
  }
  override (Gdk:Drawable) void 
  draw_lines(GdkDrawable  *self, GdkGC *gc, GdkPoint *points, gint npoints)
  {
    self_polypath(SELF(self), npoints, points);
    self_stroke(SELF(self), gc, FALSE);
  }
  override (Gdk:Drawable) void 
  draw_trapezoids(GdkDrawable *self, GdkGC *gc, GdkTrapezoid *trapezoids, 
    gint n_trapezoids)
  {
    guint i;
    cairo_t *cr = SELF(self)->_priv->cr;
    for (i = 0; i < n_trapezoids; i++) {
      cairo_move_to(cr, trapezoids[i].x11, trapezoids[i].y1);
      cairo_line_to(cr, trapezoids[i].x21, trapezoids[i].y1);
      cairo_line_to(cr, trapezoids[i].x22, trapezoids[i].y2);
      cairo_line_to(cr, trapezoids[i].x12, trapezoids[i].y2);
      cairo_line_to(cr, trapezoids[i].x11, trapezoids[i].y1);
    }
    self_stroke(SELF(self), gc, FALSE);
  }
  
  //#ifdef CAIRO_HAS_GLITZ_SURFACE
  /* glitz utilities */
  private glitz_surface_t *
  create_glitz(GdkDrawable * drawable)
  {
    gint width, height;
    glitz_drawable_t *glitz_d = NULL;
    glitz_surface_t *glitz_s;
    glitz_format_t *format;
    glitz_drawable_buffer_t buffer_type;
    glitz_drawable_format_t *d_format;
    GdkVisual *visual = gdk_drawable_get_visual(drawable);
    GdkDisplay *display = gdk_drawable_get_display(drawable);
    
    g_return_val_if_fail (visual != NULL, NULL);
    gdk_drawable_get_size (drawable, &width, &height);
    
  #ifndef WIN32
    {
      Display *dpy = gdk_x11_display_get_xdisplay(display);
      /* First, get drawable format - may need to do this separately for
         windows and pbuffers, but maybe this visual trick will work */
      d_format = glitz_glx_find_drawable_format_for_visual (dpy, 
        DefaultScreen (dpy), GDK_VISUAL_XVISUAL(visual)->visualid);
      g_return_val_if_fail(d_format != NULL, NULL);
      /* now create a glitz drawable depending on whether we are drawing to a
         window or something off-screen */
      if (GDK_IS_WINDOW (drawable))
        glitz_d = glitz_glx_create_drawable_for_window (dpy, DefaultScreen (dpy),
          d_format, GDK_WINDOW_XID(GDK_WINDOW(drawable)), width, height);
      else
        glitz_d = glitz_glx_create_pbuffer_drawable (dpy, DefaultScreen (dpy),
          d_format, width, height);
    }
    
  #else
      // windows implementation
  #endif
  
    g_return_val_if_fail (glitz_d != NULL, NULL);
    /* if we have a glitz drawable, get a glitz format */
    format = glitz_find_standard_format (glitz_d, GLITZ_STANDARD_ARGB32);
    g_return_val_if_fail(format != NULL, NULL);
    /* use the glitz format to create a glitz surface */
    glitz_s = glitz_surface_create (glitz_d, format, width, height, 0, NULL);
    /* buffer type depends on whether drawable is double buffered */
    if (d_format->doublebuffer)
      buffer_type = GLITZ_DRAWABLE_BUFFER_BACK_COLOR;
    else buffer_type = GLITZ_DRAWABLE_BUFFER_FRONT_COLOR;
    /* attach the glitz surface to the glitz drawable */
    glitz_surface_attach(glitz_s, glitz_d, buffer_type);
    
    /* cleanup */
    glitz_drawable_destroy(glitz_d);
    
    return (glitz_s);
  }
  //#endif
}
