%h{
  #include "vars.h"
%}
%{
  #include <libxml/parser.h>

  typedef enum xmlDataState
  {
    TOP = 0,
    DATASET, DESCRIPTION,
    RECORD, RECORDS, VARIABLES, VARIABLE,
    COLORMAP, COLOR,
    REAL_VARIABLE, CATEGORICAL_VARIABLE,
    INTEGER_VARIABLE, COUNTER_VARIABLE, UNIFORM_VARIABLE,
    CATEGORICAL_LEVELS, CATEGORICAL_LEVEL,
    COLORSCHEME,
    BRUSHSTYLE,
    REAL, INTEGER, STRING, NA,
    QUICK_HELP,
    EDGES, EDGE,
/* HELP, DESCRIPTION */
    UNKNOWN
  } XmlTagType;

  typedef struct
  {

    int color;
    int glyphType;
    int glyphSize;
    int edgeWidth;/*-- this has no home in ggobi --*/
    int hidden;

  } DataOptions;

  typedef struct _XMLUserData
  {
    enum xmlDataState state;
    gint current_variable;      /* Indexes the current variable. */
    gint current_record;        /* Indexes the record we are currently working on. */
    gint current_element;       /* Indexes the values within a record. */
    gint current_level;         /* */
    gint current_level_value;   /* Level value inside <level> */
    gint current_nlevels;       /* Level count inside <levels> */
    gchar *current_level_name;  /* Level name inside <level> character data */
    gchar *current_name;        /* Variable name inside <variable> character data */

    guint *var_to_col;

    gint current_color;         /* The index of the current element
                                   being processed in the colormap */

    xmlChar *recordString;
    int recordStringLength;

    /* Flag that says we are reading color entries from another file via a
     * sub-parser.  This allows us to reuse the same instance of user data
     * and the same handlers.
     */
    gboolean reading_colormap_file_p;

    /* A boolean indicating whether the transformation name of a variable
       was stored as an attribute.
     */
    gboolean variable_transform_name_as_attribute;

    /* The current data object to which new records are added. */
    GGobiStage *current_data;
    /*  The list of all datad's read. */
    GSList *dlist;

    /* Flag indicating whether we should convert
       char arrays into null-terminated strings
       before passing them to the sub-handlers
       (e.g. set_colorValue, set_variable_name).
     */
    gboolean terminateStrings_p;

    /* The datasets global missing value identifier. */
    gchar *NA_identifier;
    /* The identifier for a missing value that is currently in effect.
       This might be specified per record and will be discarded
       at the end of that record.
       We could also do this columnwise.
     */
    gchar *current_NA_identifier;

    /* A set of values that apply to records when an attribute
       is not specified for that specific record but is set
       in the ggobiata tag.
     */
    DataOptions defaults;

    /* Local set of record identifiers that are used here
       for matching purposes when specifying edges.
       These are not set in the datad structure and 
       are different from the record's label attribute.
       Currently these are used to verify that the id's are unique
       within a dataset.
     */
    GHashTable *idNamesTable;

    GHashTable *idTable;
    gboolean usesStringIds;     /* this is now unused; it's always true */

    gint recordLabelsVariable;

    gboolean *autoLevels;

    gint counterVariableIndex;

    /* Reference to the handlers being used as callbacks.
       Need this so that we can re-specify it when creating
       new sub-parsers.
     */
    xmlSAXHandlerPtr handlers;


    /*
       The number of datasets to expect within the file.
     */
    int expectedDatasetCount;
    
    /*
      The source of the data
    */
    GGobiInputSource *input_source;

    xmlParserCtxtPtr parser;

  } XMLParserData;
%}

%{
  #include <libxml/parserInternals.h>
  #include <gsf/gsf-libxml.h>
  #include <stdlib.h>
  #include <string.h>
  #include <strings.h>
  #include <gtk/gtk.h>
  #include <glib/gprintf.h>

  #include "externs.h"
  #include "GGobiAPI.h"

  /*
     The different XML element names we recognize in the input format.

     countervariable is an automatic convenience  variable that generates
     a new variable in the dataset that does not have corresponding entries
     in the input file. For each record, we generate a value which is the
     index in the dataset of that record (starting at 1).

     Along the same lines, we now have randomuniformvariable. This
     is another automatic variable whose values are generated by the
     act of reading the dataset. 
     I am not certain that this belongs here. It is not reproducible.
     It doesn't generalize to different distributions, or even transformations
     of the U(0, 1) distribution. Perhaps having this feature implemented via
     a plugin which uses the new_datad event signal to add variables to a dataset.
     There is a disconnect between what the author of the dataset wants and
     what the plugin knows. So, having this may well be necessary. 
     One can of course use a scripting language (e.g. R, Python, ...) to 
     create the dataset externall.

     One can have any number of randomuniformvariable elements in a dataset,
     which is different from the countervariable. This is implemented by 
     introducing a new variable type (like categorical, real, ...)
     in the GGobiVariableType enumeration in ggobi-variable.h. This means that we have
     to update code to handle this element in the switch statements
     and this is error-prone. (We can easily overlook some of the switch statements
     and get odd behavior). We would rather have the  GGobiVariable data structure as
     a class and have methods for it. Switch statements are simply not extensible.
     For this case, we only have to update vartable_nbook.c.

   */
  static const gchar *const xmlDataTagNames[] = {
    "ggobidata",
    "data",                     /* DATASET */
    "description",
    "record",
    "records",
    "variables",
    "variable",
    "colormap",
    "color",
    /* variables */
    "realvariable",
    "categoricalvariable",
    "integervariable",
    "countervariable",
    "randomuniformvariable",
    "levels",
    "level",
    /* color scheme */
    "activeColorScheme",
    /* brushing attributes: color first; later, glyph type and size */
    "brush",
    /* data values */
    "real",
    "int",
    "string",
    "na",
    "quickHelp",
    "edges",
    "edge",
    ""
  };
%}

/*
   This is a SAX based parser for reading a single input file
   formatted in XML for the DTD specified in ggobi.dtd.

   SAX is an event based parser. As different elements of the document
   are encountered by the parser on its input stream, it invokes
   user-specified callbacks. For our purposes, we currently need only
   handle 3 event types:
      1) the start of a tag
      2) the end of a tag  
      3) regular text data within a tag

   As with all event driven approaches, we can specify a user-level
   data object that can is passed to each event handler/callback.
   This is used to parameterize the particular call. In our case,
   we pass an XMLParserData * object (defined in read_xml.h).
   This basically stores what state in the document we currently have
   and indicates how to interpret the future callbacks, and also
   the GGobiSession structure which we are attempting to fill in.
   Additionally, it maintains a list of default settings that are 
   to be applied to each row, but which can be set generically in the
   top-level element (GGobiSessionata).
  

   When we encounter the start of tag, we are given the tag name, the
   list of attributes for the tag instance and a reference to the
   parser instance XMLParserData object we specified at the start of the
   parsing. This handler is start_xml_element.  Here, we dispatch
   a call to the appropriate method based on the tag name. Generally,
   this either allocates storage space in the GGobiSession structure being
   filled in, or stores partial information needed to do this.
   Additionally, for the tag GGobiSessionata, the attributes are processed
   to store the default values for record attributes. These are
   attributes such as color, glyph (size and type). 

   As each tag is encountered, we convert its type to an enumerated
   type and store this as the pending state. This is used to determine
   how to interpret ASCII text within an element.

   When we encounter the end of a tag/element,  the routine
   end_xml_element is called. We use this to increment counters indicating
   which record, variable or edge is next in the stream. These are 
   quasi-global variables that are parser-instance specific and a
   necessary consquence of the event-driven style of parsing.

   Finally, when ASCII text within an XML element is discovered by the
   parser, the routine characters() is called. We call different
   routines (setRecordsValues() and set_variable_name()) based on the
   state of the parsing. This was set at the start of each tag/element
   in start_xml_element. 
 
 */

class GGobi:Data:Factory:XML from GGobi:Data:Factory
{
  public GGobiDataFactoryXML *
  new (void)
  {
    GObject *obj = (GObject *)GET_NEW;
    return (GGOBI_DATA_FACTORY_XML (obj));
  }

  //interface GGobi:Data:Factory private GSList *
  override (GGobi:Data:Factory) GSList *
  create_for_input (GGobi:Data:Factory * self (check null type), 
    Gsf:Input *input  (check null type))
  {
    return self_read_xml_data (input);
  }

  private gboolean 
  is_xml_file (const gchar *fileName)
  {
    gchar *extension = strrchr (fileName, '.');
    gboolean is_xml = false;
    if (extension) {
      is_xml = !g_ascii_strcasecmp(extension, "xml");
      g_free(extension);
    }
    return(is_xml);
  }

  //interface GGobi:Data:Factory private GSList *
  override (GGobi:Data:Factory) GSList *
  get_supported_modes (GGobi:Data:Factory *self (check null type))
  {
    return g_slist_append (NULL, g_strdup("xml"));
  }

  //interface GGobi:Data:Factory private GSList *
  override (GGobi:Data:Factory) GSList *
  get_base_file_exts_for_mode(GGobi:Data:Factory *self (check null type), const gchar *mode) 
  {
    GSList *exts = NULL;
    if (!mode || !strcmp(mode, "xml"))
      exts = g_slist_append(exts, g_utf8_casefold("xml", -1));
    return exts;
  }
  
  private GSList *read_xml_data (Gsf:Input * input)
  {
    xmlSAXHandlerPtr xmlParserHandler = g_new0(xmlSAXHandler, 1);
    XMLParserData data;
    xmlParserCtxtPtr ctx;
    GSList *dlist;
    
    ctx = gsf_xml_parser_context(input);
    
    xmlParserHandler->startElement = self_start_xml_element;
    xmlParserHandler->endElement = self_end_xml_element;
    xmlParserHandler->characters = self_characters;
    xmlParserHandler->error = self_error_handler;
    xmlParserHandler->warning = self_warning_handler;
    
    self_init_parser_data(&data, xmlParserHandler);
    data.parser = ctx;
    /*data.input_source = source;*/
    data.dlist = NULL;
    
    ctx->sax = xmlParserHandler;
    ctx->userData = &data;
    
    xmlParseDocument(ctx);
    dlist = data.dlist;

    ctx->sax = NULL;
    xmlFreeParserCtxt(ctx);
    g_free(xmlParserHandler);
    
    return (dlist);
  }

  private void
    init_parser_data (XMLParserData * data, xmlSAXHandlerPtr handler)
  {
    data->current_record = 0;
    data->current_variable = 0;
    data->current_element = 0;
    data->current_data = NULL;
    data->current_level_value = 0;
    data->current_level_name = NULL;

    data->current_color = 0;
    data->reading_colormap_file_p = false;
    data->state = UNKNOWN;
    data->terminateStrings_p = true;
    data->NA_identifier = NULL;

    data->handlers = handler;
    data->defaults.color = -1;
    data->defaults.glyphType = sessionOptions->info->glyph.type;
    data->defaults.glyphSize = sessionOptions->info->glyph.size;
    data->defaults.edgeWidth = -1;/*-- this has no home in ggobi --*/
    data->defaults.hidden = false;

    data->recordString = NULL;
    data->recordStringLength = 0;

    data->autoLevels = NULL;

    data->idNamesTable = NULL;
  }

/********************** SAX HANDLERS **************************/

  private void
    start_xml_element (void *user_data, const xmlChar * name,
                       const xmlChar ** attrs)
  {
    XMLParserData *data = (XMLParserData *) user_data;
    enum xmlDataState type = self_tag_type (name, false);

    switch (type)
      {
      case COLORSCHEME:
        self_set_color_scheme (attrs, data);
        break;
      case VARIABLES:
        self_alloc_variables (attrs, data);
        break;
      case VARIABLE:
      case REAL_VARIABLE:
      case INTEGER_VARIABLE:
      case CATEGORICAL_VARIABLE:
      case UNIFORM_VARIABLE:
        self_new_variable (attrs, data, name);
        break;
      case COUNTER_VARIABLE:
        self_new_variable (attrs, data, name);
        data->counterVariableIndex = data->current_variable;
        break;

      case CATEGORICAL_LEVELS:
        self_categorical_levels (attrs, data);
        break;
      case CATEGORICAL_LEVEL:
        self_set_level_index (attrs, data);
        break;

      case RECORDS:
        self_set_dataset_info (attrs, data);
        break;
      case TOP:
        self_set_general_info (attrs, data);
        break;
      case EDGE:
      case RECORD:
        self_new_record (attrs, data);
        break;
      case COLORMAP:
        /*set_colorMap(attrs, data); *//* requires some thought ... */
        break;
      case BRUSHSTYLE:
        self_set_brush_style (attrs, data);
        break;
      case COLOR:
        /*set_colormapEntry(attrs, data); *//* ditto .... */
        break;
      case DESCRIPTION:
        /* description text pending */
        break;
      case EDGES:
      case DATASET:
        self_set_dataset (attrs, data, type);
        break;

      case REAL:
      case INTEGER:
      case STRING:
      case NA:
        if (data->recordString)
          {
            self_set_record_values (data, data->recordString,
                               data->recordStringLength);
            if (type != NA && type != STRING)
              data->current_element++;
            self_reset_record_info (data);
          }
        break;
      case QUICK_HELP:
        break;
      default:
        fprintf (stderr, "Unrecognized XML state %s\n", name);
        fflush (stderr);
        break;
      }

    data->state = type;
  }

  private void end_xml_element (void *user_data, const xmlChar * name)
  {
    XMLParserData *data = (XMLParserData *) user_data;
    enum xmlDataState type = self_tag_type (name, true);

    switch (type)
      {
      case EDGES:
        self_resolve_edge_ids (data);
      case DATASET:
        {
          GGobiStage *d = self_get_current_xml_data (data);

          self_set_edge_partners (data);
          self_release_current_data_info (data);
          if (data->current_record < d->n_rows)
            {
              g_error
                ("There are fewer records than declared for '%s': %d < %d.",
                 d->name, data->current_record, d->n_rows);
            }

          data->dlist = g_slist_append (data->dlist, d);

        }
        break;

      case EDGE:
        if (data->current_element < data->current_data->n_cols)
          {
            self_error_handler (data, "Not enough elements\n");
          }
        data->current_record++;
        break;
      case RECORD:
        self_set_record_values (data, data->recordString,
                           data->recordStringLength);
        data->current_record++;
        self_reset_record_info (data);
        break;
      case NA:
        ggobi_stage_set_missing (self_get_current_xml_data (data),
                                 data->current_record, data->current_element);
        data->current_element++;
        break;
      case REAL:
      case INTEGER:
      case STRING:
        /* This is the individual set_record_value(), i.e. with no 's' at the end. */
        // NOTE: for strings, we need to make sure variable is categorical
        self_set_record_value ((const char *) data->recordString,
                          data->current_data, data);
        data->current_element++;
        break;
      case VARIABLE:
        self_end_variable (data);
      case REAL_VARIABLE:
      case CATEGORICAL_VARIABLE:
      case COUNTER_VARIABLE:
      case INTEGER_VARIABLE:
      case UNIFORM_VARIABLE:
        data->current_variable++;
        break;
      case COLOR:
        data->current_color++;
        break;
      case COLORMAP:
        break;
      case CATEGORICAL_LEVELS:
        break;
      case CATEGORICAL_LEVEL:
        self_end_categorical_level (data);
        break;
      case TOP:
        /* resolve all the edges */
        self_resolve_all_edge_ids (data);
        break;
      default:
        data = NULL;            /* just any code so we can stop. */
        break;
      }

    if (data)
      {
        self_reset_record_info (data);
        data->state = UNKNOWN;
      }
  }

/*
  Called when data within an element is found by the parser.
  Note that the parser does not have to give us all the data
  in one go (although it usually does). Instead,
  it can make several calls to this routine for the same
  element instances. E.g 
    <text>
      a few words
     and another sentence
    </text>
   may result in two calls - one for each sentence.

   This is important to handle as it means that we must be prepared
   to read values within a record across different calls and remember
   which variable/column we last completed for this record.
   This is the current_element field in XMLParserData. 
   Additionally, if a variable name is split across multiple calls
   we must append subsequent calls to the initial value.
  

   Additionally, new lines and leading and trailing white space 
   are not removed. Hence, we must do this ourselves. We use
   skip_white_space to move to first non-whitespace character in the
   string.

   Also, the text is given to us as a a sequence of bytes rather than
   a non-terminated string. Thus, we are told the number of bytes
   rather than being able to use strlen to compute the length of the
   string.
   If the flag terminateStrings is set in the XMLParserData instance,
   this routine takes care of copying the data into a regularly
   NULL-terminated string so that the routines to which the data
   is passed can work with it more easily.
 */
  private void 
  characters (void *user_data, const xmlChar * ch, gint len)
  {
    gchar *tmp = NULL;
    gint dlen = len;
    const xmlChar *c;
    XMLParserData *data = (XMLParserData *) user_data;

    c = (const xmlChar *) self_skip_white_space (ch, &dlen);
    if (dlen < 1 || c[0] == '\n')
      return;

    if (data->terminateStrings_p)
      {
        tmp = g_strndup ((const gchar *) c, (gsize) dlen);
        c = (const xmlChar *) tmp;
      }

    switch (data->state)
      {
      case NA:
      case RECORD:
      case REAL:
      case STRING:
      case INTEGER:
      case UNKNOWN:
        /* Now we call
           after gathering the entire string for the record so that we
           don't get bizarre splits such as  "1.3 1.4 1"  followed by ".4..."
         */
        self_cumulate_record_data (data, c, dlen);
        break;
      case VARIABLE:
      case CATEGORICAL_VARIABLE:
      case REAL_VARIABLE:
      case UNIFORM_VARIABLE:
        self_set_variable_name (data, c, dlen);
        break;
      case COLOR:
        break;
      case CATEGORICAL_LEVEL:
        self_add_level (data, (const gchar *) c, dlen);
        break;
      default:
        break;
      }

    if (data->terminateStrings_p)
      {
        g_free (tmp);
      }
  }

/********************* COLOR SCHEMES *************************/

  private void set_color_scheme (const xmlChar ** attrs, XMLParserData * data)
  {
    #ifdef BRUSH_IN_XML
    const gchar *tmp;

    tmp = self_get_attribute (attrs, "file");
    if (tmp)
      {
        /* process this file to append its color schemes into the global list. */
        read_colorscheme ((gchar *) tmp, &sessionOptions->colorSchemes);
      }

    tmp = self_get_attribute (attrs, "name");
    if (tmp)
      {
        /* resolve the color scheme by name */

        colorschemed *scheme;
        scheme = findColorSchemeByName (data->gg->colorSchemes, tmp);
        if (scheme)
          {
            data->gg->activeColorScheme = scheme;
            colorscheme_init (scheme);
          }
        else
          self_error_handler (data,
                         "Invalid colorscheme name %s. No such scheme.\n",
                         tmp);
      }
    else
      {
        self_error_handler (data, "No colorscheme name specified\n");
      }
      #endif
  }

/*************************** VARIABLES **************************/

/*
   Read the declaration of a variable, gathering its information
   from the specified attributes.
   This includes its name, transformation name, etc.

   Called in response to a <variable>, <realvariable> or
   <categoricalvariable> tag.
 */

  private gboolean
    new_variable (const xmlChar ** attrs, XMLParserData * data,
                  const xmlChar * tagName)
  {
    const gchar *tmp, *tmp1;
    GGobiStage *d = self_get_current_xml_data (data);
    GGobiVariable *el;

    if (data->current_variable >= ggobi_stage_get_n_vars (d))
      {
        self_error_handler
          (data,
           "More variables (%d) than given in the <variables count='%d'> element for dataset %s\n",
           data->current_variable, ggobi_stage_get_n_vars (d), d->name);
        return (false);
      }

    el = ggobi_stage_get_variable (d, data->current_variable);

    data->variable_transform_name_as_attribute = false;

    tmp = self_get_attribute (attrs, "name");
    ggobi_variable_set_name (el, (gchar *) tmp);

    tmp = self_get_attribute (attrs, "nickname");
    if (tmp != NULL)
      ggobi_variable_set_nickname (el, (gchar *) tmp);


    tmp = self_get_attribute (attrs, "min");
    tmp1 = self_get_attribute (attrs, "max");
    if (tmp && tmp1)
      {
        gdouble mn, mx;
        mn = as_number (tmp);
        mx = as_number (tmp1);
        el->lim_specified.min = mn < mx ? mn : mx;
        el->lim_specified.max = mn > mx ? mn : mx;

        if (mn > mx)
          {
            g_printerr ("Minimum is greater than maximum for variable %s\n",
                        ggobi_variable_get_name (el));
          }
        el->lim_specified_p = true;
      }


    if (strcmp ((const char *) tagName, "categoricalvariable") == 0)
      {
        ggobi_data_set_col_type (GGOBI_DATA (d), data->current_variable,
                                 GGOBI_VARIABLE_CATEGORICAL);

        /* Mark this as being a variable for which we must compute the levels. */
        if ((tmp = self_get_attribute (attrs, "levels"))
            && strcmp (tmp, "auto") == 0)
          {
            if (data->autoLevels == NULL)
              {
                data->autoLevels =
                  g_new0 (gboolean, data->current_data->n_cols);
              }
            data->autoLevels[data->current_variable] = true;
          }
      }
    else if (strcmp ((const char *) tagName, "integervariable") == 0)
      {
        ggobi_data_set_col_type (GGOBI_DATA (d), data->current_variable,
                                 GGOBI_VARIABLE_INTEGER);
      }
    else if (strcmp ((const char *) tagName, "countervariable") == 0)
      {
        ggobi_data_set_col_type (GGOBI_DATA (d), data->current_variable,
                                 GGOBI_VARIABLE_COUNTER);
      }
    else if (strcmp ((const char *) tagName, "randomuniformvariable") == 0)
      {
        ggobi_data_set_col_type (GGOBI_DATA (d), data->current_variable,
                                 GGOBI_VARIABLE_UNIFORM);
      }                         /* real by default */

/* This is now disabled - sorry if people like it
  tmp = get_attribute (attrs, "time");
  if (tmp && (strcmp (tmp, "yes") == 0 || strcmp (tmp, "true") == 0)) {
    el->isTime = true;
  }
*/

    return (true);
  }

/*
   Reads the number of variables in the dataset from the attributes
   and allocates space for them in the GGobiSession structure.
   At this point, we have the number of records and variables
   and can initialize the data areas of the GGobiSession structure.

    Called in response to a <variables> tag. (Note the plural.)
 */
  private gboolean
    alloc_variables (const xmlChar ** attrs, XMLParserData * data)
  {
    const gchar *tmp = self_get_attribute (attrs, "count");
    GGobiStage *d = self_get_current_xml_data (data);

    if (tmp == NULL)
      {
        g_error ("No count for variables attribute\n");
      }

    ggobi_data_add_cols (GGOBI_DATA (d), atoi (tmp));
    ggobi_data_add_attributes (GGOBI_DATA (d));
    data->var_to_col = ggobi_stage_translate_var_to_col (d);

    return (true);
  }

  private void end_variable (XMLParserData * data)
  {
    GGobiStage *d = self_get_current_xml_data (data);
    ggobi_stage_set_col_name (d, data->current_element, data->current_name);
    g_free (data->current_name);
    data->current_name = NULL;
  }

/*
  Reads the text in name and assigns it as the name of the
  variable currently being read within the 
  <variable> tag. The index for the variable is stored in 
  data->current_variable.

   Called when parsing free-formatted text within a <variable> tag.
 */
  private gboolean
    set_variable_name (XMLParserData * data, const xmlChar * name, gint len)
  {
    gchar *tmp = g_strndup ((const gchar *) name, (gsize) len);

    /* Handle the case where we have multiple calls to the characters
       handler for the same variable because the data is split
     */
    if (data->current_name != NULL)
      {
        /* need to append tmp to the existing value. */
        gchar *name = g_strconcat (data->current_name, tmp, NULL);
        g_free (data->current_name);
        data->current_name = name;
      }
    else
      data->current_name = g_strdup (tmp);

    g_free (tmp);

    return (true);
  }

  private gint set_level_index (const xmlChar ** attrs, XMLParserData * data)
  {
    const gchar *tmp = self_get_attribute (attrs, "value");
    gint itmp;
    GGobiStage *d = self_get_current_xml_data (data);

/*-- dfs: placeholder for proper debugging --*/
    if (data->current_level >= data->current_nlevels)
      {
       self_warning_handler (data, "adding too many levels to %s\n",
                         ggobi_stage_get_col_name (d,
                                                   data->current_variable));
      }
/* */

    itmp = data->current_level + 1;
    if (tmp != NULL)
      {
        itmp = atoi (tmp);
      }
    data->current_level_value = itmp;

    return (data->current_level++);
  }

  private void
    categorical_levels (const xmlChar ** attrs, XMLParserData * data)
  {
    GGobiStage *d = self_get_current_xml_data (data);

    const gchar *tmp = self_get_attribute (attrs, "count");

    data->current_nlevels = G_MAXINT;
    if (tmp != NULL)
      {
        data->current_nlevels = atoi (tmp);
        if (data->current_nlevels < 1)
          {
            self_error_handler (stderr, "Level count for %s mis-specified\n",
                           ggobi_stage_get_col_name (d,
                                                     data->current_variable));
          }
      }

    data->current_level = 0;
  }

  private void add_level (XMLParserData * data, const gchar * c, gint len)
  {
    /*
     * This is a kludge, I admit, but if a level name includes special
     * characters (such as &), the string is somehow fed into this
     * routine in pieces.  This section of code glues the separate
     * pieces back together again.  -- dfs
     */
    if (data->current_level_name)
      {
        gchar *tmp = g_strconcat (data->current_level_name, c, NULL);
        g_free (data->current_level_name);
        data->current_level_name = tmp;
      }
    else
      data->current_level_name = g_strdup (c);
  }

  private void end_categorical_level (XMLParserData * data)
  {
    GGobiStage *d = self_get_current_xml_data (data);
    GGobiVariable *var = ggobi_stage_get_variable (d, data->current_variable);
    ggobi_variable_add_level (var, data->current_level_name,
                              data->current_level_value);
    g_free (data->current_level_name);
    data->current_level_name = NULL;
  }

/*************************** EDGES *****************************/

  private void resolve_edge_ids (XMLParserData * parserData)
  {

  }

  private void resolve_all_edge_ids (XMLParserData * parserData)
  {

  }

  private gint edge_compare (const void *val1, const void *val2)
  {
    const SortableEndpoints *e1 = (const SortableEndpoints *) val1;
    const SortableEndpoints *e2 = (const SortableEndpoints *) val2;
    gint acomp, bcomp;

    acomp = strcmp (e1->a, e2->a);
    bcomp = strcmp (e1->b, e2->b);

    if (acomp < 0 || (acomp == 0 && bcomp < 0))
      return (-1);
    else if (acomp == 0 && bcomp == 0)
      return (0);
    else
      return (1);
  }

  private void set_edge_partners (XMLParserData * parserData)
  {
    GGobiStage *e = self_get_current_xml_data (parserData);
    SortableEndpoints *ep;
    gint i, k, n;
    gboolean dups = false;

    if (!ggobi_stage_get_n_edges (e))
      return;

    n = 2 * ggobi_stage_get_n_edges (e);
    ep = (SortableEndpoints *) g_malloc (n * sizeof (SortableEndpoints));

  /*-- Assume that we have no edges from i to i --*/

    /*
     * Before setting partners, check for duplicate edges.  If we find
     * one, bail out -- we don't handle them correctly, and we don't
     * want them around.
     */

    for (i = 0, k = 0; i < ggobi_stage_get_n_edges (e); i++)
      {
        ep[k].a =
          g_strdup ((gchar *) ggobi_stage_get_edge_data (e)->sym_endpoints[i].
                    a);
        ep[k].b =
          g_strdup ((gchar *) ggobi_stage_get_edge_data (e)->sym_endpoints[i].
                    b);
        ep[k].jcase = i;
        k++;
      }
    qsort ((gchar *) ep, ggobi_stage_get_n_edges (e),
           sizeof (SortableEndpoints), self_edge_compare);

    for (i = 1; i < ggobi_stage_get_n_edges (e); i++)
      {
        k = i - 1;
        if (strcmp (ep[i].a, ep[k].a) == 0 && strcmp (ep[i].b, ep[k].b) == 0)
          {
            g_critical ("Found duplicate edge from %s to %s",
                        (gchar *) ggobi_stage_get_edge_data (e)->
                        sym_endpoints[ep[i].jcase].a,
                        (gchar *) ggobi_stage_get_edge_data (e)->
                        sym_endpoints[ep[i].jcase].b);
            dups = true;
          }
      }
    if (dups)
      g_error ("Duplicate edges found");


  /*-- If there are no dups, add the reverse of each edge and re-sort --*/
    for (i = 0, k = ggobi_stage_get_n_edges (e);
         i < ggobi_stage_get_n_edges (e); i++)
      {
        ep[k].a =
          g_strdup ((gchar *) ggobi_stage_get_edge_data (e)->sym_endpoints[i].
                    b);
        ep[k].b =
          g_strdup ((gchar *) ggobi_stage_get_edge_data (e)->sym_endpoints[i].
                    a);
        ep[k].jcase = i;
        k++;
      }
    qsort ((gchar *) ep, n, sizeof (SortableEndpoints), self_edge_compare);


    for (i = 1; i < n; i++)
      {
        k = i - 1;
        if (strcmp (ep[i].a, ep[k].a) == 0 && strcmp (ep[i].b, ep[k].b) == 0)
          {
            ggobi_stage_get_edge_data (e)->sym_endpoints[ep[i].jcase].
              jpartner = ep[k].jcase;
            ggobi_stage_get_edge_data (e)->sym_endpoints[ep[k].jcase].
              jpartner = ep[i].jcase;
          }
      }

    for (i = 0; i < n; i++)
      {
        g_free (ep[i].a);
        g_free (ep[i].b);
      }
    g_free (ep);
  }

/*************************** DATA  *****************************/

  private void
  cumulate_record_data (XMLParserData * data, const xmlChar * ch, gint len)
  {
    data->recordString = (xmlChar *) g_realloc (data->recordString,
                                                (len +
                                                 data->recordStringLength +
                                                 1) * sizeof (xmlChar));
    memcpy (data->recordString + data->recordStringLength, ch,
            len * sizeof (xmlChar));
    data->recordStringLength += len;
    data->recordString[data->recordStringLength] = '\0';

    return;
  }



/**
  Called in response to a ggobidata tag which contains
  the different datasets. The count element here is the
  number of datasets to expect.
 */
  private gboolean
    set_general_info (const xmlChar ** attrs, XMLParserData * data)
  {
    const gchar *tmp = self_get_attribute (attrs, "count");

    if (tmp != NULL)
      {
        data->expectedDatasetCount = atoi (tmp);
      }

    tmp = self_get_attribute (attrs, "ids");

    return (true);
  }


  private gboolean
    set_dataset_info (const xmlChar ** attrs, XMLParserData * data)
  {
    const gchar *tmp = self_get_attribute (attrs, "count");
    GGobiStage *d = self_get_current_xml_data (data);

    if (tmp == NULL)
      {
        g_error ("No count attribute");
      }

    ggobi_data_add_rows (GGOBI_DATA (d), atoi (tmp));

    // GGOBI_DATA (d)->edge.n = 0;

    self_set_default_dataset_values (attrs, data);

    data->current_variable = 0;
    data->current_record = 0;
    data->current_variable = 0;
    data->current_element = 0;

    return (true);
  }

  private gboolean
    set_default_dataset_values (const xmlChar ** attrs, XMLParserData * data)
  {
    const gchar *tmp = self_get_attribute (attrs, "missingValue");
    if (tmp != NULL)
      {
        data->NA_identifier = g_strdup (tmp);
      }

    self_set_glyph (attrs, data, -1);
    self_set_color (attrs, data, -1);
    self_set_hidden (attrs, data, -1);
    return (true);
  }

  private gboolean new_record (const xmlChar ** attrs, XMLParserData * data)
  {
    self_read_xml_record (attrs, data);

    return (true);
  }

  private gboolean
    set_hidden (const xmlChar ** attrs, XMLParserData * data, gint i)
  {
    const gchar *tmp;
    GGobiStage *d = self_get_current_xml_data (data);

    GGOBI_STAGE_ATTR_INIT_ALL (d);
    tmp = self_get_attribute (attrs, "hidden");
    if (tmp)
      {
        gboolean hidden = as_logical (tmp);

        if (i < 0)
          {
            data->defaults.hidden = hidden;
          }
        else
          GGOBI_STAGE_SET_ATTR_HIDDEN (d, i, hidden, ATTR_SET_SAVE);
      }

    return (tmp != NULL);
  }

  private gboolean
    set_color (const xmlChar ** attrs, XMLParserData * data, gint i)
  {
    const gchar *tmp;
    gint value = data->defaults.color;
    GGobiStage *d = self_get_current_xml_data (data);
    GGOBI_STAGE_ATTR_INIT_ALL (d);
    /*colorschemed *scheme = data->gg->activeColorScheme;*/

    tmp = self_get_attribute (attrs, "color");
    if (tmp)
      {
        value = atoi (tmp);
      }

    if (value < 0 || value >= MAXNCOLORS)
      {
        if (tmp)
          self_xml_warning ("color", tmp, "Out of range", data);
      }
    else
      {
        if (i < 0)
          data->defaults.color = value;
        else
          GGOBI_STAGE_SET_ATTR_COLOR (d, i, value, ATTR_SET_SAVE);
      }

    return (value != -1);
  }

  private gboolean
    set_glyph (const xmlChar ** attrs, XMLParserData * data, gint i)
  {
    const gchar *tmp;
    gint size, type;
    GGobiStage *d = self_get_current_xml_data (data);

/*
 * glyphSize  0:7
*/
    size = data->defaults.glyphSize;
    tmp = self_get_attribute (attrs, "glyphSize");
    if (tmp)
      {
        size = atoi (tmp);
      }

    if (size < 0 || size >= NGLYPHSIZES)
      {
        if (tmp)
          self_xml_warning ("glyphSize", tmp, "Out of range", data);
      }
    else
      {
        if (i < 0)
          data->defaults.glyphSize = size;
      }

/*
 * glyphType  0:6
*/
    type = data->defaults.glyphType;
    tmp = self_get_attribute (attrs, "glyphType");
    if (tmp)
      {
        /*
         * make sure this attribute is an integer; if someone puts a
         * string here, like "plus" or "fc", value = 0 and the mistake
         * isn't caught later when value is tested.
         */
        type = mapGlyphName (tmp);
        if (type == UNKNOWN_GLYPH)
          {
            if (tmp[0] < '0' || tmp[0] > '6')
              {
                g_error
                  ("%s is an illegal value for glyphType; it must be on [0,6]",
                   tmp);
              }

            type = atoi (tmp);
          }
      }
    if (type < 0 || type >= NGLYPHTYPES)
      {
        if (tmp)
          self_xml_warning ("glyphType", tmp, "Out of range", data);
      }
    else
      {
        if (i < 0)
          data->defaults.glyphType = type;
      }

/*
 * glyph:  strings like "plus 3" or "."
*/
    tmp = self_get_attribute (attrs, "glyph");
    if (tmp != NULL)
      {
        const gchar *next;
        gint j;
        next = tmp;
        next = strtok ((gchar *) tmp, " ");
        j = 0;
        while (next)
          {
            if (j == 0)
              {                 /* type */
                type = mapGlyphName (next);
                if (i < 0)
                  {
                    data->defaults.glyphType = type;
                  }
              }
            else
              {                 /* size */
                size = atoi (next);
                if (i < 0)
                  {
                    if (size >= 0 && size < NGLYPHTYPES)
                      {
                        data->defaults.glyphSize = size;
                      }
                    else
                      {
                        self_xml_warning ("File error:", next,
                                     "glyph improperly specified", data);
                      }
                  }
              }
            j++;
            next = strtok (NULL, " ");
          }
      }

    if (i >= 0)
      {
        if (type != -1)
          type = data->defaults.glyphType;
        if (size != -1)
          type = data->defaults.glyphSize;
        GGOBI_STAGE_ATTR_INIT_ALL (d);

        if (type != -1)
          GGOBI_STAGE_SET_ATTR_TYPE (d, i, type, ATTR_SET_SAVE);
        if (size != -1)
          GGOBI_STAGE_SET_ATTR_SIZE (d, i, size, ATTR_SET_SAVE);
      }


    return (size != -1 && type != -1);
  }

  private void
    xml_set_value (GGobiStage * d, XMLParserData * data, gdouble value)
  {
    guint col = data->var_to_col[data->current_element];
    ggobi_stage_set_raw_value (d, data->current_record, col, value);
  }

  private void apply_random_uniforms (GGobiStage * d, XMLParserData * data)
  {
    gint j, ncols = ggobi_stage_has_vars (d);
    for (j = data->current_element; j < ncols &&
         ggobi_stage_get_col_type (d, j) == GGOBI_VARIABLE_UNIFORM; j++)
      {
        self_xml_set_value (d, data, g_random_double ());
      }
  }

  private gboolean
    set_record_value (const char *tmp, GGobiStage * d, XMLParserData * data)
  {
    gdouble value;

    /* If we have a counter variable in this dataset, check whether the
       cursor is at that. */
    if (data->counterVariableIndex > -1 &&
        data->current_element == data->counterVariableIndex)
      {
        self_xml_set_value (d, data, data->current_record + 1);
        data->current_element++;
      }

    /* If reading past the last column or row, stop */
    if (data->current_record >= d->n_rows ||
        data->current_element >= d->n_cols)
      {
        g_printerr ("Row %d (counting from 1) has too many elements\n",
                    data->current_record + 1);
        data->current_element = 0;
        return (false);
      }

    self_apply_random_uniforms (d, data);
    if (!ggobi_stage_has_vars (d))
      return (true);

    /*
     * this is a missing value if 
     *  1. the file does not specify a string and this string is either
     *     "na", "NA", or ".", or
     *  2. the file specifies a string for NA and this is that string
     */
    if ((data->NA_identifier == NULL &&
         (strcmp (tmp, "na") == 0 ||
          strcmp (tmp, "NA") == 0 ||
          strcmp (tmp, ".") == 0)) ||
        (data->NA_identifier && strcmp (tmp, data->NA_identifier) == 0))
      {
        ggobi_stage_set_missing (d, data->current_record,
                                 data->current_element);
      }
    else
      {
        GGobiVariable *var =
          ggobi_stage_get_variable (d, data->current_element);
        value = as_number (tmp);
        if (GGOBI_VARIABLE_IS_CATEGORICAL (var))
          {
            if (data->autoLevels && data->autoLevels[data->current_element])
              {
                ggobi_stage_set_categorical_value (d, data->current_record,
                                                   data->current_element,
                                                   tmp);
              }
            else
              {
                if (!ggobi_variable_has_level (var, value))
                  {
                    self_warning_handler (data,
                                     "incorrect level in record %d, variable `%s', dataset `%s' in the XML input file\n",
                                     (int) data->current_record + 1,
                                     ggobi_variable_get_name (var),
                                     data->current_data->name ? data->
                                     current_data->name : "");
                  }
                self_xml_set_value (d, data, value);
              }
          }
        else if (data->state == STRING)
          {
            self_error_handler (data,
                           "<string> element for non categorical variable (%s) in record %d\n",
                           ggobi_variable_get_name (var),
                           (int) data->current_record + 1);
            value = 0;
          }
        else
          self_xml_set_value (d, data, value);
      }

    return (true);
  }

/*
  Read the values for this record from free-formatted text. The entries
  are white-space delimited. They should not have quotes or anything
  that needs to be escaped.
*/
  private gboolean
    set_record_values (XMLParserData * data, const xmlChar * line, gint len)
  {
    const gchar *tmp;
    GGobiStage *d = self_get_current_xml_data (data);

    gint ncols = ggobi_stage_get_n_vars (d);

    if (!line)
      {
        self_apply_random_uniforms (d, data);
        return (false);
      }
    tmp = strtok ((gchar *) line, " \t\n");

    while (tmp && (tmp < (gchar *) (line + len)))
      {
        /*
           g_printerr("current element %d token %s\n", data->current_element,
           tmp);
         */
        if (self_set_record_value (tmp, d, data) == false)
          return (false);
        data->current_element++;
        tmp = strtok (NULL, " \t\n");
        /*    printf("%d %d \n",data->current_record,ncols); */
      }
    if (data->current_element < ncols)
      {
        self_error_handler (data, "Not enough elements\n");
        /*    printf("%d %d \n",data->current_record,data->current_element); */
        /*
           g_printerr ("Record %d has insufficient elements: %d < %d\n",
           data->current_record, data->current_element,
           ggobi_stage_get_n_vars(d));
         */
      }

    //apply_random_uniforms (d, data);
    return (true);
  }

  private gboolean
    set_dataset (const xmlChar ** attrs, XMLParserData * parserData,
                 enum xmlDataState type)
  {
    GGobiData *data = ggobi_data_new (0, 0);
    const gchar *name, *nickname;
    gchar /* *my_name, */*my_nickname;

    name = self_get_attribute (attrs, "name");
    /*if (!name)
      my_name = ggobi_input_source_get_display_name(parserData->input_source);
    else my_name = g_strdup(name);*/
    ggobi_stage_set_name (GGOBI_STAGE(data), (gchar *) name);
    /*g_free(my_name);*/
    
    nickname = self_get_attribute (attrs, "nickname");
    if (!nickname)
      my_nickname = g_strdup(name);
    else my_nickname = g_strdup(nickname);
    ggobi_data_set_nickname (data, my_nickname);
    g_free(my_nickname);
    
    /*ggobi_data_set_source(data, parserData->input_source);*/
    
    parserData->current_data = GGOBI_STAGE(data);
    parserData->counterVariableIndex = -1;

    if (type == EDGES)
      {
        self_set_dataset_info (attrs, parserData);
      }

    return (true);
  }


  private GGobiStage *get_current_xml_data (XMLParserData * parserData)
  {
    GGobiStage *data = parserData->current_data;
    if (data == NULL)
      {
        data = GGOBI_STAGE (ggobi_data_new (0, 0));
        parserData->current_data = data;
      }
    /*ggobi_data_set_source(GGOBI_DATA(data), parserData->input_source);*/
    return (data);
  }

  private gboolean
    read_xml_record (const xmlChar ** attrs, XMLParserData * data)
  {
    GGobiStage *d = self_get_current_xml_data (data);
    const gchar *tmp;
    gint i = data->current_record;

    if (i == d->n_rows)
      {
        g_error ("There are more records than declared for '%s'; exiting.",
                 d->name);
      }

    data->current_element = 0;

    self_set_color (attrs, data, i);
    self_set_glyph (attrs, data, i);
    self_set_hidden (attrs, data, i);

    tmp = self_get_attribute (attrs, "id");
    if (tmp)
      {
        gint m = ggobi_stage_get_row_for_id (d, (gchar *) tmp);
        /* every row has an id now - if 'tmp' is the same as the default id,
           we should not report an error */
        if (m != data->current_record)
          self_error_handler (data,
                         "duplicated id (%s) in records %d and %d of dataset %s\n",
                         (gchar *) tmp,
                         data->current_record + 1,
                         m + 1, data->current_data->name);
        ggobi_stage_set_row_id (d, (guint) i, (gchar *) tmp);
      }

/*
 * Probably something's missing here:  if edges should be
 * present, then every record should have a source and an
 * endpoint, and there's no validation going on now. --dfs
*/

    /* Read the edge source and destination pair if, present. */
    tmp = self_get_attribute (attrs, "source");
    if (tmp != (const gchar *) NULL)
      {
        const gchar *dest;
        dest = self_get_attribute (attrs, "destination");
        if (!dest)
          {
            self_xml_warning ("edge specification error:", tmp,
                         "source but no destination attribute for record.",
                         data);
            return (true);
          }
        if (strcmp (tmp, dest) == 0)
          {
            self_xml_warning ("edge specification error:", tmp,
                         "source is the same as destination for record.",
                         data);
            return (true);
          }

        if (ggobi_stage_get_edge_data (d)->sym_endpoints == NULL)
          {
            // GGOBI_DATA (d)->edge.n = d->n_rows;
            //g_debug("no endpoints yet, allocating space for: %d", ggobi_stage_get_n_edges (d));
            // GGOBI_DATA (d)->edge.sym_endpoints = (SymbolicEndpoints *)
              // g_malloc (sizeof (SymbolicEndpoints) *
                        // ggobi_stage_get_n_edges (d));
          }
          //g_debug("setting edge record: %d", data->current_record);
        // ggobi_stage_get_edge_data (d)->sym_endpoints[data->current_record].a =
        //   self_intern (data, tmp);
        // ggobi_stage_get_edge_data (d)->sym_endpoints[data->current_record].b =
        //   self_intern (data, dest);
        // ggobi_stage_get_edge_data (d)->sym_endpoints[data->current_record].
        //   jpartner = -1;
      }

    return (true);
  }

/* Routines for walking the hash table and getting all the row labels
   into an array. */

  private void get_row_label (gpointer key, gpointer val, gchar ** labels)
  {
    if (val)
      {
        labels[*(guint *) val] = (gchar *) key;
      }
  }

  private gchar **get_row_labels_from_table (GHashTable * tbl, gchar ** names)
  {
    if (!names)
      names =
        (gchar **) g_malloc (sizeof (gchar *) * g_hash_table_size (tbl));

    g_hash_table_foreach (tbl, (GHFunc) self_get_row_label, names);

    return (names);
  }

/*************************** CLEANUP ***************************/

  private void reset_record_info (XMLParserData * data)
  {
    if (data->recordString)
      g_free (data->recordString);

    data->recordString = NULL;
    data->recordStringLength = 0;
  }

  private void
    free_level_hash_entry (gpointer key, gpointer value, gpointer data)
  {
    g_free (value);
    if (data)
      g_free (key);
  }

  private void release_current_data_info (XMLParserData * parserData)
  {
    if (!parserData->current_data)
      return;

    if (parserData->autoLevels)
      {
        g_free (parserData->autoLevels);
        parserData->autoLevels = NULL;
      }
  }

/*************************** MISC ******************************/
  private gboolean
    set_brush_style (const xmlChar ** attrs, XMLParserData * data)
  {
    gboolean retval = true;
    #ifdef BRUSH_FROM_XML
    const gchar *tmp;
    gint value;
    tmp = self_get_attribute (attrs, "color");
    if (tmp != NULL)
      {
        colorschemed *scheme = data->gg->activeColorScheme;
        value = atoi (tmp);
        if (value >= 0 && value < scheme->n)
          {
            data->gg->color_id = value;
          }
        else
          {
            self_xml_warning ("File error:", tmp,
                         "brushing color improperly specified", data);
            return false;
          }
      }

/*
 * glyphType  0:6
*/
    tmp = self_get_attribute (attrs, "glyphType");
    if (tmp != NULL)
      {
        /*
         * make sure this attribute is an integer; if someone puts a
         * string here, like "plus" or "fc", value = 0 and the mistake
         * isn't caught later when value is tested.
         */
        if (tmp[0] < '0' || tmp[0] > '6')
          {
            self_xml_warning ("brushing glyphType", tmp, "Must be on [0,6]\n",
                         data);
            return false;
          }
        value = mapGlyphName (tmp);
        if (value == UNKNOWN_GLYPH)
          value = atoi (tmp);

        if (value < 0 || value >= NGLYPHTYPES)
          {
            self_xml_warning ("glyphType", tmp, "Out of range", data);
            return false;
          }
        else
          {
            data->gg->glyph_id.type = value;
          }
      }

/*
 * glyphSize  0:7
*/
    tmp = self_get_attribute (attrs, "glyphSize");
    if (tmp != NULL)
      {
        value = atoi (tmp);

        if (value < 0 || value >= NGLYPHSIZES)
          {
            self_xml_warning ("glyphSize", tmp, "Out of range", data);
          }
        else
          {
            data->gg->glyph_id.size = value;
          }
      }


    tmp = self_get_attribute (attrs, "glyph");
    if (tmp != NULL)
      {
        const gchar *next;
        gint j;
        next = tmp;
        next = strtok ((gchar *) tmp, " ");
        j = 0;
        while (next)
          {
            if (j == 0)
              {                 /* type */
                value = mapGlyphName (next);
                data->gg->glyph_id.type = value;
              }
            else
              {                 /* size */
                value = atoi (next);
                if (value >= 0 && value < NGLYPHTYPES)
                  {
                    data->gg->glyph_id.size = value;
                  }
                else
                  {
                    self_xml_warning ("File error:", next,
                                 "brushing glyph improperly specified", data);
                    retval = false;
                  }
              }
            j++;
            next = strtok (NULL, " ");
          }
      }
    #endif
    return retval;
  }

/*************************** UTILITIES *************************/

  private gchar *intern (XMLParserData * data, const char *el)
  {
    gchar *ans;

    if (data->idNamesTable == NULL)
      {
        data->idNamesTable = g_hash_table_new (g_str_hash, g_str_equal);
      }

    ans = g_hash_table_lookup (data->idNamesTable, el);
    if (!ans)
      {
        ans = g_strdup (el);
        g_hash_table_insert (data->idNamesTable, ans, ans);
      }
    return (ans);
  }

/*
 Prints the attributes.
 For debugging.
*/
  private void show_attributes (const xmlChar ** attrs)
  {
    const xmlChar **tmp;
    tmp = attrs;
    while (tmp && tmp[0])
      {
        g_printerr ("\t %s=%s\n", tmp[0], tmp[1]);
        tmp += 2;
      }
  }

  private void
    xml_warning (const gchar * attribute, const gchar * value,
                 const gchar * msg, XMLParserData * data)
  {
    self_warning_handler (data, "%s %s: value = %s\n", attribute, msg, value);
  }

  private const gchar *
  get_attribute (const xmlChar ** attrs, gchar * name)
  {
    const xmlChar **tmp = attrs;
    while (tmp && tmp[0])
      {
        if (strcmp (name, (const gchar *) tmp[0]) == 0)
          return ((const gchar *) tmp[1]);
        tmp += 2;
      }

    return (NULL);
  }

  private const xmlChar *
  skip_white_space (const xmlChar * ch, gint * len)
  {
    const xmlChar *tmp = ch;
    while (*len >= 0)
      {
        if (*len == 0 || (tmp[0] != ' ' && tmp[0] != '\t' && tmp[0] != '\n'))
          break;
        tmp++;
        (*len)--;
      }

    return (tmp);
  }

  private XmlTagType tag_type (const xmlChar * name, gboolean endTag)
  {
    gint n = sizeof (xmlDataTagNames) / sizeof (xmlDataTagNames)[0] - 1;
    gint i;
    const gchar *tmp = (const gchar *) name;
    /*
       if(endTag) {
       tmp++;
       }
     */

    for (i = 0; i < n; i++)
      {
        if (strcmp (tmp, xmlDataTagNames[i]) == 0)
          {
            return ((enum xmlDataState) i);
          }
      }

    return (UNKNOWN);
  }

  private void warning_handler (void *data, const gchar * msg, ...)
  {
    va_list ap;
    xmlParserCtxtPtr p = (xmlParserCtxtPtr) ((XMLParserData *) data)->parser;

    va_start (ap, msg);
    g_warning ("XML parsing [%d, %d]: ",
               (int) p->input->line, (int) p->input->col);

    g_vfprintf (stderr, msg, ap);

    fflush (stderr);
  }
  private void error_handler (void *data, const gchar * msg, ...)
  {
    va_list ap;
    xmlParserCtxtPtr p = (xmlParserCtxtPtr) ((XMLParserData *) data)->parser;

    g_critical ("XML parsing [line %d, column %d]: ",
                (int) p->input->line, (int) p->input->col);

    va_start (ap, msg);
    g_vfprintf (stderr, msg, ap);

    fflush (stderr);
  }

}
