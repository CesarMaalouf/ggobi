%{
  // FIXME: temporary
  #include "ggobi-input-source.h"
  #include "ggobi-data.h"
  #include "vars.h"
  #include "externs.h"
%}

%h{
#include "ggobi-variable.h"
#include "ggobi-pipeline-message.h"
#include "utils.h"

/* temporarily */
#include "defines.h"
#include "brushing.h"
#include "fileio.h"

/* for use in GOB parameter checks like: guint j (check < N_COLS) */
#define N_COLS GGOBI_STAGE(self)->n_cols
#define N_ROWS GGOBI_STAGE(self)->n_rows

/* shorthand for checking whether a column refers to a categorical variable */
#define GGOBI_STAGE_IS_COL_CATEGORICAL(stage, col) \
  ggobi_stage_get_col_type((stage), (col)) == GGOBI_VARIABLE_CATEGORICAL

// FIXME: do we really need this? macros that declare variables are messy...
#define GGOBI_STAGE_VARIABLES_ITERATE(stage) \
  guint* var_to_col = ggobi_stage_translate_var_to_col((stage)); \
  guint jj = 0; \
  for(guint j = 0; jj < ggobi_stage_get_n_vars(stage); jj++, j = var_to_col[jj]) 

// Macros for getting and setting attribute values
// -----------------------------------------------

/* FIXME: Is there some way around having macros that declare variables
   in the current scope? What about storing the attribute index inside the 
   stage via methods named get/set_active_col(). There could be macros for
   setting the active col for a particular attribute. Then get/set_active_value()
   would modify the values. This might not work well when setting multiple
   attributes at once. One way to solve this problem and the one above
   (iterating only over the variables) is to make it easy to create different
   "views" of a stage with regard to column indexing. This could be done
   with additional pipeline stages, but that may be overkill.
*/

#define GGOBI_STAGE_ATTR_INIT(d, attribute) \
  guint attr_ ## attribute; \
  (attr_ ## attribute = ggobi_stage_get_col_index_for_name(d, "_" #attribute))

#define GGOBI_STAGE_BRUSH_ATTR_INIT(d, attribute) \
  guint attr_ ## attribute [3]; \
  (attr_ ## attribute[0] = ggobi_stage_get_col_index_for_name(d, "_" #attribute)); \
  (attr_ ## attribute[1] = ggobi_stage_get_col_index_for_name(d, "_" #attribute "_now")); \
  (attr_ ## attribute[2] = ggobi_stage_get_col_index_for_name(d, "_" #attribute "_prev"))

#define GGOBI_STAGE_ATTR_INIT_ALL(d) \
  GGOBI_STAGE_BRUSH_ATTR_INIT(d, color); \
  GGOBI_STAGE_BRUSH_ATTR_INIT(d, size); \
  GGOBI_STAGE_BRUSH_ATTR_INIT(d, hidden); \
  GGOBI_STAGE_BRUSH_ATTR_INIT(d, type); \
  \
  GGOBI_STAGE_ATTR_INIT(d, sampled); \
  GGOBI_STAGE_ATTR_INIT(d, excluded); \
  GGOBI_STAGE_ATTR_INIT(d, cluster)
  
#define GGOBI_STAGE_SET_ATTR(d, i, attribute, value, brush) \
  ggobi_stage_set_attr(d, i, attr_ ##attribute[0], attr_ ##attribute[1], attr_ ##attribute[2], (gdouble) value, brush)
#define GGOBI_STAGE_GET_ATTR(d, i, attribute) \
  ggobi_stage_get_attr(d, i, attr_ ##attribute[0], attr_ ##attribute[1], attr_ ##attribute[2])
#define GGOBI_STAGE_RESET_ATTR(d, i, attribute, brush) \
  ggobi_stage_reset_attr(d, i, attr_ ##attribute[0], attr_ ##attribute[1], attr_ ##attribute[2], brush)

#define GGOBI_STAGE_SET_ATTR_COLOR(d, i,  value, brush)  GGOBI_STAGE_SET_ATTR(d, i, color,  value, brush)
#define GGOBI_STAGE_SET_ATTR_TYPE(d, i,   value, brush)  GGOBI_STAGE_SET_ATTR(d, i, type,   value, brush)
#define GGOBI_STAGE_SET_ATTR_SIZE(d, i,   value, brush)  GGOBI_STAGE_SET_ATTR(d, i, size,   value, brush)
#define GGOBI_STAGE_SET_ATTR_HIDDEN(d, i, value, brush)  GGOBI_STAGE_SET_ATTR(d, i, hidden, value, brush)
#define GGOBI_STAGE_SET_ATTR_SAMPLED(d, i, value)        ggobi_stage_set_raw_value(d, i, attr_sampled, (gdouble) value)
#define GGOBI_STAGE_SET_ATTR_EXCLUDED(d, i, value)       ggobi_stage_set_raw_value(d, i, attr_excluded, (gdouble) value)
#define GGOBI_STAGE_SET_ATTR_CLUSTER(d, i, value)        ggobi_stage_set_raw_value(d, i, attr_cluster, (gdouble) value)

#define GGOBI_STAGE_GET_ATTR_COLOR(d, i )   ((gushort) GGOBI_STAGE_GET_ATTR(d, i, color  ))
#define GGOBI_STAGE_GET_ATTR_TYPE(d, i  )   ((gint) GGOBI_STAGE_GET_ATTR(d, i, type   ))
#define GGOBI_STAGE_GET_ATTR_SIZE(d, i  )   ((gint) GGOBI_STAGE_GET_ATTR(d, i, size   ))
#define GGOBI_STAGE_GET_ATTR_HIDDEN(d, i)   ((gboolean) GGOBI_STAGE_GET_ATTR(d, i, hidden ))
#define GGOBI_STAGE_GET_ATTR_SAMPLED(d, i)  (ggobi_stage_get_raw_value(d, i, attr_sampled))
#define GGOBI_STAGE_GET_ATTR_EXCLUDED(d, i) ((gboolean) ggobi_stage_get_raw_value(d, i, attr_excluded))
#define GGOBI_STAGE_GET_ATTR_VISIBLE(d, i)  true //(GGOBI_STAGE_GET_ATTR_SAMPLED(d, i) && !GGOBI_STAGE_GET_ATTR_EXCLUDED(d, i))
#define GGOBI_STAGE_GET_ATTR_CLUSTER(d, i)  ((gint) ggobi_stage_get_raw_value(d, i, attr_cluster))

#define GGOBI_STAGE_GET_ATTR_GLYPH(d, i)  ggobi_stage_get_attr_glyph(d, i, attr_type[1], attr_size[1])

#define GGOBI_STAGE_RESET_ATTR_COLOR(d, i,  brush)  GGOBI_STAGE_RESET_ATTR(d, i, color,  brush)
#define GGOBI_STAGE_RESET_ATTR_TYPE(d, i,   brush)  GGOBI_STAGE_RESET_ATTR(d, i, type,   brush)
#define GGOBI_STAGE_RESET_ATTR_SIZE(d, i,   brush)  GGOBI_STAGE_RESET_ATTR(d, i, size,   brush)
#define GGOBI_STAGE_RESET_ATTR_HIDDEN(d, i, brush)  GGOBI_STAGE_RESET_ATTR(d, i, hidden, brush)

#define GGOBI_STAGE_BRUSH_POINT(d, i, condition, brush_mode, brush) \
  if (condition) {\
   switch (brush_mode) {\
    case br_candg:\
      GGOBI_STAGE_SET_ATTR_COLOR(d, i, d->gg->color_id, brush);\
      GGOBI_STAGE_SET_ATTR_SIZE(d, i, (&d->gg->glyph_id)->size, brush);\
      GGOBI_STAGE_SET_ATTR_TYPE(d, i, (&d->gg->glyph_id)->type, brush);\
      break;\
    case br_color:\
      GGOBI_STAGE_SET_ATTR_COLOR(d, i, d->gg->color_id, brush);\
      break;\
    case br_glyph:\
      GGOBI_STAGE_SET_ATTR_SIZE(d, i, (&d->gg->glyph_id)->size, brush);\
      GGOBI_STAGE_SET_ATTR_TYPE(d, i, (&d->gg->glyph_id)->type, brush);\
      break;\
    case br_shadow:\
      GGOBI_STAGE_SET_ATTR_HIDDEN(d, i, true, brush);\
      break;\
    case br_unshadow:\
      GGOBI_STAGE_SET_ATTR_HIDDEN(d, i, false, brush);\
      break;\
    case br_exclude:\
      GGOBI_STAGE_SET_ATTR_EXCLUDED(d, i, true);\
      break;\
    case br_include:\
      GGOBI_STAGE_SET_ATTR_EXCLUDED(d, i, false);\
      break;\
    default:\
      break;\
    }\
  } else if (brush == ATTR_SET_TRANSIENT) {  \
    switch (brush_mode) {\
    case br_candg:\
      GGOBI_STAGE_RESET_ATTR_COLOR(d, i, ATTR_SET_TRANSIENT);\
      GGOBI_STAGE_RESET_ATTR_SIZE(d, i, ATTR_SET_TRANSIENT);\
      GGOBI_STAGE_RESET_ATTR_TYPE(d, i, ATTR_SET_TRANSIENT);\
      break;\
    case br_color:\
      GGOBI_STAGE_RESET_ATTR_COLOR(d, i, ATTR_SET_TRANSIENT);\
      break;\
    case br_glyph:\
      GGOBI_STAGE_RESET_ATTR_SIZE(d, i, ATTR_SET_TRANSIENT);\
      GGOBI_STAGE_RESET_ATTR_TYPE(d, i, ATTR_SET_TRANSIENT);\
      break;\
    case br_unshadow:\
    case br_shadow:\
      GGOBI_STAGE_RESET_ATTR_HIDDEN(d, i, ATTR_SET_TRANSIENT);\
      break;\
    default:\
      break;\
    }\
  }
    
/*---- STUFF FROM DATA.GOB ----*/

typedef struct _Jitterd {
  gfloat factor;
  gboolean type;
  gboolean convex;
  gfloat *jitfacv;
} Jitterd;

typedef struct _Varpanel_cboxd {
  GtkWidget *ebox;   /*-- child1 of pane widget --*/
  GtkWidget *swin;   /*-- child of ebox --*/
  GtkWidget *vbox;   /*-- child of swin --*/
  GSList *box;       /*-- single column of hboxes --*/
} Varpanel_cboxd;

typedef struct _Varpanel_circd {
  GtkWidget *ebox;        /*-- child2 of pane widget --*/
  GtkWidget *vbox;        /*-- child of ebox --*/
  GtkWidget *swin, *hbox; /*-- children of vbox --*/
  GtkWidget *table;       /*-- sole child of swin; now a vbox --*/
  GtkWidget *manip_btn, *freeze_btn; /*-- children of hbox --*/

  GdkCursor *cursor;
  gint jcursor;

 /*-- components and properties of the table --*/
  GSList *vb, *da, *label;
  GSList *da_pix;         /*-- backing pixmaps --*/
  gint nvars;
} Varpanel_circd;

typedef struct _Varpaneld {
  GtkWidget *hpane;  /*-- child of the ebox --*/
} Varpaneld;

/*-------------------- transformation --------------------------------*/

/* sphering transformation **/
typedef struct _Sphere_d {
  vector_i vars;        /*-- vars available to be sphered --*/
  vector_i vars_sphered;/*-- vars that have been sphered --*/
  gint npcs;      /*-- the first npcs vars of vars will be sphered --*/
  vector_i pcvars;/*-- vars into which sphered data is written --*/

  vector_f eigenval;
  array_d eigenvec;
  array_f vc;
  vector_f tform_mean;
  vector_f tform_stddev;

  gboolean vars_stdized;
} Sphere_d;

typedef struct _BrushBins {
  gint nbins;
  bin_struct **binarray;
  /*
   * bin0 is the bin which contains of the upper left corner of the
   * brush; bin1 is the one containing of the lower right corner.
  */  
  icoords bin0, bin1;
} BrushBins;

// FIXME: This form of edge storage is particular to the default GGobiData
// implementation and so should eventually be declared privately there
typedef struct _EdgeData {
  gint n;
  /* maps from edge to row in edge dataset (mapping not 1-1 due to polygons) */
  guint *indices;
  // FIXME: maybe SymbolicEndpoints could become some sort of boxed structure
  // representing an edge, including its index into the edgeset
  SymbolicEndpoints *sym_endpoints;
  
  // To EDGE-RESOLVER stage
  GList *endpointList;   
    /* a list of endpointsd elements corresponding to the resolved 
       record ids relative to a given datad. This is akin to a table
       indexed by datad elements. **/

  // To BRUSH stage
  gint nxed_by_brush;
  vector_b xed_by_brush;
} EdgeData;

/* END DATA.GOB */

%}

// FIXME: perhaps this could be replaced with a stage that masks arbitrary
// attributes? Like a transient layer on top of a persistent layer.
enum ATTR_SET {
  PERSISTENT,
  TRANSIENT
} GGobi:Attr:Set:Method;

/**
 * SECTION:GGobiStage
 * @short_description: The base class of the GGobi pipeline.
 * @stability: Unstable
 *
 * The GGobi pipeline manipulates data so that it becomes suitable for 
 * a certain visualization. The pipeline consists of stages, each performing
 * a specific task on the data.
 *
 * This class only implements the identity transformation. Subclasses are meant
 * override a subset of these operations in order to transform or otherwise 
 * "decorate" the data on the way to its visualization.
 *
 * Optimization possibilities: data caching and signal buffering
 */
 
class GGobi:Stage from G:Object {

/*-- this forms the pipeline --*/
protected GGobiStage *parent;
property OBJECT parent
  (nick = "prev", blurb = "The stage preceeding this one in the pipeline",
    object_type = GGobi:Stage, export)
  set {
    GGobiStage *parent = g_value_get_object(VAL);
    GGobiStage *former = self->parent;
    GGobiPipelineMessage *msg = ggobi_pipeline_message_new(0, 0);
    
    if (former) {
      g_signal_handler_disconnect(former, selfp->changed_handler);
      g_signal_handler_disconnect(former, selfp->col_name_changed_handler);
      for (guint j = 0; j < self->n_cols; j++)
        self_col_removed(self, j);
      self_flush_changes_here(self);
      self_remove_child(former, self);
    }
      
    self->parent = parent;
    
    /* In order to allow subclasses to block signal forwarding (like
       for row and column filters) we pass every single through a virtual */
    selfp->changed_handler = g_signal_connect_swapped(G_OBJECT(parent), "changed", 
      G_CALLBACK(self_changed_handler), self);
    selfp->col_name_changed_handler = g_signal_connect_swapped(G_OBJECT(parent), 
      "col-name-changed",  G_CALLBACK(self_col_name_changed_handler), self);
    
    self_add_child(parent, self);
    
    /* pretend like the parent just said "here's some new rows and columns!" */
    ggobi_pipeline_message_add_rows(msg, self->parent->n_rows);
    ggobi_pipeline_message_add_cols(msg, self->parent->n_cols);
    self_changed_handler(self, msg);
    g_object_unref(G_OBJECT(msg));
  }
  get { g_value_set_object(VAL, self->parent); };

/* the children of this stage */
private GSList *children destroywith g_slist_free;

/*-- every pipeline stage has a name --*/
public gchar *name destroywith g_free;
property STRING name
  (nick = "id", blurb = "The name of the pipeline stage",
   default_value = "identity", link, export);

/*-- a pointer to the application context --*/
/*-- note that we don't want this -- the pipeline must be freed of GGobi! --*/
public struct _GGobiSession *gg; /*-- a pointer to the parent --*/

/* variables are now stored in the stage */
private GPtrArray *vartable = { g_ptr_array_new() } 
  destroy { /* scrap the variables then the array */
    g_ptr_array_foreach(VAR, (GFunc)g_object_unref, NULL); 
    g_ptr_array_free(VAR, TRUE);
  };

/* we cache the number of rows and columns */

public guint n_rows;
public guint n_cols;

/* warning: only set these properties if you know what you are doing */
property UINT n_rows 
  (nick = "nrows", blurb = "Number of rows at this stage",
   minimum = 0, maximum = G_MAXUINT, default_value = 0, export)
   set { 
     guint old_n_rows = self->n_rows;
     self->n_rows = g_value_get_uint(VAL);
     if (old_n_rows < self->n_rows) {
       arrayg_add_rows (&self->jitdata, self->n_rows);
       arrayg_add_rows (&self->world, self->n_rows);
     }
     if (old_n_rows != self->n_rows) {
       vectori_realloc (&self->rows_under_brush, self->n_rows);
       vectori_realloc (&self->rows_under_brush_prev, self->n_rows);
       self->nrows_under_brush = self->nrows_under_brush_prev = 0;
       clusters_set(self);
     }
   }
   get { g_value_set_uint(VAL, self->n_rows); };
property UINT n_cols 
  (nick = "ncols", blurb = "Number of cols at this stage",
   minimum = 0, maximum = G_MAXUINT, default_value = 0, export)
   set { 
     guint old_n_cols = self->n_cols;
     self->n_cols = g_value_get_uint(VAL);
     g_ptr_array_set_size(selfp->vartable, self->n_cols);
     for (guint j = old_n_cols; j < self->n_cols; j++) {
       GGobiVariable *var = self_create_variable(self, j);
       self_set_variable(self, j, var);
     }
     if (old_n_cols < self->n_cols) {
       arrayg_add_cols (&self->jitdata, self->n_cols);
       arrayg_add_cols (&self->world, self->n_cols);
       tour_realloc_up (self, self->n_cols);
     }
   }
   get { g_value_set_uint(VAL, self->n_cols); };

/*------ STUFF FROM DATA.GOB ---------*/

/* GUI related */
public Varpanel_cboxd  vcbox_ui;
public Varpanel_circd  vcirc_ui;
public Varpaneld  varpanel_ui;
public GtkWidget *vartable_tree_view[GGOBI_VARIABLE_ALL_VARTYPES];
public GtkTreeModel *vartable_tree_model; /* the root model, with all vars **/
public GtkWidget *cluster_table; /*-- table of symbol groups from brushing --*/
public clusteruid *clusvui;

/* PIPELINE AND IMODE OBJECTS */

public Jitterd  jitter;
public Sphere_d  sphere;
public BrushBins  brush;

public vector_i rows_under_brush;
public vector_i rows_under_brush_prev;

public array_g world;
public array_g jitdata;

public gboolean missings_show_p; /*-- show/hide per datad, not per display --*/
public gint nrows_under_brush;
public gint nrows_under_brush_prev;

/*--------------- clusters: hiding, excluding ----------------------*/

// A pipeline stage could map the data to its clusters
public symbol_cell symbol_table[NGLYPHTYPES][NGLYPHSIZES][MAXNCOLORS];
public gint nclusters;
public clusterd *clusv;

public GSList *sticky_ids; // as an attribute from IDENTIFY stage
   
/* END PIPELINE */

/*-- used in identification, line editing, and point motion --*/
// Could be moved to imode object or a boolean attribute or g_object_set_data()
public gint nearest_point;
public gint nearest_point_prev;

/*-------------------- moving points ---------------------------------*/
// To 'move points' imode?
public GSList *movepts_history; /*-- a list of elements of type celld --*/

/*-- to support brushing by categorical variable --*/
// to the brush imode object?
public gchar* linkvar = NULL;  /*-- the linking variable name--*/

// FIXME: shouldn't need this - attributes should be filtered out by pipeline
protected guint n_attributes;

/* END DATA.GOB */

private GHashTable* var_name_lookup = { 
  g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL) 
} destroywith g_hash_table_destroy;

/* messages */
private GGobiPipelineMessage *queued_message;
private GGobiPipelineMessage *working_message;

/* handler id's (for disconnecting when reparenting) */
private guint changed_handler;
private guint col_name_changed_handler;

/* This is kept separate from the 'changed' signal, since it's just metadata - 
   it is not part of the actual data matrix */
/* Column name changing is somewhat complex. Column names are set in two ways:
   1) Through the GGobiVariable object
   2) With ggobi_stage_set_col_name
   The latter chains up to the root, where it modifies the GGobiVariable,
   which then degenerates to the first case. The stage listens to the 
   name change signal of each GGobiVariable and responds by emitting the
   col_name_changed signal. The default handler for the signal, below, 
   updates the variable name hash table. */
public signal first NONE (STRING, UINT) void 
col_name_changed(self, const gchar *old_name, guint j)
{
  self_update_var_name_hash(self, old_name, j);
}

/* new pipeline message dispatch event */

/* Users should not emit this event directly, rather they should communicate 
   changes to the stage using the convenience methods like _col_data_changed(). 
   The changes are stored in an internal "working" message, which is sent to
   listeners using _flush_changes(). The message may be retrieved with 
   _get_message(). The user may then modify the message directly or merge it 
   with another message. 
   
   Subclasses can override the processing at two places: when a message is
   received from the parent and when it is queued for dispatch. When a message
   is received, it first must be translated to the index space of the stage.
   Fortunately, the parent and child index spaces are usually the same. The
   primary exception to this are filters. The subclass is responsible for
   adding the incoming changes to the outgoing queue, which may be accomplished
   by chaining up to the parent handler of _process_incoming or by manually
   invoking _queue_message(). Subclasses will often need to queue multiple
   messages, as they proceed through different stages of processing. All
   queued messages are assumed to be in the index space of the current stage.
*/

private signal NONE (OBJECT) void
changed(self, GGobiPipelineMessage *msg);

/* the messaging system */

public GGobiPipelineMessage *
get_message(self)
{
  if (!selfp->working_message)
    selfp->working_message = ggobi_pipeline_message_new(self->n_rows, self->n_cols);
  return selfp->working_message;
}
public void
queue_message(self, GGobiPipelineMessage *msg)
{
  self_process_outgoing(self, msg);
  if (selfp->queued_message)
    ggobi_pipeline_message_merge(selfp->queued_message, msg);
  else selfp->queued_message = g_object_ref(G_OBJECT(msg));
}
public gboolean
has_changes(self)
{
  return selfp->queued_message || selfp->working_message;
}
/* find the stage closest to the root with changes and flush them, then
   repeat until everything is flushed */
public void
flush_changes(self)
{
  GGobiStage *dirty;
  do {
    GGobiStage *s;
    dirty = NULL;
    for (s = self; s; s = s->parent)
      if (self_has_changes(s))
        dirty = s;
    if (dirty)
      self_flush_changes_here(dirty);
  } while(dirty);
}
/* dispatch the changes that have occurred at this stage */
/* this probably only makes sense from within stage implementations - 
   pipeline clients would prefer _flush_changes() since they don't know
   where the changes they are flushing actually occurred.
*/
public void
flush_changes_here(self)
{
  if (selfp->working_message) { /* make sure everything is in queue */
    self_queue_message(self, selfp->working_message);
    g_object_unref(G_OBJECT(selfp->working_message));
    selfp->working_message = NULL;
  }
  if (selfp->queued_message) { /* send our changes to listeners */
    self_changed(self, selfp->queued_message); 
    g_object_unref(G_OBJECT(selfp->queued_message));
    selfp->queued_message = NULL;
  }
}

/* register changes on queued message */

public void 
col_data_changed(self, guint j) {
  GGobiPipelineMessage *msg = self_get_message(self);
  ggobi_pipeline_message_change_col(msg, j);
}

/**
 * cols_added:
 * @self: #GGobiStage
 * @n: number of new columns
 *
 **/
public void
cols_added(self, guint n) {
  GGobiPipelineMessage *msg = self_get_message(self);
  ggobi_pipeline_message_add_cols(msg, n);
}

/**
 * cols_deleted:
 * @self: #GGobiStage
 * @j: Column deleted
 *
 **/
public void
col_removed(self, guint j) {
  GGobiPipelineMessage *msg = self_get_message(self);
  GSList *col = g_slist_append(NULL, GINT_TO_POINTER(j));
  ggobi_pipeline_message_remove_cols(msg, col);
  g_slist_free(col);
}

/**
 * rows_added:
 * @self: #GGobiStage
 * @n: number of new rows
 *
 **/
public void
rows_added(self, guint n) {
  GGobiPipelineMessage *msg = self_get_message(self);
  ggobi_pipeline_message_add_rows(msg, n);
}

public void
rows_removed(self, GSList *rows) {
  GGobiPipelineMessage *msg = self_get_message(self);
  ggobi_pipeline_message_remove_rows(msg, rows);
}

/* initializer */

init (self) {
  sphere_init(self);
  self->nearest_point = -1;
  self->missings_show_p = true;
}

/** 
 * new:
 *
 * Create new #GGobiStage object
 * 
 * Returns: #GGobiStage object
 **/
public GGobiStage* 
new(const gchar *name, GGobiStage *parent)
{
  GObject* s = (GObject *)GET_NEW_VARG("name", name, "parent", parent, NULL);
  return(GGOBI_STAGE(s));
}

/**
 * get_col_name:
 * @self: #GGobiStage
 * @j: column index
 *
 * Returns: allocated column name
 **/
public gchar* 
get_col_name(self, guint j) 
{
  GGobiVariable *var = self_get_variable(self, j);
  g_return_val_if_fail(GGOBI_IS_VARIABLE(var), NULL);
  return ggobi_variable_get_name(var);
}

/**
 * get_col_nickname:
 * @self: #GGobiStage
 * @j: column index
 *
 * Returns: allocated column nickname
 **/
public gchar* 
get_col_nickname(self, guint j) 
{
  GGobiVariable *var = self_get_variable(self, j);
  g_return_val_if_fail(GGOBI_IS_VARIABLE(var), NULL);
  return ggobi_variable_get_nickname(var);
}

/**
 * get_col_index_for_name:
 * @self: #GGobiStage
 * @name: column name
 *
 * Returns: index of column with given name, or -1 if no matching columns
 **/
public gint
get_col_index_for_name(self, const gchar* name) onerror -1
{
  gpointer pos, key;
  if (g_hash_table_lookup_extended(selfp->var_name_lookup, name, &key, &pos))
    return GPOINTER_TO_INT(pos);
  return -1;
}

/** 
 * set_col_name:
 * @self: GGobiStage object
 * @j: column index
 * @value: new column name (if NULL uses column index)
 *
 * Set column name
 * Also sets nickname to the first two letters.
 * Emits col_name_changed() signal.
 **/
public void 
set_col_name(self, guint j, const gchar* value) 
{
  GGobiVariable* vt;
  gchar *nick = NULL, *name;
  
  if (self->parent && self->parent->n_cols > j) {
    self_set_col_name(self->parent, j, value);
    return;
  }

  vt = self_get_variable(self, j);
  
  if (value)
    name = g_strdup(value);
  else {
    nick = g_strdup_printf("V%d", j);
    name = g_strdup_printf("_Var %d", j);
  }
  
  if (nick) {
    ggobi_variable_set_nickname(vt, nick);
    g_free(nick);
  }
  
  ggobi_variable_set_name(vt, name);
  g_free(name);
}

/** 
 * set_col_nickname:
 * @self: GGobiData object
 * @j: column index
 * @value: new column nickname
 **/
public void 
set_col_nickname(self, guint j, const gchar* value)
{
  GGobiVariable* vt = self_get_variable(self, j);
  ggobi_variable_set_nickname(vt, g_strdup(value));
}

/* this recurses up the tree until reaching the root or the stage that
   appends the column, then registers the column as changed */
virtual void
update_col(self, guint j)
{
  if (self->parent && self->parent->n_cols > j)
    self_update_col(self->parent, j);
  else self_col_data_changed(self, j);
}

/**
 * set_missing:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 *
 * Set specified cell to be a missing value.  
 * If the variable is categorical, a new level value ("MISSING")
 * will be created, and the raw value set to that.
 **/
virtual void
set_missing(self, guint i, guint j)
{
  self_set_missing(self->parent, i, j);
}


/**
 * is_missing:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 *
 * Returns: if value at specified positive is missing or not
 **/
virtual gboolean
is_missing(self, guint i, guint j) 
{
  return(self_is_missing(self->parent, i, j));  
}

/**
 * has_missings:
 * @self: GGobiStage object
 * Returns: whether there are missing values in the stage
 **/
public gboolean
has_missings(self) 
{
  for (guint j = 0; j < self->n_cols; j++)
    if (ggobi_variable_has_missings(self_get_variable(self, j)))
      return(TRUE);
  return(FALSE);
}

/**
 * get_col_n_missing:
 * @self: GGobiStage object
 * @j: column index
 * Returns: how many missing values does a column have?
 **/
 // FIXME: Should this be cached and made part of GGobiVariable?
 // Well, it takes longer (on average) to count missings than detect them
 // This is only used in the variable notebook, so maybe we could count there.
public guint 
get_col_n_missing(self, guint j) {
  guint i, n = 0, nrows = self_get_n_rows(self);
  
  for(i = 0; i < nrows; i++) {
    if (self_is_missing(self, i, j)) n++;
  }
  
  return(n);
}


/**
 * set_raw_values:
 * @self: GGobiStage object
 * @j: column index
 * @values: vector of new values, of length self->nrows
 * 
 * Sets all values in the specified column.  
 * Emits "changed" signal.
 **/
public void
set_raw_values(self, guint j, gdouble *values)
{
  guint i, nrows = self_get_n_rows(self);
  
  for (i = 0; i < nrows; i++) {
    self_set_raw_value(self, i, j, values[i]);
  }
  self_update_col(self, j);
  self_flush_changes_here(self);
}


/**
 * set_raw_value:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 * @values: vector of new values, of length self->nrows
 * 
 * Sets a single value in the specified column.  
 *
 * This will set missing values if necessary and sets
 * tform value as well to keep dataset consistent.
 *
 * You need to call ggobi_stage_update_col() after
 * using this function to inform observers (like child stages) of the changes.
 **/
virtual void
set_raw_value(self, guint i, guint j, gdouble value)
{
  self_set_raw_value(self->parent, i, j, value);
  //self->tform.vals[i][j] = value;
}

/**
 * set_categorical_value:
 * @self: #GGobiStage
 * @i: row index
 * @j: column index
 * @value: new categorical value
 * 
 * This function sets the value of a cell in a categorical variable.
 * It will automatically create a new level if necessary.
 * If the column is not already categorical, this will make it so.
 */
virtual void
set_categorical_value(self, guint i, guint j, const gchar* value) 
{
  if (self->parent)
    self_set_categorical_value(self->parent, i, j, value);
  else {
    GGobiVariable *root_var = self_get_variable(self, j);
    ggobi_variable_add_level(root_var, value, -1);
    self_set_raw_value(self, i, j, 
      (gdouble)ggobi_variable_get_level_value(root_var, value));
  }
}

virtual const gchar *
get_categorical_value(self, guint i, guint j)
{
  GGobiVariable *var = self_get_variable(self, j);
  gint value = (gint)self_get_raw_value(self, i, j);
  if (ggobi_variable_has_level(var, value))
    return ggobi_variable_get_level_name(var, value);
  /*g_return_val_if_fail(self->parent != NULL, NULL);*/
  if (!self->parent)
    return NULL;
  return self_get_categorical_value(self->parent, i, j);
}

/**
 * set_string_value:
 * @self: #GGobiStage
 * @i: row index
 * @j: column index
 * @value: new value
 *
 * This function provides a convenient method for setting the
 * value from a string.  Empty strings, . and NA will be treated as
 * missings.  Strings that can be converted to an number will store
 * that number.  Otherwise set_categorical_value() will be used
 **/
public void
set_string_value(self, guint i, guint j, const gchar* value) 
{
  if (is_numeric(value)) {
    self_set_raw_value(self, i, j, (gfloat) g_strtod (value, NULL));
  } else {
    if (!g_ascii_strcasecmp (value, "na") || !strcmp (value, ".") || !strcmp(value, ""))  
      self_set_missing(self, i, j);
    else
      self_set_categorical_value(self, i, j, value);
  }
}

// FIXME: wouldn't simply get_value() work here?
/** 
 * get_raw_value:
 * @self: #GGobiStage
 * @i: row index
 * @j: column index
 **/
virtual gdouble
get_raw_value(self, guint i, guint j)
{
  return self_get_raw_value(self->parent, i, j);
}

/**
 * get_raw_values:
 * @self: GGobiStage object
 * @j: column index
 * Returns: vector of values, of length self->nrows
 * 
 * Gets all values in the specified column.  
 **/
public gdouble *
get_raw_values(self, guint j)
{
  guint i, nrows = self_get_n_rows(self);
  gdouble *values = g_new(gdouble, nrows);
  
  for (i = 0; i < nrows; i++) {
    values[i] = self_get_raw_value(self, i, j);
  }
  
  return values;
}

public GGobiVariableType
get_col_type(self, guint j)
{
  GGobiVariable *var = self_get_variable(self, j);
  g_return_val_if_fail(GGOBI_IS_VARIABLE(var), -1);
  return(ggobi_variable_get_vartype(var));
}

/** 
 * get_col_is_attribute:
 * @self: #GGobiStage
 * @j: column index
 *
 * Returns: true if this column is an attribute
 **/
public gboolean
col_is_attribute(self, guint j) {
  GGobiVariable* vt = self_get_variable(self, j);
  return vt->is_attribute;
}

/** 
 * translate_var_to_col:
 * @self: #GGobiStage
 *
 * Returns: an array of length n_vars, with value i
 * indicating the column of variable i
 **/
public guint*
translate_var_to_col(self) {
  guint nvars = self_get_n_vars(self);
  guint* translate = g_new(guint, nvars);
  
  guint var = 0;
  for(guint j = 0; j < self->n_cols; j++) {
    if (self_col_is_attribute(self, j)) continue;
    translate[var++] = j;
  }
  
  return(translate);
}


virtual GGobiVariable*
create_variable (self, guint j)
{
  if (self->parent)
    return ggobi_variable_clone(self_get_variable(self->parent, j));
  return GGOBI_VARIABLE(ggobi_variable_new(self));
}

/**
 * get_variable:
 * @self: #GGobiStage object
 * @j: column index
 *
 * Get variable meta data for specified column
 **/
public GGobiVariable*
get_variable (self, guint j)
{
  return g_ptr_array_index(selfp->vartable, j);
}

/**
 * get_string_value:
 * @self: #GGobiStage object
 * @i: row index
 * @j: column index
 * @transformed: transformed or raw values?
 *
 * Get string representation of value
 * This currently returns a locale insensitive string, suitable for
 * output into csv etc.  It may be sub-optimal for user display, because
 * it does not use the users locale settings, and outputs full precision.
 **/
public gchar*
get_string_value(self, guint i, guint j) 
{
  GGobiVariable *var = self_get_variable(self, j);
  /*gdouble raw = transformed ? self->tform.vals[i][j] : 
    GGOBI_DATA(self)->raw.vals[i][j];*/
  gdouble raw = self_get_raw_value(self, i, j);
  
  if (self_is_missing(self, i, j)) 
    return g_strdup("NA");

  if (!GGOBI_VARIABLE_IS_CATEGORICAL(var)) {
    gchar *buf = g_new(gchar, G_ASCII_DTOSTR_BUF_SIZE);
    g_ascii_dtostr(buf, G_ASCII_DTOSTR_BUF_SIZE, raw);
    return buf;
  }
  
  return g_strdup(ggobi_variable_get_level_name(var, raw));
}

/**
 * get_edges_edges:
 * @self: #GGobiStage object
 *
 * Get the number of edges in this dataset
 **/ 
virtual guint
get_n_edges (self)
{
  return(self_get_n_edges(self->parent));
}

// FIXME: dirty hack so that we can keep the edge data in GGobiData where it belongs
// We need to work out an actual API eventually
virtual EdgeData *
get_edge_data (self)
{
  return(self_get_edge_data(self->parent));
}

/** 
 * set_row_id:
 * @self: #GGobiStage object
 * @i: row
 * @value: new string value for row id
 *
 * Set the row id (a string) for specified row
 * A row id is a unique string reference to a given row.
 * These are hashed for O(1) lookup.
 **/ 
virtual void
set_row_id(self, guint i, gchar* value) {
  self_set_row_id(self->parent, i, value);
}

public void
set_row_ids(self, GSList *ids)
{
  for (guint i = 0; i < self->n_rows && ids; ids = ids->next, i++)
    self_set_row_id(self, i, ids->data);
}

/** 
 * get_row_id:
 * @self: #GGobiStage object
 * @i: row
 * 
 * Retrive row id for specified row.
 * Returns: duplicate of row id if present, NULL otherwise
 **/
virtual gchar*
get_row_id(self, guint i) {
  return self_get_row_id(self->parent, i);
}

public GSList *
get_row_ids(self) {
  GSList *ids = NULL;
  for (guint i = 0; i < self->n_rows; i++)
    ids = g_slist_prepend(ids, g_strdup(self_get_row_id(self, i)));
  return g_slist_reverse(ids);
}

/** 
 * get_row_for_id:
 * @self: #GGobiStage object
 * @id: row id string
 * 
 * Get row index corresponding to row id
 *
 * Returns: row index if found, -1 otherwise
 **/
virtual gint
get_row_for_id(self, gchar *id) {
  return self_get_row_for_id(self->parent, id);
}


/* Pipeline structure 
 * ============================================================================
 */

public GGobiStage *
get_root(self)
{
  GGobiStage *stage;
  for (stage = self; stage->parent != NULL; stage = stage->parent);
  return(stage);
}

public GSList *
get_children(self)
{
  return g_slist_copy(selfp->children);
}

/* Find (first) descendant with given name */
private GGobiStage *
find_recurse(self, const gchar *name)
{
  GSList *tmp_children, *children = self_get_children(self);
  GGobiStage *result = NULL;
  for (tmp_children = children; tmp_children && !result; tmp_children = tmp_children->next) {
    GGobiStage *child = GGOBI_STAGE(tmp_children->data);
    if (!strcmp(child->name, name))
      result = child;
    else result = ggobi_stage_find(child, name);
  }
  g_slist_free(children);
  return result;
}

/* Currently, this is the main mechanism for looking up specific stages from
   the pipeline. The various GGobi GUI components need this so that they 
   can serve as view/controllers of specific stages. The pipeline factory
   can provide alternative implementations for the built-in stages. */
public GGobiStage *
find(self, const gchar *name  (check null))
{
  if (!strcmp(self->name, name))
    return self;
  return self_find_recurse(self, name);
}

protected void
add_child(self, GGobi:Stage *child  (check null type))
{
  g_object_ref(G_OBJECT(child));
  selfp->children = g_slist_append(selfp->children, child);
}
protected void
remove_child(self, GGobi:Stage *child  (check null type))
{
  GSList *el = g_slist_find(selfp->children, child);
  if (el) {
    g_object_unref(G_OBJECT(el->data));
    selfp->children = g_slist_delete_link(selfp->children, el);
  }
}

/* Attributes
 * ============================================================================
 */

/**
 * set_attr:
 * @self: #GGobiStage
 * @i: row index
 * @j: attribute column
 * @j_now: column index for transient value of attribute
 * @j_prev: column index for previous value of attribute
 * @brush: persistent or transient
 *
 * Sets attribute to new value. Use with GGOBI_STAGE_ATTR_INIT and
 * GGOBI_STAGE_ATTR_SET
 * Returns: true if value has changed, false otherwise
**/
public gboolean
set_attr(self, guint i, guint j, guint j_now, guint j_prev, gdouble value, GGobiAttrSetMethod method)
{
  //g_debug("(%i,%i %i %i) -> %g %s", i, j, j_now, j_prev, value, brush == ATTR_SET_TRANSIENT ? "t" : "p");
  if (method == ATTR_SET_TRANSIENT ?
    (self_get_raw_value(self, i, j_now) == value) :
    (self_get_raw_value(self, i, j) == value))
    return false;

  if (method == ATTR_SET_PERSISTENT) {
    self_set_raw_value(self, i, j_prev, self_get_raw_value(self, i, j));
    self_set_raw_value(self, i, j, value);
  }

  self_set_raw_value(self, i, j_now, value);
  return true;
}

public gboolean
reset_attr(self, guint i, guint j, guint j_now, guint j_prev, GGobiAttrSetMethod brush)
{
  gdouble value;
  switch(brush) {
    case ATTR_SET_PERSISTENT:
      value = self_get_raw_value(self, i, j_prev);
    default:
      value = self_get_raw_value(self, i, j);
  }
  
  return self_set_attr(self, i, j, j_now, j_prev, value, brush);
}

public gdouble
get_attr(self, guint i, guint j, guint j_now, guint j_prev)
{
  return self_get_raw_value(self, i, j_now);
}

/**
 * get_attr_glyph:
 * @self: #GGobiStage
 * @i: row index
 * 
 * Retrieve current glyph
**/
public glyphd* 
get_attr_glyph(self, guint i, guint j_type, guint j_size)
{
  glyphd* glyph = (glyphd*) g_malloc (sizeof (glyphd));   
  glyph->type = (gshort) self_get_raw_value(self, i, j_type);
  glyph->size = (gshort) self_get_raw_value(self, i, j_size);
  return glyph;
}

// FIXME: data/attribute distinction should be made by a pipeline stage
public guint
get_n_vars(self) {
  return self_get_n_cols(self) - self->n_attributes;
}

public guint
has_vars(self) {
  return self_get_n_vars(self) > 0;
}

/**
 * set_rows_in_plot:
 * @self: #GGobiData object
 *
 * Combine the values in two arrays:
 *   excluded[] (which comes from the exclusion panel or from linking)
 *   sampled[] (which come from the subset panel)
 * to determine which cases should be plotted.
 *
 * rows_in_plot = sampled && !excluded
 **/
 // FIXME: Needs to go bye-bye
/*public void
set_rows_in_plot(self)
{
  guint i;
  self->nrows_in_plot = 0;

  GGOBI_STAGE_ATTR_INIT_ALL(self);
  for (i = 0; i < self->n_rows; i++) 
    if (!GGOBI_STAGE_GET_ATTR_EXCLUDED(self, i))
      self->rows_in_plot.els[self->nrows_in_plot++] = i;
  
  self_rows_in_plot_changed(self, (guint) self->nrows_in_plot); 
}*/

/**
 * attach:
 * @self: #GGobiStage object
 * @gg: GGobi object
 * @cleanup: should cleanup occur?
 *
 * Attach a GGobi object to this dataset
 * The purpose of this function is to hook up the #GGobiData object
 * to all the gui components and make sure they stay in sync by
 * listening to the correct signals.  This function still needs a lot of
 * work.
 **/
 // FIXME: This should not exist.. we need a ggobi_main_add_data()
public void 
attach (self, GGobiSession *gg, gboolean cleanup)
{
  displayd *display = NULL;
  GGobiStage *d = self_get_root(self);
  gint *vars = (gint *) g_malloc(GGOBI_STAGE(self)->n_cols * sizeof(gint));
  GGobiInputSource *source = ggobi_data_get_source(GGOBI_DATA(d));

  d->gg = gg;
  gg->d = g_slist_append (gg->d, GGOBI_DATA(d));
  
  if (gg->data_source)
    g_object_unref(gg->data_source);
  g_object_ref(source);
  gg->data_source = source;

  self->brush.bin0.x = self->brush.bin1.x = BRUSH_NBINS;
  self->brush.bin0.y = self->brush.bin1.y = BRUSH_NBINS;

  gint iv, ih;
  self->brush.nbins = BRUSH_NBINS;

  edgeedit_init (self->gg);
  if (ggobi_stage_get_n_edges(GGOBI_STAGE(self)))
    vectorb_realloc (&GGOBI_DATA(d)->edge.xed_by_brush, GGOBI_DATA(d)->edge.n);

  /* binning the plot window; no need to realloc these **/
  self->brush.binarray = (bin_struct **)
    g_malloc (self->brush.nbins * sizeof (bin_struct *));
  for (ih = 0; ih < self->brush.nbins; ih++) {
    self->brush.binarray[ih] = (bin_struct *)
      g_malloc (self->brush.nbins * sizeof (bin_struct));

    for (iv = 0; iv < self->brush.nbins; iv++) {
      self->brush.binarray[ih][iv].nels = 0;
      self->brush.binarray[ih][iv].nblocks = 1;
      self->brush.binarray[ih][iv].els = (gulong *)
        g_malloc (BINBLOCKSIZE * sizeof (gulong));
    }
  }

  for(guint j = 0; j < self_get_n_vars(self); j++) 
    self_update_col(self, j);
  self_flush_changes(self);
    
  /**
   * If there are missings, they've been initialized with a value
   * of 0.  Here, re-set that value to 15% below the minimum for each
   * variable.  (dfs -- done at Di's request, September 2004)
   **/
  /*limits_set (self, self->gg->lims_use_visible);*/
  for (guint j = 0; j < self->n_cols; j++) vars[j] = j;
  impute_fixed (IMP_BELOW, 15.0, self->n_cols, vars, self);
  /*limits_set (self, self->gg->lims_use_visible);*/
  g_free(vars);

  clusters_set(self);  /*-- find the clusters for data just read in --*/

  display_menu_build (gg);
  
  // Set up variable table and listen to important events
  self_connect__col_name_changed(self, self_vartable_collab_set_by_var_cb, NULL);
  self_connect__col_name_changed(self, self_vartable_collab_tform_set_by_var_cb, NULL);

  varcircles_populate (self, gg);
  self_connect__col_name_changed(self, self_varcircle_label_set_cb, NULL);

  if (cleanup)
    varpanel_clear (self, gg);
  varpanel_populate (self, gg);   
  if (gg->current_display != NULL)
    varpanel_refresh (gg->current_display, gg);
  if (g_slist_index(gg->d, d) == 0)
    varpanel_set_sensitive (self, true, gg);
  self_connect__col_name_changed(self, self_varpanel_label_set_cb, NULL);
  
  if (cleanup || g_list_length(gg->displays) == 0) {
    display_free_all (gg);  /*-- destroy any existing displays --*/
    gg->pmode = NULL_PMODE;

    /*-- initialize the first display --*/
    if(sessionOptions->info->createInitialScatterPlot && 
        self_get_n_cols(self)) {
      display = scatterplot_new (false, NULL, self, gg);

      gg->displays = g_list_append (gg->displays, (gpointer) display);
      gg->current_splot = (splotd *)
      g_list_nth_data (display->splots, 0);
      display->current_splot = gg->current_splot;
      display_set_current (display, gg);

      sp_event_handlers_toggle (gg->current_splot, on, gg->pmode, gg->imode);
    }
  }
  g_signal_emit_by_name (G_OBJECT (gg), "datad_added", d);
}

/**
 * set_variable:
 * @self: #GGobiStage object
 * @j: column index
 *
 * Set variable meta data for specified column
 **/
public void
set_variable (self, guint j, GGobiVariable* value)
{
  // FIXME: This function should be private
  // It's only external use is in cloning of vars, which needs to be redone
  if (g_ptr_array_index(selfp->vartable, j))
    g_object_unref(g_ptr_array_index(selfp->vartable, j));
  g_ptr_array_index(selfp->vartable, j) = value;
  if (!self->parent) /* for unique name */
    self_set_col_name(self, j, NULL);
  self_update_var_name_hash(self, NULL, j);
  ggobi_variable_connect__name_changed(value, self_variable_name_changed_cb, self);
}

/* made this separate from col_name_changed() because we don't want to
   emit that event when the GGobiVariable's name changes */
protected void
update_var_name_hash(self, const gchar *old_name, guint j)
{
  gchar *name = self_get_col_name(self, j);
  if (old_name)
    g_hash_table_remove(selfp->var_name_lookup, old_name);
  g_hash_table_insert(selfp->var_name_lookup, name, GINT_TO_POINTER(j));
}

/* SIGNAL HANDLERS */

private void 
variable_name_changed_cb(GGobi:Variable *var, const gchar *old_name, 
  const gchar *raw_name, gpointer data)
{
  gint j = self_get_col_index_for_name(SELF(data), old_name);
  self_col_name_changed(SELF(data), old_name, j);
}

private void 
vartable_collab_set_by_var_cb(GGobi:Stage *d, const gchar *old_name, guint j, gpointer user_data)
{
  vartable_collab_set_by_var(d, j);
}
private void 
vartable_collab_tform_set_by_var_cb(GGobi:Stage *d, const gchar *old_name, guint j, gpointer user_data)
{
  vartable_collab_tform_set_by_var(d, j);
}
private void
varcircle_label_set_cb(GGobi:Stage * d, const gchar *old_name, guint j, gpointer user_data)
{
  varcircle_label_set(d, j);
}
private void
varpanel_label_set_cb(GGobi:Stage * d, const gchar *old_name, guint j, gpointer user_data)
{
  varpanel_label_set(d, j);
}

/* message handling */

/* override to process any local, outgoing changes */
private virtual void
process_outgoing(self, GGobiPipelineMessage *msg)
/* Here we catch any changes that have occurred to our data matrix and update
   various structures (like GGobiVariable) and fields (like n_rows, n_cols).
   A LOT of this stuff will be gone after the pipeline is in place.
*/
{
  GSList *removed_cols = ggobi_pipeline_message_get_removed_cols(msg);
  GSList *changed_cols = ggobi_pipeline_message_get_changed_cols(msg);
  GSList *removed_rows = ggobi_pipeline_message_get_removed_rows(msg);
  guint n_added_cols = ggobi_pipeline_message_get_n_added_cols(msg);
  guint n_added_rows = ggobi_pipeline_message_get_n_added_rows(msg);
  guint n_removed_cols = g_slist_length(removed_cols);
  guint n_removed_rows = g_slist_length(removed_rows);
  guint col_change = n_added_cols - n_removed_cols;
  guint row_change = n_added_rows - n_removed_rows;
  
  if (col_change)
    self_set_n_cols(self, self->n_cols + col_change);
  
  /* handle column removal */
  if (n_removed_cols) {
    g_debug("removing cols");
    g_slist_foreach(removed_cols, (GFunc)self_removed_col_foreach, self);
    arrayg_delete_cols (&self->jitdata, removed_cols);
    arrayg_delete_cols (&self->world, removed_cols);
    tour2d_realloc_down (removed_cols, self, self->gg);
    tour1d_realloc_down (removed_cols, self, self->gg);
    tourcorr_realloc_down (removed_cols, self, self->gg);
    g_debug("removed");
  }
  
  /* handle column changes */
  g_slist_foreach(changed_cols, (GFunc)self_changed_col_foreach, self);
  
  if (row_change)
    self_set_n_rows(self, self->n_rows + row_change);
  
  if (n_removed_rows) {
    /* row removal */
    arrayg_delete_rows (&self->jitdata, removed_rows);
    arrayg_delete_rows (&self->world, removed_rows);
  }

  /* clean up */
  g_slist_free(removed_cols);
  g_slist_free(removed_rows);
  g_slist_free(changed_cols);
}

/* handlers for keeping GGobiVariable in sync */

private void
changed_col_foreach(guint j, GGobiStage *self)
{
  GGobiVariable *var = self_get_variable(self, j);
  ggobi_variable_update(var);
  // FIXME: incorporate into variable_update
  //limits_set_by_var(SELF(self), j, (SELF(self)->gg) ? SELF(self)->gg->lims_use_visible : true);
  // we could still support atomic events like this
  //g_signal_emit_by_name(self, "col-data-changed", j);
}

private void
removed_col_foreach(guint j, GGobiStage *self)
{
  GGobiVariable *var = self_get_variable(self, j);
  g_object_unref(G_OBJECT(var));
  //g_signal_emit_by_name(self, "col-removed", j);
}

/* subclasses override this to respond to parent changes */
private virtual void
process_incoming(self, GGobiPipelineMessage *msg)
{
  self_queue_message(self, msg); /* queue for dispatch */
}

private void
changed_handler(self, GGobiPipelineMessage *msg)
{
  self_process_incoming(self, msg); /* process incoming message */
  self_flush_changes_here(self); /* pass it on to listeners */
}

private void
col_name_changed_handler(self, const gchar *old_name, guint j)
{
  GGobiVariable *var = self_get_variable(self, j);
  gchar *name = self_get_col_name(self->parent, j);
  gchar *nickname = self_get_col_nickname(self->parent, j);
  ggobi_variable_set_name(var, name);
  /* nicknames are not transformed */
  ggobi_variable_set_nickname(var, nickname);
  g_free(nickname);
  g_free(name);
}

}