%{
  
  // FIXME: temporary
  #include "ggobi-data.h"
  
  // FIXME: these probably won't be necessary - we will not proxy properties
  #define SET_PARENT_PROP(prop) \
    g_object_set_property(G_OBJECT(self->_priv->parent), (prop), VAL)
  #define GET_PARENT_PROP(prop) \
    g_object_get_property(G_OBJECT(self->_priv->parent), (prop), VAL)
  
  #define RELAY_SIGNAL(signal) \
    g_signal_connect_swapped(G_OBJECT(parent), #signal, G_CALLBACK(self_##signal), self)
    
  /* signal handlers */
  
  static void 
  variable_name_changed_cb(GGobiVariable *var, const gchar *old_name, GGobiStage *stage)
  {
    gint j = ggobi_stage_get_col_index_for_name(stage, old_name);
    ggobi_stage_col_name_changed(stage, old_name, j);
  }
  
%}

%h{
  #include "ggobi-variable.h"
  #include "utils.h"
  
  /* for use in GOB parameter checks like: guint j (check < N_COLS) */
  #define N_COLS GGOBI_STAGE(self)->n_cols
  #define N_ROWS GGOBI_STAGE(self)->n_rows;
  
  #define GGOBI_STAGE_IS_COL_CATEGORICAL(stage, col) \
    ggobi_stage_get_col_type((stage), (col)) == GGOBI_VARIABLE_CATEGORICAL
%}

/**
 * SECTION:GGobiStage
 * @short_description: The base class of the GGobi pipeline.
 * @stability: Unstable
 *
 * The GGobi pipeline manipulates data so that it becomes suitable for 
 * a certain visualization. The pipeline consists of stages, each performing
 * a specific task on the data.
 *
 * This class only implements the identity transformation. Subclasses are meant
 * override a subset of these operations in order to transform or otherwise 
 * "decorate" the data on the way to its visualization.
 *
 * Optimization possibilities: data caching and signal buffering
 */
 
class GGobi:Stage from G:Object {

/*-- this forms the pipeline --*/
private GGobiStage *parent;

property OBJECT parent
  (nick = "prev", blurb = "The stage preceeding this one in the pipeline",
    object_type = GGobi:Stage, export)
  set {
    // FIXME: does not yet support reparenting
    GGobiStage *parent = GGOBI_STAGE(g_value_get_object(VAL));
    self->_priv->parent = parent;
    RELAY_SIGNAL(col_data_changed);
    RELAY_SIGNAL(col_name_changed);
    RELAY_SIGNAL(cols_added);
    RELAY_SIGNAL(col_deleted);
    RELAY_SIGNAL(rows_added);
  }
  get { g_value_set_object(VAL, self->_priv->parent); };
   
/*-- every pipeline stage has a name --*/
private gchar *name
  destroywith g_free;

property STRING name
  (nick = "id", blurb = "The name of the pipeline stage",
   default_value = "identity", link, export);

/*-- a pointer to the application context --*/
/*-- note that we don't want this -- the pipeline must be freed of GGobi! --*/
/* private struct _ggobid *gg; */

/* variables are now stored in the stage */
public GPtrArray *vartable = { g_ptr_array_new() } 
  destroy { /* scrap the variables then the array */
    g_ptr_array_foreach(VAR, (GFunc)g_object_unref, NULL); 
    g_ptr_array_free(VAR, TRUE);
  };

/* A note: GOB places 'private' fields in a separate structure, requiring us
  to use '->_priv' to access them. That is a real pain. By making fields
  'protected' they are placed in the object's structure, but are marked so
  that they do not appear in documentation. This may be sufficient. 
  In fact, if no methods are marked 'protected' then there is no need for a 
  private header file and we can tell GOB not to generate one. */

/* we cache the number of rows and columns */

// FIXME: We may in fact leave these as public (read-only) fields since they
// are so commonly used. This is convention in GObject.
// Of course, 'read-only' is by contract and is not enforced by the language
public guint n_rows;
public guint n_cols;

property UINT n_rows 
  (nick = "nrows", blurb = "Number of rows at this stage",
   minimum = 0, maximum = INT_MAX, default_value = 0, link, export);
property UINT n_cols 
  (nick = "ncols", blurb = "Number of cols at this stage",
   minimum = 0, maximum = INT_MAX, default_value = 0, export)
   set { 
     gint nprev = self->n_cols;
     self->n_cols = g_value_get_uint(VAL);
     g_ptr_array_set_size(self->vartable, self->n_cols);
     /* we emit cols_added here, but we can't emit col_deleted */
     if (nprev < self->n_cols)
       self_cols_added(self, self->n_cols - nprev);
   }
   get { g_value_set_uint(VAL, self->n_cols); };

public GHashTable* var_name_lookup = { 
  g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL) 
} destroywith g_hash_table_destroy;
   

public signal first NONE (UINT) void 
col_data_changed(self, guint j) {
  GGobiVariable *var = self_get_variable(self, j);
  ggobi_variable_update(var);
}

public signal first NONE (STRING, UINT) void 
col_name_changed(self, const gchar *old_name, guint j) {
  gchar *name = self_get_col_name(self, j);
  if (old_name)
    g_hash_table_remove(self->var_name_lookup, old_name);
  g_hash_table_insert(self->var_name_lookup, name, GINT_TO_POINTER(j));
}

// FIXME: these signals can probably remain public - may want protected

/**
 * cols_added:
 * @self: #GGobiStage
 * @n: number of new columns
 *
 * Columns added signal
 **/
public signal NONE (UINT) void
cols_added(self, guint n);

/**
 * cols_deleted:
 * @self: #GGobiStage
 * @j: Column deleted
 *
 * Columns deleted signal
 **/
public signal NONE (UINT) void
col_deleted(self, guint j);

/**
 * rows_added:
 * @self: #GGobiStage
 * @n: number of new rows
 * 
 * Rows added signal
 **/
public signal NONE (UINT) void
rows_added(self, guint n);

/** 
 * new:
 *
 * Create new #GGobiStage object
 * 
 * Returns: #GGobiStage object
 **/
public GGobiStage* 
new(const gchar *name, GGobiStage *parent)
{
  GGobiStage* s = GGOBI_STAGE(GET_NEW_VARG("name", name, "parent", parent));
  return(s);
}

/**
 * get_col_name:
 * @self: #GGobiStage
 * @j: column index
 *
 * Returns: allocated column name
 **/
public gchar* 
get_col_name(self, guint j) 
{
  GGobiVariable *var = self_get_variable(self, j);
  g_return_val_if_fail(GGOBI_IS_VARIABLE(var), NULL);
  return ggobi_variable_get_name(var);
}

/**
 * get_col_nickname:
 * @self: #GGobiStage
 * @j: column index
 *
 * Returns: allocated column nickname
 **/
public gchar* 
get_col_nickname(self, guint j) 
{
  GGobiVariable *var = self_get_variable(self, j);
  g_return_val_if_fail(GGOBI_IS_VARIABLE(var), NULL);
  return ggobi_variable_get_nickname(var);
}

/**
 * get_col_index_for_name:
 * @self: #GGobiStage
 * @name: column name
 *
 * Returns: index of column with given name, or -1 if no matching columns
 **/
public gint
get_col_index_for_name(self, const gchar* name) onerror -1
{
  gpointer pos, key;
  if (g_hash_table_lookup_extended(self->var_name_lookup, name, &key, &pos))
    return GPOINTER_TO_INT(pos);
  return -1;
}

/** 
 * set_col_name:
 * @self: GGobiStage object
 * @j: column index
 * @value: new column name (if NULL uses column index)
 *
 * Set column name
 * Also sets nickname to the first two letters.
 * Emits col_name_changed() signal.
 **/
public void 
set_col_name(self, guint j, const gchar* value) 
{
  GGobiVariable* vt = self_get_variable(self, j);
  gchar *nick = NULL, *name;
  
  if (value)
    name = g_strdup(value);
  else {
    nick = g_strdup_printf("V%d", j);
    name = g_strdup_printf("_Var %d", j);
  }
  
  ggobi_variable_set_name(vt, name);
  g_free(name);
  
  if (nick) {
    ggobi_variable_set_nickname(vt, nick);
    g_free(nick);
  }  
}

/** 
 * set_col_nickname:
 * @self: GGobiData object
 * @j: column index
 * @value: new column nickname
 **/
public void 
set_col_nickname(self, guint j, const gchar* value)
{
  GGobiVariable* vt = self_get_variable(self, j);
  ggobi_variable_set_nickname(vt, g_strdup(value));
}

/**
 * set_missing:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 *
 * Set specified cell to be a missing value.  
 * If the variable is categorical, a new level value ("MISSING")
 * will be created, and the raw value set to that.
 **/
virtual void
set_missing(self, guint i, guint j)
{
  self_set_missing(self->_priv->parent, i, j);
}


/**
 * is_missing:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 *
 * Returns: if value at specified positive is missing or not
 **/
virtual gboolean
is_missing(self, guint i, guint j) 
{
  return(self_is_missing(self->_priv->parent, i, j));  
}

/**
 * has_missings:
 * @self: GGobiStage object
 * Returns: whether there are missing values in the stage
 **/
virtual guint
has_missings(self) 
{
  return(self_has_missings(self->_priv->parent));
}

/**
 * get_col_n_missing:
 * @self: GGobiStage object
 * @j: column index
 * Returns: whether or not specified column contains any missing values
 **/
 // FIXME: Should this be cached and made part of GGobiVariable?
public guint 
get_col_n_missing(self, guint j) {
  guint i, n = 0, nrows = self_get_n_rows(self);
  
  for(i = 0; i < nrows; i++) {
    if (self_is_missing(self, i, j)) n++;
  }
  
  return(n);
}


/**
 * set_raw_values:
 * @self: GGobiStage object
 * @j: column index
 * @values: vector of new values, of length self->nrows
 * 
 * Sets all values in the specified column.  
 * Emits self_col_data_changed() signal.
 **/
public void
set_raw_values(self, guint j, gdouble *values)
{
  guint i, nrows = self_get_n_rows(self);
  
  for (i = 0; i < nrows; i++) {
    self_set_raw_value(self, i, j, values[i]);
  }
  self_col_data_changed(self, j);
}


/**
 * set_raw_value:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 * @values: vector of new values, of length self->nrows
 * 
 * Sets a single value in the specified column.  
 *
 * This will set missing values if necessary and sets
 * tform value as well to keep dataset consistent.
 *
 * You need to manually emits self_col_data_changed() signal after
 * using this function if you want the data to continue down the pipeline.
 **/
virtual void
set_raw_value(self, guint i, guint j, gdouble value)
{
  self_set_raw_value(self->_priv->parent, i, j, value);
}

/**
 * set_categorical_value:
 * @self: #GGobiStage
 * @i: row index
 * @j: column index
 * @value: new categorical value
 * 
 * This function sets the value of a cell in a categorical variable.
 * It will automatically create a new level if necessary.
 * If the column is not already categorical, this will make it so.
 */
public void
set_categorical_value(self, guint i, guint j, const gchar* value) 
{
  GGobiVariable* var = self_get_variable(self, j);
  ggobi_variable_add_level(var, value, -1);
  //ggobi_variable_add_level_instance(var, value, -1);
  self_set_raw_value(self, i, j, (gdouble)ggobi_variable_get_level_value(var, value));
}

/**
 * set_string_value:
 * @self: #GGobiStage
 * @i: row index
 * @j: column index
 * @value: new value
 *
 * This function provides a convenient method for setting the
 * value from a string.  Empty strings, . and NA will be treated as
 * missings.  Strings that can be converted to an number will store
 * that number.  Otherwise set_categorical_value() will be used
 **/
public void
set_string_value(self, guint i, guint j, const gchar* value) 
{
  if (is_numeric(value)) {
    self_set_raw_value(self, i, j, (gfloat) g_strtod (value, NULL));
  } else {
    if (!g_ascii_strcasecmp (value, "na") || !strcmp (value, ".") || !strcmp(value, ""))  
      self_set_missing(self, i, j);
    else
      self_set_categorical_value(self, i, j, value);
  }
}

/** 
 * get_raw_value:
 * @self: #GGobiStage
 * @i: row index
 * @j: column index
 **/
virtual gdouble
get_raw_value(self, guint i, guint j)
{
  return self_get_raw_value(self->_priv->parent, i, j);
}

public GGobiVariableType
get_col_type(self, guint j)
{
  GGobiVariable *var = self_get_variable(self, j);
  g_return_val_if_fail(GGOBI_IS_VARIABLE(var), -1);
  return(ggobi_variable_get_vartype(var));
}

virtual GGobiVariable*
create_variable (self, guint j)
{
  return GGOBI_VARIABLE(ggobi_variable_new(self));
}

/**
 * get_variable:
 * @self: #GGobiStage object
 * @j: column index
 *
 * Get variable meta data for specified column
 **/
public GGobiVariable*
get_variable (self, guint j)
{
  /* here we use a lazy creation pattern, because most stages will not need
    to provide variable objects. It could be costly to provide the full set
    of variables for each stage. */
  if (!g_ptr_array_index(self->vartable, j)) {
    GGobiVariable *var = self_create_variable(self, j);
    g_ptr_array_index(self->vartable, j) = var;
    self_col_name_changed(self, NULL, j); /* changed from... undefined */
    ggobi_variable_connect__name_changed(var, variable_name_changed_cb, self);
    self_set_col_name(self, j, NULL);
  }

  return g_ptr_array_index(self->vartable, j);
}

/**
 * get_string_value:
 * @self: #GGobiStage object
 * @i: row index
 * @j: column index
 * @transformed: transformed or raw values?
 *
 * Get string representation of value
 * This currently returns a locale insensitive string, suitable for
 * output into csv etc.  It may be sub-optimal for user display, because
 * it does not use the users locale settings, and outputs full precision.
 **/
// FIXME: obviously broken, waiting on pipeline
public gchar*
get_string_value(self, guint i, guint j, gboolean transformed) 
{
  GGobiVariable *var = self_get_variable(self, j);
  gdouble raw = transformed ? GGOBI_DATA(self)->tform.vals[i][j] : 
    GGOBI_DATA(self)->raw.vals[i][j];
  //gdouble raw = self_get_raw_data(self, i, j);
  
  if (self_is_missing(self, i, j)) 
    return g_strdup("NA");

  if (!GGOBI_VARIABLE_IS_CATEGORICAL(var)) {
    gchar *buf = g_new(gchar, G_ASCII_DTOSTR_BUF_SIZE);
    g_ascii_dtostr(buf, G_ASCII_DTOSTR_BUF_SIZE, raw);
    return buf;
  }
  
  return ggobi_variable_get_level_name(var, raw);
}

/**
 * get_edges_edges:
 * @self: #GGobiStage object
 *
 * Get the number of edges in this dataset
 **/ 
virtual guint
get_n_edges (self)
{
  return(self_get_n_edges(self->_priv->parent));
}

/** 
 * set_row_id:
 * @self: #GGobiStage object
 * @i: row
 * @value: new string value for row id
 * @check: throw error if id is already used?
 *
 * Set the row id (a string) for specified row
 * A row id is a unique string reference to a given row.
 * These are hashed for O(1) lookup.
 **/ 
virtual void
set_row_id(self, guint i, gchar* value, gboolean check) {
  self_set_row_id(self->_priv->parent, i, value, check);
}

/** 
 * get_row_id:
 * @self: #GGobiStage object
 * @i: row
 * 
 * Retrive row id for specified row.
 * Returns: duplicate of row id if present, NULL otherwise
 **/
virtual gchar*
get_row_id(self, guint i) {
  return self_get_row_id(self->_priv->parent, i);
}

/** 
 * get_row_for_id:
 * @self: #GGobiStage object
 * @id: row id string
 * 
 * Get row index corresponding to row id
 *
 * Returns: row index if found, -1 otherwise
 **/
virtual gint
get_row_for_id(self, gchar *id) {
  return self_get_row_for_id(self->_priv->parent, id);
}

}