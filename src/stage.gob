%{
  
  // FIXME: temporary
  #include "ggobi-data.h"
  #include "vars.h"
  #include "externs.h"

  // FIXME: these probably won't be necessary - we will not proxy properties
  #define SET_PARENT_PROP(prop) \
    g_object_set_property(G_OBJECT(self->parent), (prop), VAL)
  #define GET_PARENT_PROP(prop) \
    g_object_get_property(G_OBJECT(self->parent), (prop), VAL)
  
  #define RELAY_SIGNAL(signal) \
    g_signal_connect_swapped(G_OBJECT(parent), #signal, G_CALLBACK(self_##signal##_handler), self)
  
  /* how many signals are we proxying? */
  #define N_HANDLERS 5
  
  /* signal handlers */
  
  /* it may be possible to do this and other handlers within GOB using 
    private methods and g_object_connect_swapped */
  static void 
  variable_name_changed_cb(GGobiVariable *var, const gchar *old_name, 
    const gchar *raw_name, gpointer data)
  {
    GGobiStage *stage = GGOBI_STAGE(data);
    gint j = ggobi_stage_get_col_index_for_name(stage, old_name);
    ggobi_stage_update_var_name_hash(stage, old_name, j);
  }
  
  static void 
  vartable_stats_set_by_var_cb(GGobiStage *d, guint j, gpointer user_data)
  {
    vartable_stats_set_by_var(d, j);
  }
  static void 
  vartable_limits_set_by_var_cb(GGobiStage *d, guint j, gpointer user_data)
  {
    vartable_limits_set_by_var(d, j);
  }
  static void 
  vartable_collab_set_by_var_cb(GGobiStage *d, guint j, gpointer user_data)
  {
    vartable_collab_set_by_var(d, j);
  }
  static void 
  vartable_collab_tform_set_by_var_cb(GGobiStage *d, guint j, gpointer user_data)
  {
    vartable_collab_tform_set_by_var(d, j);
  }
  static void
  varcircle_label_set_cb(GGobiStage * d, guint j, gpointer user_data)
  {
    varcircle_label_set(d, j);
  }
  static void
  varpanel_label_set_cb(GGobiStage * d, guint j, gpointer user_data)
  {
    varpanel_label_set(d, j);
  }
  
%}

%h{
#include "ggobi-variable.h"
#include "utils.h"

/* temporarily */
#include "defines.h"
#include "brushing.h"
#include "fileio.h"

/* for use in GOB parameter checks like: guint j (check < N_COLS) */
#define N_COLS GGOBI_STAGE(self)->n_cols
#define N_ROWS GGOBI_STAGE(self)->n_rows

#define GGOBI_STAGE_IS_COL_CATEGORICAL(stage, col) \
  ggobi_stage_get_col_type((stage), (col)) == GGOBI_VARIABLE_CATEGORICAL

#define GGOBI_STAGE_VARIABLES_ITERATE(stage) \
  guint* var_to_col = ggobi_stage_translate_var_to_col((stage)); \
  guint jj = 0; \
  for(guint j = 0; jj < ggobi_stage_get_n_vars(stage); jj++, j = var_to_col[jj]) 

// Macros for getting and setting attribute values
// -----------------------------------------------


#define GGOBI_STAGE_ATTR_INIT(d, attribute) \
  guint attr_ ## attribute; \
  (attr_ ## attribute = ggobi_stage_get_col_index_for_name(d, "_" #attribute))

#define GGOBI_STAGE_BRUSH_ATTR_INIT(d, attribute) \
  guint attr_ ## attribute [3]; \
  (attr_ ## attribute[0] = ggobi_stage_get_col_index_for_name(d, "_" #attribute)); \
  (attr_ ## attribute[1] = ggobi_stage_get_col_index_for_name(d, "_" #attribute "_now")); \
  (attr_ ## attribute[2] = ggobi_stage_get_col_index_for_name(d, "_" #attribute "_prev"))

#define GGOBI_STAGE_ATTR_INIT_ALL(d) \
  GGOBI_STAGE_BRUSH_ATTR_INIT(d, color); \
  GGOBI_STAGE_BRUSH_ATTR_INIT(d, size); \
  GGOBI_STAGE_BRUSH_ATTR_INIT(d, hidden); \
  GGOBI_STAGE_BRUSH_ATTR_INIT(d, type); \
  \
  GGOBI_STAGE_ATTR_INIT(d, sampled); \
  GGOBI_STAGE_ATTR_INIT(d, excluded); \
  GGOBI_STAGE_ATTR_INIT(d, cluster)
  
#define GGOBI_STAGE_SET_ATTR(d, i, attribute, value, brush) \
  ggobi_stage_set_attr(d, i, attr_ ##attribute[0], attr_ ##attribute[1], attr_ ##attribute[2], (gdouble) value, brush)
#define GGOBI_STAGE_GET_ATTR(d, i, attribute) \
  ggobi_stage_get_attr(d, i, attr_ ##attribute[0], attr_ ##attribute[1], attr_ ##attribute[2])
#define GGOBI_STAGE_RESET_ATTR(d, i, attribute, brush) \
  ggobi_stage_reset_attr(d, i, attr_ ##attribute[0], attr_ ##attribute[1], attr_ ##attribute[2], brush)

#define GGOBI_STAGE_SET_ATTR_COLOR(d, i,  value, brush)  GGOBI_STAGE_SET_ATTR(d, i, color,  value, brush)
#define GGOBI_STAGE_SET_ATTR_TYPE(d, i,   value, brush)  GGOBI_STAGE_SET_ATTR(d, i, type,   value, brush)
#define GGOBI_STAGE_SET_ATTR_SIZE(d, i,   value, brush)  GGOBI_STAGE_SET_ATTR(d, i, size,   value, brush)
#define GGOBI_STAGE_SET_ATTR_HIDDEN(d, i, value, brush)  GGOBI_STAGE_SET_ATTR(d, i, hidden, value, brush)
#define GGOBI_STAGE_SET_ATTR_SAMPLED(d, i, value)  ggobi_stage_set_raw_value(d, i, attr_sampled, (gdouble) value)
#define GGOBI_STAGE_SET_ATTR_EXCLUDED(d, i, value) ggobi_stage_set_raw_value(d, i, attr_excluded, (gdouble) value)
#define GGOBI_STAGE_SET_ATTR_CLUSTER(d, i, value)  ggobi_stage_set_raw_value(d, i, attr_cluster, (gdouble) value)

#define GGOBI_STAGE_GET_ATTR_COLOR(d, i )  ((gushort) GGOBI_STAGE_GET_ATTR(d, i, color  ))
#define GGOBI_STAGE_GET_ATTR_TYPE(d, i  )  ((gint) GGOBI_STAGE_GET_ATTR(d, i, type   ))
#define GGOBI_STAGE_GET_ATTR_SIZE(d, i  )  ((gint) GGOBI_STAGE_GET_ATTR(d, i, size   ))
#define GGOBI_STAGE_GET_ATTR_HIDDEN(d, i)  ((gboolean) GGOBI_STAGE_GET_ATTR(d, i, hidden ))
#define GGOBI_STAGE_GET_ATTR_SAMPLED(d, i)  ((gboolean) ggobi_stage_get_raw_value(d, i, attr_sampled))
#define GGOBI_STAGE_GET_ATTR_EXCLUDED(d, i) ((gboolean) ggobi_stage_get_raw_value(d, i, attr_excluded))
#define GGOBI_STAGE_GET_ATTR_CLUSTER(d, i)  ((gint) ggobi_stage_get_raw_value(d, i, attr_cluster))

#define GGOBI_STAGE_GET_ATTR_GLYPH(d, i)  ggobi_stage_get_attr_glyph(d, i, attr_type[1], attr_size[1])

#define GGOBI_STAGE_RESET_ATTR_COLOR(d, i,  brush)  GGOBI_STAGE_RESET_ATTR(d, i, color,  brush)
#define GGOBI_STAGE_RESET_ATTR_TYPE(d, i,   brush)  GGOBI_STAGE_RESET_ATTR(d, i, type,   brush)
#define GGOBI_STAGE_RESET_ATTR_SIZE(d, i,   brush)  GGOBI_STAGE_RESET_ATTR(d, i, size,   brush)
#define GGOBI_STAGE_RESET_ATTR_HIDDEN(d, i, brush)  GGOBI_STAGE_RESET_ATTR(d, i, hidden, brush)

#define GGOBI_STAGE_BRUSH_POINT(d, i, condition, brush_mode, brush) \
  if (condition) {\
   switch (brush_mode) {\
    case br_candg:\
      GGOBI_STAGE_SET_ATTR_COLOR(d, i, d->gg->color_id, brush);\
      GGOBI_STAGE_SET_ATTR_SIZE(d, i, (&d->gg->glyph_id)->size, brush);\
      GGOBI_STAGE_SET_ATTR_TYPE(d, i, (&d->gg->glyph_id)->type, brush);\
      break;\
    case br_color:\
      GGOBI_STAGE_SET_ATTR_COLOR(d, i, d->gg->color_id, brush);\
      break;\
    case br_glyph:\
      GGOBI_STAGE_SET_ATTR_SIZE(d, i, (&d->gg->glyph_id)->size, brush);\
      GGOBI_STAGE_SET_ATTR_TYPE(d, i, (&d->gg->glyph_id)->type, brush);\
      break;\
    case br_shadow:\
      GGOBI_STAGE_SET_ATTR_HIDDEN(d, i, true, brush);\
      break;\
    case br_unshadow:\
      GGOBI_STAGE_SET_ATTR_HIDDEN(d, i, false, brush);\
      break;\
    default:\
      break;\
    }\
  } else if (brush == ATTR_SET_TRANSIENT) {  \
    switch (brush_mode) {\
    case br_candg:\
      GGOBI_STAGE_RESET_ATTR_COLOR(d, i, ATTR_SET_TRANSIENT);\
      GGOBI_STAGE_RESET_ATTR_SIZE(d, i, ATTR_SET_TRANSIENT);\
      GGOBI_STAGE_RESET_ATTR_TYPE(d, i, ATTR_SET_TRANSIENT);\
      break;\
    case br_color:\
      GGOBI_STAGE_RESET_ATTR_COLOR(d, i, ATTR_SET_TRANSIENT);\
      break;\
    case br_glyph:\
      GGOBI_STAGE_RESET_ATTR_SIZE(d, i, ATTR_SET_TRANSIENT);\
      GGOBI_STAGE_RESET_ATTR_TYPE(d, i, ATTR_SET_TRANSIENT);\
      break;\
    case br_unshadow:\
    case br_shadow:\
      GGOBI_STAGE_RESET_ATTR_HIDDEN(d, i, ATTR_SET_TRANSIENT);\
      break;\
    default:\
      break;\
    }\
  }
    
/*---- STUFF FROM DATA.GOB ----*/
typedef struct _Subset {
  gint random_n;
  gint string_pos;
 /*-- adjustments from which to get values for blocksize, everyn --*/
  GtkAdjustment *bstart_adj, *bsize_adj;
  GtkAdjustment *estart_adj, *estep_adj;
} Subset;


typedef struct _Jitterd {
  gfloat factor;
  gboolean type;
  gboolean convex;
  gfloat *jitfacv;
} Jitterd;

typedef struct _Varpanel_cboxd {
  GtkWidget *ebox;   /*-- child1 of pane widget --*/
  GtkWidget *swin;   /*-- child of ebox --*/
  GtkWidget *vbox;   /*-- child of swin --*/
  GSList *box;       /*-- single column of hboxes --*/
} Varpanel_cboxd;

typedef struct _Varpanel_circd {
  GtkWidget *ebox;        /*-- child2 of pane widget --*/
  GtkWidget *vbox;        /*-- child of ebox --*/
  GtkWidget *swin, *hbox; /*-- children of vbox --*/
  GtkWidget *table;       /*-- sole child of swin; now a vbox --*/
  GtkWidget *manip_btn, *freeze_btn; /*-- children of hbox --*/

  GdkCursor *cursor;
  gint jcursor;

 /*-- components and properties of the table --*/
  GSList *vb, *da, *label;
  GSList *da_pix;         /*-- backing pixmaps --*/
  gint nvars;
} Varpanel_circd;

typedef struct _Varpaneld {
  GtkWidget *hpane;  /*-- child of the ebox --*/
} Varpaneld;

/*-------------------- transformation --------------------------------*/

/* sphering transformation **/
typedef struct _Sphere_d {
  vector_i vars;        /*-- vars available to be sphered --*/
  vector_i vars_sphered;/*-- vars that have been sphered --*/
  gint npcs;      /*-- the first npcs vars of vars will be sphered --*/
  vector_i pcvars;/*-- vars into which sphered data is written --*/

  vector_f eigenval;
  array_d eigenvec;
  array_f vc;
  vector_f tform_mean;
  vector_f tform_stddev;

  gboolean vars_stdized;
} Sphere_d;

typedef struct _BrushBins {
  gint nbins;
  bin_struct **binarray;
  /*
   * bin0 is the bin which contains of the upper left corner of the
   * brush; bin1 is the one containing of the lower right corner.
  */  
  icoords bin0, bin1;
} BrushBins;

// FIXME: This form of edge storage is particular to the default GGobiData
// implementation and so should eventually be declared privately there
typedef struct _EdgeData {
  gint n;
  /* maps from edge to row in edge dataset (mapping not 1-1 due to polygons) */
  guint *indices;
  // FIXME: maybe SymbolicEndpoints could become some sort of boxed structure
  // representing an edge, including its index into the edgeset
  SymbolicEndpoints *sym_endpoints;
  
  // To EDGE-RESOLVER stage
  GList *endpointList;   
    /* a list of endpointsd elements corresponding to the resolved 
       record ids relative to a given datad. This is akin to a table
       indexed by datad elements. **/

  // To BRUSH stage
  gint nxed_by_brush;
  vector_b xed_by_brush;
} EdgeData;

/* END DATA.GOB */

%}

// FIXME: perhaps this could be replaced with a stage that masks arbitrary
// attributes? Like a transient layer on top of a persistent layer.
enum ATTR_SET {
  PERSISTENT,
  TRANSIENT
} GGobi:Attr:Set:Method;

/**
 * SECTION:GGobiStage
 * @short_description: The base class of the GGobi pipeline.
 * @stability: Unstable
 *
 * The GGobi pipeline manipulates data so that it becomes suitable for 
 * a certain visualization. The pipeline consists of stages, each performing
 * a specific task on the data.
 *
 * This class only implements the identity transformation. Subclasses are meant
 * override a subset of these operations in order to transform or otherwise 
 * "decorate" the data on the way to its visualization.
 *
 * Optimization possibilities: data caching and signal buffering
 */
 
class GGobi:Stage from G:Object {

/*-- this forms the pipeline --*/
protected GGobiStage *parent;
property OBJECT parent
  (nick = "prev", blurb = "The stage preceeding this one in the pipeline",
    object_type = GGobi:Stage, export)
  set {
    GGobiStage *parent = g_value_get_object(VAL);
    GGobiStage *former = self->parent;
    
    if (former) {
      for (guint i = 0; i < N_HANDLERS; i++)
        g_signal_handler_disconnect(former, selfp->handlers[i]);
      for (guint j = 0; j < self->n_cols; j++)
        self_col_deleted(self, j);
    }
      
    self->parent = parent;
    /* In order to allow subclasses to block signal forwarding (like
       for row and column filters) we should not simply forward signals.
       They need to pass through a handler first. We can make the handlers
       virtuals that forward by default or we could make one virtual
       for registering (and another for unregistering) the handlers.
       The former seems more robust and convenient. */
    selfp->handlers[0] = RELAY_SIGNAL(col_data_changed);
    selfp->handlers[1] = RELAY_SIGNAL(col_name_changed);
    selfp->handlers[2] = RELAY_SIGNAL(cols_added);
    selfp->handlers[3] = RELAY_SIGNAL(col_deleted);
    selfp->handlers[4] = RELAY_SIGNAL(rows_added);
    selfp->handlers[4] = RELAY_SIGNAL(rows_deleted);
    
    self_cols_added(self, self->parent->n_cols);
  }
  get { g_value_set_object(VAL, self->parent); };

/* stores the ids of our handlers of parent signals */
private gulong *handlers = { g_new(gulong, N_HANDLERS) } destroywith g_free;

/*-- every pipeline stage has a name --*/
public gchar *name
  destroywith g_free;
property STRING name
  (nick = "id", blurb = "The name of the pipeline stage",
   default_value = "identity", link, export);

/*-- a pointer to the application context --*/
/*-- note that we don't want this -- the pipeline must be freed of GGobi! --*/
/* private struct _ggobid *gg; */

/* variables are now stored in the stage */
private GPtrArray *vartable = { g_ptr_array_new() } 
  destroy { /* scrap the variables then the array */
    g_ptr_array_foreach(VAR, (GFunc)g_object_unref, NULL); 
    g_ptr_array_free(VAR, TRUE);
  };

/* we cache the number of rows and columns */

public guint n_rows;
public guint n_cols;

// FIXME: right now these properties are writable.
// The cols_added, rows_added emitters are also public. Perhaps we need
// to protect against this? It only seems (somewhat) valid at GGobiData
// This would mean including ggobi-stage-private.h in stage subclasses.
property UINT n_rows 
  (nick = "nrows", blurb = "Number of rows at this stage",
   minimum = 0, maximum = INT_MAX, default_value = 0, link, export);
property UINT n_cols 
  (nick = "ncols", blurb = "Number of cols at this stage",
   minimum = 0, maximum = INT_MAX, default_value = 0, export)
   set { 
     self->n_cols = g_value_get_uint(VAL);
     g_ptr_array_set_size(selfp->vartable, self->n_cols);
   }
   get { g_value_set_uint(VAL, self->n_cols); };

/*------ STUFF FROM DATA.GOB ---------*/

public struct _ggobid *gg; /*-- a pointer to the parent --*/

/* GUI related */
/* The GUI components should likely hold references to the pipeline stages, 
  not the other way around. If necessary, the GGobi context can map stages to
  GUI components. */
public Varpanel_cboxd  vcbox_ui;
public Varpanel_circd  vcirc_ui;
public Varpaneld  varpanel_ui;
public GtkWidget *vartable_tree_view[GGOBI_VARIABLE_ALL_VARTYPES];
public GtkTreeModel *vartable_tree_model; /* the root model, with all vars **/
public GtkWidget *cluster_table; /*-- table of symbol groups from brushing --*/
public clusteruid *clusvui;
public Subset  subset;

/* PIPELINE AND IMODE OBJECTS */

public Jitterd  jitter;
public Sphere_d  sphere;
public BrushBins  brush;

protected vector_i rows_in_plot;
public vector_i rows_under_brush;
public vector_i rows_under_brush_prev;

public array_f tform;
public array_g world;
public array_g jitdata;

public gboolean missings_show_p; /*-- show/hide per datad, not per display --*/
public gint nrows_in_plot;     /*-- how many elements of rows_in_plot to use --*/
public gint nrows_under_brush;
public gint nrows_under_brush_prev;

/*--------------- clusters: hiding, excluding ----------------------*/

// A pipeline stage could map the data to its clusters
public symbol_cell symbol_table[NGLYPHTYPES][NGLYPHSIZES][MAXNCOLORS];
public gint nclusters;
public clusterd *clusv;

public GSList *sticky_ids; // as an attribute from IDENTIFY stage
   
/* END PIPELINE */

/*-- used in identification, line editing, and point motion --*/
// Could be moved to imode object or a boolean attribute or g_object_set_data()
public gint nearest_point;
public gint nearest_point_prev;

/*-------------------- moving points ---------------------------------*/
// To 'move points' imode?
public GSList *movepts_history; /*-- a list of elements of type celld --*/

/*-- to support brushing by categorical variable --*/
// to the brush imode object?
public gchar* linkvar = NULL;  /*-- the linking variable name--*/

// FIXME: make attributes
public vector_b sampled;
public vector_i clusterid;

// FIXME: shouldn't need this - attributes should be filtered out by pipeline
protected guint n_attributes;

/* END DATA.GOB */

private GHashTable* var_name_lookup = { 
  g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL) 
} destroywith g_hash_table_destroy;

public signal first NONE (UINT) void 
col_data_changed(self, guint j) {
  GGobiVariable *var = self_get_variable(self, j);
  ggobi_variable_update(var);
  // FIXME: incorporate into variable_update
  limits_set_by_var(SELF(self), j, true, true, (SELF(self)->gg) ? SELF(self)->gg->lims_use_visible : true);
  // FIXME: rest of this stuff by pipeline
  tform_to_world_by_var(SELF(self), j);
  if (SELF(self)->gg)
    displays_tailpipe (FULL, SELF(self)->gg);
}

public signal first NONE (UINT) void 
col_name_changed(self, guint j) {
  if (self->parent) {
    GGobiVariable *var = self_get_variable(self, j);
    gchar *name = self_get_col_name(self->parent, j);
    gchar *nickname = self_get_col_nickname(self->parent, j);
    ggobi_variable_set_name(var, name);
    /* nicknames are not transformed */
    ggobi_variable_set_nickname(var, nickname);
    g_free(nickname);
    g_free(name);
  }
}

// FIXME: these signals can probably remain public - may want protected

/**
 * cols_added:
 * @self: #GGobiStage
 * @n: number of new columns
 *
 * Columns added signal
 **/
public signal NONE (UINT) void
cols_added(self, guint n) {
  guint nprev = self->n_cols, ncols = self->n_cols + n;
  
  self_set_n_cols(self, ncols);
  
  for (guint j = nprev; j < ncols; j++) {
    GGobiVariable *var = self_create_variable(self, j);
    self_set_variable(self, j, var);
  }
  
  arrayf_add_cols (&self->tform, ncols);
  arrayg_add_cols (&self->jitdata, ncols);
  arrayg_add_cols (&self->world, ncols);
  
  tour_realloc_up (self, ncols);
};

/**
 * cols_deleted:
 * @self: #GGobiStage
 * @j: Column deleted
 *
 * Columns deleted signal
 **/
public signal NONE (UINT) void
col_deleted(self, guint j) {
  GGobiVariable *var = self_get_variable(self, j);
  g_object_unref(G_OBJECT(var));
  
  self_set_n_cols(self, self->n_cols - 1);

  gint j1 = (gint) j;
  arrayf_delete_cols (&self->tform, 1, &j1);
  arrayg_delete_cols (&self->jitdata, 1, &j1);
  arrayg_delete_cols (&self->world, 1, &j1);
  
  //FIXME: need function analogous to tour_relloc_up
  tour2d_realloc_down (1, &j1, self, self->gg);
  tour1d_realloc_down (1, &j1, self, self->gg);
  tourcorr_realloc_down (1, &j1, self, self->gg);
  
  /* clearly inefficient but will be OK for now */
  tform_to_world(GGOBI_STAGE(self));
};

/**
 * rows_added:
 * @self: #GGobiStage
 * @n: number of new rows
 * 
 * Rows added signal
 **/
public signal NONE (UINT) void
rows_added(self, guint n) {
  gint i, nprev = self->n_rows, nrows = self->n_rows + n;
  self_set_n_rows(self, nrows);
  
  vectorb_realloc (&self->sampled, nrows);
  vectori_realloc (&self->rows_in_plot, nrows);
  vectori_realloc (&self->rows_under_brush, nrows);
  vectori_realloc (&self->rows_under_brush_prev, nrows);
  vectori_realloc (&self->clusterid, nrows);
  
  arrayf_add_rows (&self->tform, nrows);
  arrayg_add_rows (&self->jitdata, nrows);
  arrayg_add_rows (&self->world, nrows);
  
  self->nrows_under_brush = self->nrows_under_brush_prev = 0;
  
  for (i = nprev; i < nrows; i++) {
    self->sampled.els[i] = true;
    
    self->rows_under_brush.els[i] = 0;
    self->rows_under_brush_prev.els[i] = 0;
  }
  
  clusters_set(self);
  self_set_rows_in_plot(self);
};


/* We probably want to say which rows here, lest clients must refresh all */
public signal NONE (POINTER, UINT) void
rows_deleted(self, guint *rows, guint n);

init (self) {
  sphere_init(self);
  self->nearest_point = -1;
  self->missings_show_p = true;
}

/** 
 * new:
 *
 * Create new #GGobiStage object
 * 
 * Returns: #GGobiStage object
 **/
public GGobiStage* 
new(const gchar *name, GGobiStage *parent)
{
  GObject* s = (GObject *)GET_NEW_VARG("name", name, "parent", parent, NULL);
  return(GGOBI_STAGE(s));
}

/**
 * get_col_name:
 * @self: #GGobiStage
 * @j: column index
 *
 * Returns: allocated column name
 **/
public gchar* 
get_col_name(self, guint j) 
{
  GGobiVariable *var = self_get_variable(self, j);
  g_return_val_if_fail(GGOBI_IS_VARIABLE(var), NULL);
  return ggobi_variable_get_name(var);
}

/**
 * get_col_nickname:
 * @self: #GGobiStage
 * @j: column index
 *
 * Returns: allocated column nickname
 **/
public gchar* 
get_col_nickname(self, guint j) 
{
  GGobiVariable *var = self_get_variable(self, j);
  g_return_val_if_fail(GGOBI_IS_VARIABLE(var), NULL);
  return ggobi_variable_get_nickname(var);
}

/**
 * get_col_index_for_name:
 * @self: #GGobiStage
 * @name: column name
 *
 * Returns: index of column with given name, or -1 if no matching columns
 **/
public gint
get_col_index_for_name(self, const gchar* name) onerror -1
{
  gpointer pos, key;
  if (g_hash_table_lookup_extended(selfp->var_name_lookup, name, &key, &pos))
    return GPOINTER_TO_INT(pos);
  return -1;
}

/** 
 * set_col_name:
 * @self: GGobiStage object
 * @j: column index
 * @value: new column name (if NULL uses column index)
 *
 * Set column name
 * Also sets nickname to the first two letters.
 * Emits col_name_changed() signal.
 **/
public void 
set_col_name(self, guint j, const gchar* value) 
{
  GGobiVariable* vt;
  gchar *nick = NULL, *name;
  GGobiStage *root = self_get_root(self);
  
  if (self != root) {
    self_set_col_name(root, j, value);
    return;
  }

  vt = self_get_variable(self, j);
  
  if (value)
    name = g_strdup(value);
  else {
    nick = g_strdup_printf("V%d", j);
    name = g_strdup_printf("_Var %d", j);
  }
  
  if (nick) {
    ggobi_variable_set_nickname(vt, nick);
    g_free(nick);
  }
  
  ggobi_variable_set_name(vt, name);
  g_free(name);
  
  self_col_name_changed(self, j);
}

/** 
 * set_col_nickname:
 * @self: GGobiData object
 * @j: column index
 * @value: new column nickname
 **/
public void 
set_col_nickname(self, guint j, const gchar* value)
{
  GGobiVariable* vt = self_get_variable(self, j);
  ggobi_variable_set_nickname(vt, g_strdup(value));
}

/**
 * set_missing:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 *
 * Set specified cell to be a missing value.  
 * If the variable is categorical, a new level value ("MISSING")
 * will be created, and the raw value set to that.
 **/
virtual void
set_missing(self, guint i, guint j)
{
  self_set_missing(self->parent, i, j);
}


/**
 * is_missing:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 *
 * Returns: if value at specified positive is missing or not
 **/
virtual gboolean
is_missing(self, guint i, guint j) 
{
  return(self_is_missing(self->parent, i, j));  
}

/**
 * has_missings:
 * @self: GGobiStage object
 * Returns: whether there are missing values in the stage
 **/
public gboolean
has_missings(self) 
{
  for (guint j = 0; j < self->n_cols; j++)
    if (ggobi_variable_has_missings(self_get_variable(self, j)))
      return(TRUE);
  return(FALSE);
}

/**
 * get_col_n_missing:
 * @self: GGobiStage object
 * @j: column index
 * Returns: how many missing values does a column have?
 **/
 // FIXME: Should this be cached and made part of GGobiVariable?
 // Well, it takes longer (on average) to count missings than detect them
 // This is only used in the variable notebook, so maybe we could count there.
public guint 
get_col_n_missing(self, guint j) {
  guint i, n = 0, nrows = self_get_n_rows(self);
  
  for(i = 0; i < nrows; i++) {
    if (self_is_missing(self, i, j)) n++;
  }
  
  return(n);
}


/**
 * set_raw_values:
 * @self: GGobiStage object
 * @j: column index
 * @values: vector of new values, of length self->nrows
 * 
 * Sets all values in the specified column.  
 * Emits self_col_data_changed() signal.
 **/
public void
set_raw_values(self, guint j, gdouble *values)
{
  guint i, nrows = self_get_n_rows(self);
  
  for (i = 0; i < nrows; i++) {
    self_set_raw_value(self, i, j, values[i]);
  }
  self_col_data_changed(self, j);
}


/**
 * set_raw_value:
 * @self: GGobiStage object
 * @i: row index
 * @j: column index
 * @values: vector of new values, of length self->nrows
 * 
 * Sets a single value in the specified column.  
 *
 * This will set missing values if necessary and sets
 * tform value as well to keep dataset consistent.
 *
 * You need to manually emits self_col_data_changed() signal after
 * using this function if you want the data to continue down the pipeline.
 **/
virtual void
set_raw_value(self, guint i, guint j, gdouble value)
{
  self_set_raw_value(self->parent, i, j, value);
  self->tform.vals[i][j] = value;
}

/**
 * set_categorical_value:
 * @self: #GGobiStage
 * @i: row index
 * @j: column index
 * @value: new categorical value
 * 
 * This function sets the value of a cell in a categorical variable.
 * It will automatically create a new level if necessary.
 * If the column is not already categorical, this will make it so.
 */
virtual void
set_categorical_value(self, guint i, guint j, const gchar* value) 
{
  if (self->parent)
    self_set_categorical_value(self->parent, i, j, value);
  else {
    GGobiVariable *root_var = self_get_variable(self, j);
    ggobi_variable_add_level(root_var, value, -1);
    self_set_raw_value(self, i, j, 
      (gdouble)ggobi_variable_get_level_value(root_var, value));
  }
}

virtual const gchar *
get_categorical_value(self, guint i, guint j)
{
  GGobiVariable *var = self_get_variable(self, j);
  gint value = (gint)self_get_raw_value(self, i, j);
  if (ggobi_variable_has_level(var, value))
    return ggobi_variable_get_level_name(var, value);
  /*g_return_val_if_fail(self->parent != NULL, NULL);*/
  if (!self->parent)
    return NULL;
  return self_get_categorical_value(self->parent, i, j);
}

/**
 * set_string_value:
 * @self: #GGobiStage
 * @i: row index
 * @j: column index
 * @value: new value
 *
 * This function provides a convenient method for setting the
 * value from a string.  Empty strings, . and NA will be treated as
 * missings.  Strings that can be converted to an number will store
 * that number.  Otherwise set_categorical_value() will be used
 **/
public void
set_string_value(self, guint i, guint j, const gchar* value) 
{
  if (is_numeric(value)) {
    self_set_raw_value(self, i, j, (gfloat) g_strtod (value, NULL));
  } else {
    if (!g_ascii_strcasecmp (value, "na") || !strcmp (value, ".") || !strcmp(value, ""))  
      self_set_missing(self, i, j);
    else
      self_set_categorical_value(self, i, j, value);
  }
}

/** 
 * get_raw_value:
 * @self: #GGobiStage
 * @i: row index
 * @j: column index
 **/
virtual gdouble
get_raw_value(self, guint i, guint j)
{
  return self_get_raw_value(self->parent, i, j);
}

public GGobiVariableType
get_col_type(self, guint j)
{
  GGobiVariable *var = self_get_variable(self, j);
  g_return_val_if_fail(GGOBI_IS_VARIABLE(var), -1);
  return(ggobi_variable_get_vartype(var));
}

/** 
 * get_col_is_attribute:
 * @self: #GGobiStage
 * @j: column index
 *
 * Returns: true if this column is an attribute
 **/
public gboolean
col_is_attribute(self, guint j) {
  GGobiVariable* vt = self_get_variable(self, j);
  return vt->is_attribute;
}

/** 
 * translate_var_to_col:
 * @self: #GGobiStage
 *
 * Returns: an array of length n_vars, with value i
 * indicating the column of variable i
 **/
public guint*
translate_var_to_col(self) {
  guint nvars = self_get_n_vars(self);
  guint* translate = g_new(guint, nvars);
  
  guint var = 0;
  for(guint j = 0; j < self->n_cols; j++) {
    if (self_col_is_attribute(self, j)) continue;
    translate[var++] = j;
  }
  
  return(translate);
}


virtual GGobiVariable*
create_variable (self, guint j)
{
  if (self->parent)
    return ggobi_variable_clone(self_get_variable(self->parent, j));
  return GGOBI_VARIABLE(ggobi_variable_new(self));
}

/**
 * get_variable:
 * @self: #GGobiStage object
 * @j: column index
 *
 * Get variable meta data for specified column
 **/
public GGobiVariable*
get_variable (self, guint j)
{
  return g_ptr_array_index(selfp->vartable, j);
}

/**
 * get_string_value:
 * @self: #GGobiStage object
 * @i: row index
 * @j: column index
 * @transformed: transformed or raw values?
 *
 * Get string representation of value
 * This currently returns a locale insensitive string, suitable for
 * output into csv etc.  It may be sub-optimal for user display, because
 * it does not use the users locale settings, and outputs full precision.
 **/
// FIXME: obviously broken, waiting on pipeline
public gchar*
get_string_value(self, guint i, guint j, gboolean transformed) 
{
  GGobiVariable *var = self_get_variable(self, j);
  gdouble raw = transformed ? self->tform.vals[i][j] : 
    GGOBI_DATA(self)->raw.vals[i][j];
  //gdouble raw = self_get_raw_data(self, i, j);
  
  if (self_is_missing(self, i, j)) 
    return g_strdup("NA");

  if (!GGOBI_VARIABLE_IS_CATEGORICAL(var)) {
    gchar *buf = g_new(gchar, G_ASCII_DTOSTR_BUF_SIZE);
    g_ascii_dtostr(buf, G_ASCII_DTOSTR_BUF_SIZE, raw);
    return buf;
  }
  
  return g_strdup(ggobi_variable_get_level_name(var, raw));
}

/**
 * get_edges_edges:
 * @self: #GGobiStage object
 *
 * Get the number of edges in this dataset
 **/ 
virtual guint
get_n_edges (self)
{
  return(self_get_n_edges(self->parent));
}

// FIXME: dirty hack so that we can keep the edge data in GGobiData where it belongs
// We need to work out an actual API eventually
virtual EdgeData *
get_edge_data (self)
{
  return(self_get_edge_data(self->parent));
}

/** 
 * set_row_id:
 * @self: #GGobiStage object
 * @i: row
 * @value: new string value for row id
 * @check: throw error if id is already used?
 *
 * Set the row id (a string) for specified row
 * A row id is a unique string reference to a given row.
 * These are hashed for O(1) lookup.
 **/ 
virtual void
set_row_id(self, guint i, gchar* value, gboolean check) {
  self_set_row_id(self->parent, i, value, check);
}

/** 
 * get_row_id:
 * @self: #GGobiStage object
 * @i: row
 * 
 * Retrive row id for specified row.
 * Returns: duplicate of row id if present, NULL otherwise
 **/
virtual gchar*
get_row_id(self, guint i) {
  return self_get_row_id(self->parent, i);
}

/** 
 * get_row_for_id:
 * @self: #GGobiStage object
 * @id: row id string
 * 
 * Get row index corresponding to row id
 *
 * Returns: row index if found, -1 otherwise
 **/
virtual gint
get_row_for_id(self, gchar *id) {
  return self_get_row_for_id(self->parent, id);
}


public GGobiStage *
get_root(self)
{
  GGobiStage *stage;
  for (stage = self; stage->parent != NULL; stage = stage->parent);
  return(stage);
}

/* Attributes
 * ============================================================================
 */

/**
 * set_attr_color:
 * @self: #GGobiStage
 * @i: row index
 * @j: attribute column
 * @j_now: column index for transient value of attribute
 * @j_prev: column index for previous value of attribute
 * @brush: persistent or transient
 *
 * Sets attribute to new value. Use with GGOBI_STAGE_ATTR_INIT and
 * GGOBI_STAGE_ATTR_SET
 * Returns: true if value has changed, false otherwise
**/
public gboolean
set_attr(self, guint i, guint j, guint j_now, guint j_prev, gdouble value, GGobiAttrSetMethod brush)
{
  //g_debug("(%i,%i %i %i) -> %g %s", i, j, j_now, j_prev, value, brush == ATTR_SET_TRANSIENT ? "t" : "p");
  if (brush == ATTR_SET_TRANSIENT ?
    (self_get_raw_value(self, i, j_now) == value) :
    (self_get_raw_value(self, i, j) == value))
    return false;

  if (brush == ATTR_SET_PERSISTENT) {
    self_set_raw_value(self, i, j_prev, self_get_raw_value(self, i, j));
    self_set_raw_value(self, i, j, value);
  }

  self_set_raw_value(self, i, j_now, value);
  return true;
}

public gboolean
reset_attr(self, guint i, guint j, guint j_now, guint j_prev, GGobiAttrSetMethod brush)
{
  gdouble value;
  switch(brush) {
    case ATTR_SET_PERSISTENT:
      value = self_get_raw_value(self, i, j_prev);
    default:
      value = self_get_raw_value(self, i, j);
  }
  
  return self_set_attr(self, i, j, j_now, j_prev, value, brush);
}

public gdouble
get_attr(self, guint i, guint j, guint j_now, guint j_prev)
{
  return self_get_raw_value(self, i, j_now);
}

/**
 * get_attr_glyph:
 * @self: #GGobiStage
 * @i: row index
 * 
 * Retrieve current glyph
**/
public glyphd* 
get_attr_glyph(self, guint i, guint j_type, guint j_size)
{
  glyphd* glyph = (glyphd*) g_malloc (sizeof (glyphd));   
  glyph->type = (gshort) self_get_raw_value(self, i, j_type);
  glyph->size = (gshort) self_get_raw_value(self, i, j_size);
  return glyph;
}






// FIXME: to be removed once pipeline in place
/** 
 * get_transformed_col_name:
 * @self: GGobiStage object
 * @j: column index
 * Returns: duplicate of transformed column name (brief description of transformation
 * applied to variable)
 **/
public gchar* 
get_transformed_col_name(self, guint j) 
{
  gchar *lbl0, *lbl1, *lbl2;
  GGobiVariable *vt = self_get_variable(self, j);

   /*-- skip the stage0 changes except negation --*/
   switch (vt->tform0) {
     case NEGATE:
       lbl0 = g_strdup_printf ("-%s", self_get_col_name(self, j));
       break;
     default:
       lbl0 = g_strdup (self_get_col_name(self, j));
       break;
   }

   switch (vt->tform1) {
     case BOXCOX:
       lbl1 = g_strdup_printf ("B-C(%s,%.2f)", lbl0, vt->param);
       break;
     case LOG10:
       lbl1 = g_strdup_printf ("log10(%s)", lbl0);
       break;
     case INVERSE:
       lbl1 = g_strdup_printf ("1/%s", lbl0);
       break;
     case ABSVALUE:
       lbl1 = g_strdup_printf ("abs(%s)", lbl0);
       break;
     case SCALE_AB:
       lbl1 = g_strdup_printf ("%s [a,b]", lbl0);
       break;
     default:
       lbl1 = g_strdup (lbl0);
   }

   switch (vt->tform2) {
     case STANDARDIZE:
       lbl2 = g_strdup_printf ("(%s-m)/s", lbl1);
     break;
     case SORT:
       lbl2 = g_strdup_printf ("sort(%s)", lbl1);
     break;
     case RANK:
       lbl2 = g_strdup_printf ("rank(%s)", lbl1);
     break;
     case NORMSCORE:
       lbl2 = g_strdup_printf ("normsc(%s)", lbl1);
     break;
     case ZSCORE:
       lbl2 = g_strdup_printf ("zsc(%s)", lbl1);
     break;
     case DISCRETE2:
       lbl2 = g_strdup_printf ("%s:0,1", lbl1);
     break;
     default:
       lbl2 = g_strdup (lbl1);
   }
   
   return lbl2;
}

// FIXME: data/attribute distinction should be made by a pipeline stage
public guint
get_n_vars(self) {
  return self_get_n_cols(self) - self->n_attributes;
}

// FIXME: go away!
private signal first NONE (UINT) void 
rows_in_plot_changed(self, guint n) {
  tform_to_world(self);
  if (self->gg)
    displays_tailpipe (FULL, self->gg);
}

/**
 * set_rows_in_plot:
 * @self: #GGobiData object
 *
 * Combine the values in two arrays:
 *   excluded[] (which comes from the exclusion panel or from linking)
 *   sampled[] (which come from the subset panel)
 * to determine which cases should be plotted.
 *
 * rows_in_plot = sampled && !excluded
 **/
 // FIXME: Needs to go bye-bye
public void
set_rows_in_plot(self)
{
  guint i;
  self->nrows_in_plot = 0;

  GGOBI_STAGE_ATTR_INIT_ALL(self);
  for (i = 0; i < self->n_rows; i++)
    if (self->sampled.els[i] && !GGOBI_STAGE_GET_ATTR_EXCLUDED(GGOBI_STAGE(self), i))
      self->rows_in_plot.els[self->nrows_in_plot++] = i;
  
  self_rows_in_plot_changed(self, (guint) self->nrows_in_plot); 
}

/**
 * attach:
 * @self: #GGobiStage object
 * @gg: GGobi object
 * @cleanup: should cleanup occur?
 *
 * Attach a GGobi object to this dataset
 * The purpose of this function is to hook up the #GGobiData object
 * to all the gui components and make sure they stay in sync by
 * listening to the correct signals.  This function still needs a lot of
 * work.
 **/
 // FIXME: This should not exist.. we need a ggobi_app_add_data()
public void 
attach (self, ggobid *gg, gboolean cleanup)
{
  self->gg = gg;
  gg->d = g_slist_append (gg->d, self);
  displayd *display = NULL;
  GGobiData *d = GGOBI_DATA(self_get_root(self));

  gint *vars = (gint *) g_malloc(GGOBI_STAGE(self)->n_cols * sizeof(gint));
  
  self->brush.bin0.x = self->brush.bin1.x = BRUSH_NBINS;
  self->brush.bin0.y = self->brush.bin1.y = BRUSH_NBINS;

  gint iv, ih;
  self->brush.nbins = BRUSH_NBINS;

  edgeedit_init (self->gg);
  if (ggobi_stage_get_n_edges(GGOBI_STAGE(self)))
    vectorb_realloc (&d->edge.xed_by_brush, d->edge.n);

  /* binning the plot window; no need to realloc these **/
  self->brush.binarray = (bin_struct **)
    g_malloc (self->brush.nbins * sizeof (bin_struct *));
  for (ih = 0; ih < self->brush.nbins; ih++) {
    self->brush.binarray[ih] = (bin_struct *)
      g_malloc (self->brush.nbins * sizeof (bin_struct));

    for (iv = 0; iv < self->brush.nbins; iv++) {
      self->brush.binarray[ih][iv].nels = 0;
      self->brush.binarray[ih][iv].nblocks = 1;
      self->brush.binarray[ih][iv].els = (gulong *)
        g_malloc (BINBLOCKSIZE * sizeof (gulong));
    }
  }

  /**
   * If there are missings, they've been initialized with a value
   * of 0.  Here, re-set that value to 15% below the minimum for each
   * variable.  (dfs -- done at Di's request, September 2004)
   **/
  limits_set (self, true, true, self->gg->lims_use_visible);
  for (guint j = 0; j < self->n_cols; j++) vars[j] = j;
  impute_fixed (IMP_BELOW, 15.0, self->n_cols, vars, self);
  limits_set (self, true, true, self->gg->lims_use_visible);
  g_free(vars);

  for(guint j = 0; j < self_get_n_vars(self); j++) 
    self_col_data_changed(self, j);

  clusters_set(self);  /*-- find the clusters for data just read in --*/

  display_menu_build (gg);
  
  // Set up variable table and listen to important events
  self_connect__col_data_changed(self, vartable_stats_set_by_var_cb, NULL);
  self_connect__col_data_changed(self, vartable_limits_set_by_var_cb, NULL);
  self_connect__col_name_changed(self, vartable_collab_set_by_var_cb, NULL);
  self_connect__col_name_changed(self, vartable_collab_tform_set_by_var_cb, NULL);

  varcircles_populate (self, gg);
  self_connect__col_name_changed(self, varcircle_label_set_cb, NULL);

  if (cleanup)
    varpanel_clear (self, gg);
  varpanel_populate (self, gg);   
  if (gg->current_display != NULL)
    varpanel_refresh (gg->current_display, gg);
  if (g_slist_index(gg->d, (gpointer)self) == 0)
    varpanel_set_sensitive (self, true, gg);
  self_connect__col_name_changed(self, varpanel_label_set_cb, NULL);
  
  if (cleanup || g_list_length(gg->displays) == 0) {
    display_free_all (gg);  /*-- destroy any existing displays --*/
    gg->pmode = NULL_PMODE;

    /*-- initialize the first display --*/
    if(sessionOptions->info->createInitialScatterPlot && 
        self_get_n_cols(self)) {
      display = scatterplot_new (false, NULL, self, gg);

      gg->displays = g_list_append (gg->displays, (gpointer) display);
      gg->current_splot = (splotd *)
      g_list_nth_data (display->splots, 0);
      display->current_splot = gg->current_splot;
      display_set_current (display, gg);

      sp_event_handlers_toggle (gg->current_splot, on, gg->pmode, gg->imode);
    }
  }
  g_signal_emit_by_name (G_OBJECT (gg), "datad_added", self);
}

/**
 * set_variable:
 * @self: #GGobiStage object
 * @j: column index
 *
 * Set variable meta data for specified column
 **/
public void
set_variable (self, guint j, GGobiVariable* value)
{
  // FIXME: This function should be private
  // It's only external use is in cloning of vars, which needs to be redone
  if (g_ptr_array_index(selfp->vartable, j))
    g_object_unref(g_ptr_array_index(selfp->vartable, j));
  g_ptr_array_index(selfp->vartable, j) = value;
  if (!self->parent) /* for unique name */
    self_set_col_name(self, j, NULL);
  self_update_var_name_hash(self, NULL, j);
  ggobi_variable_connect__name_changed(value, variable_name_changed_cb, self);
}

/* made this separate from col_name_changed() because we don't want to
   emit that event when the GGobiVariable's name changes */
protected void
update_var_name_hash(self, const gchar *old_name, guint j)
{
  gchar *name = self_get_col_name(self, j);
  if (old_name)
    g_hash_table_remove(selfp->var_name_lookup, old_name);
  g_hash_table_insert(selfp->var_name_lookup, name, GINT_TO_POINTER(j));
}

private virtual void
col_data_changed_handler(self, guint j)
{
  self_col_data_changed(self, j);
}
private virtual void
col_deleted_handler(self, guint j)
{
  self_col_deleted(self, j);
}
private virtual void
cols_added_handler(self, guint n)
{
  self_cols_added(self, n);
}
private virtual void
rows_added_handler(self, guint n)
{
  self_rows_added(self, n);
}
private virtual void
rows_deleted_handler(self, guint *rows, guint n)
{
  self_rows_deleted(self, rows, n);
}
private virtual void
col_name_changed_handler(self, guint j)
{
  self_col_name_changed(self, j);
}

}