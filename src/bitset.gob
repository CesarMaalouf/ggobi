%h{
  #include "utils.h" /* for GGobiIndexFunc */
%}
%{
  #define BITS_PER_CHUNK 8
  #define N_BITS self->bits->len * BITS_PER_CHUNK
  
  /* we use these macros internally for speed */
  #define SET_BIT(i, v) \
    self->bits->data[(i) / BITS_PER_CHUNK] |= (v) << ((i) % BITS_PER_CHUNK)
  #define TEST_BIT(i) \
    (self->bits->data[(i) / BITS_PER_CHUNK] & (1 << ((i) % BITS_PER_CHUNK))) > 0
%}
/* For storing lists of indices, in addition to pure bit ops */
/* Some of this code was "inspired" by the bitsets in mono and java.util */
class GGobi:Bitset from G:Object {
  
  protected GByteArray *bits = { g_byte_array_new() } destroy { 
    g_byte_array_free(VAR, TRUE);
  };
  
  /* creation */
  
  public GGobiBitset *
  new(void)
  {
    GObject *obj = (GObject *)GET_NEW;
    return GGOBI_BITSET(obj);
  }
  public GGobiBitset *
  new_with_size(guint size)
  {
    GGobiBitset *bs = self_new();
    self_set_size(bs, size);
    return bs;
  }
  
  public virtual GGobiBitset *
  clone(self)
  {
    GGobiBitset *other = ggobi_bitset_new_with_size(self_get_size(self));
    for (guint i = 0; i < self->bits->len; i++)
      other->bits->data[i] = self->bits->data[i];
    return other;
  }
  
  /* size management */
  
  public void
  set_size(self, guint size)
  {
    guint i, size_bytes = (size + BITS_PER_CHUNK - 1) / BITS_PER_CHUNK;
    guint old_size = self->bits->len;
    g_byte_array_set_size(self->bits, size_bytes);
    for (i = old_size; i < size_bytes; i++)
      self->bits->data[i] = 0;
  }
  public guint
  get_size(self)
  {
    return self->bits->len * BITS_PER_CHUNK;
  }
  
  /* index operations */
  
  /* the indices must be sorted for insertion and removal */
  // FIXME: Do we want to sort here?
  
  public void
  remove_indices(self, GSList *indices)
  {
    guint i = indices ? GPOINTER_TO_INT(indices->data) : 0, dec = 0;
    for (; indices; indices = indices->next) {
      guint index = GPOINTER_TO_INT(indices->data);
      /* shift indices */
      while(i < index) {
        SET_BIT(i - dec, TEST_BIT(i));
        i++;
      }
      /* remove index, if present */
      SET_BIT(i, 0);
      dec++;
    }
  }
  public void /* just the opposite of removal */
  insert_indices(self, GSList *indices)
  {
    GSList *rev_indices = g_slist_reverse(g_slist_copy(indices));
    guint i = self->bits->len, inc = g_slist_length(indices);
    for (; rev_indices; rev_indices = rev_indices->next) {
      guint index = GPOINTER_TO_INT(rev_indices->data);
      /* shift indices */
      while(i > index) {
        SET_BIT(i, TEST_BIT(i - inc));
        i--;
      }
      /* inset index */
      SET_BIT(i, 1);
      inc--;
    }
    g_slist_free(rev_indices);
  }
  public GSList *
  get_indices(self)
  {
    guint i;
    GSList *indices = NULL;
    for (i = 0; i < self->bits->len; i++) {
      guchar byte = self->bits->data[i];
      if (byte) {
        gint msb = g_bit_nth_msf(byte, -1);
        gint lsb = -1;
        while(lsb != msb) {
          lsb = g_bit_nth_lsf(byte, lsb); 
          indices = g_slist_prepend(indices, GINT_TO_POINTER(lsb + i * BITS_PER_CHUNK));
        }
      }
    }
    return g_slist_reverse(indices);
  }
  public guint
  get_n_indices(self)
  {
    static const guchar table[16] = {
      0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4
    };
    guint i, count = 0;
    /* there has been talk about to adding this functionality to GLib,
       except much faster (asm based) 
    */
    for (i = 0; i < self->bits->len; i++) {
      guchar b = self->bits->data[i];
      if (b) {
        count += table [b & 0xf];
        count += table [b >> 4];
      }
    }
    return count;
  }
  public void
  foreach(self, GGobiIndexFunc func, gpointer data)
  {
    GSList *indices = self_get_indices(self);
    g_slist_foreach(indices, (GFunc)func, data);
    g_slist_free(indices);
  }
  
  /* pure bit operations */
  
  public void
  clear(self)
  {
    guint i;
    for (i = 0; i < self->bits->len; i++)
      self->bits->data[i] = 0;
  }
  public void
  set(self, guint i  (check < N_BITS))
  {
    SET_BIT(i, 1);
  }
  public void
  unset(self, guint i  (check < N_BITS))
  {
    SET_BIT(i, 0);
  }
  public gboolean
  test(self, guint i  (check < N_BITS))
  {
    return TEST_BIT(i);
  }
  
  /* set operations */
  // TODO: not, and, or, xor, subtract, subset
}
