%h{
  #include <gsf/gsf-input-impl.h>
  #include <gsf/gsf-input.h>
  /* apparently the GSF guys don't like this convention */
  #define GSF_TYPE_INPUT gsf_input_get_type()
%}
%{
  #include <libxml/nanohttp.h>
%}
class GGobi:Gsf:Input:HTTP from Gsf:Input
{
  private gchar *url destroywith g_free;
  property STRING url
    (nick = "URL", blurb = "HTTP(S) URL accessed by this stream", link, export);
  private gchar *content_type destroywith g_free;
  property STRING content_type
    (nick = "mime type", blurb = "Content-Type in HTTP header", link, export);
  private gpointer ctx destroywith xmlNanoHTTPClose;
  
  private guint8 *buf destroywith g_free;
  private gsize buf_size;
  
  public GsfInput *
  new(const gchar *url, GError **error)
  {
    GObject *obj = (GObject *)GET_NEW_VARG("url", url, NULL);
    GGobiGsfInputHTTP *input = SELF(obj);
    gpointer ctx;
    char *content_type;
    
    ctx = SELF(obj)->_priv->ctx = xmlNanoHTTPOpen(input->_priv->url, &content_type);
    if (!ctx) /* no meaningful errors provided by nanohttp */
      return NULL;
    
    if (content_type)
      self_set_content_type(input, content_type);
    
    gsf_input_set_size(GSF_INPUT(obj), xmlNanoHTTPContentLength(ctx));
    
    return GSF_INPUT(obj);
  }
  
  override (Gsf:Input) GsfInput *
  Dup(GsfInput *src, GError **err)
  {
    return ggobi_gsf_input_http_new(SELF(src)->_priv->url, err);
  }
  
  override (Gsf:Input) const guint8 *
  Read(GsfInput *input, size_t num_bytes, guint8 *buffer)
  {
    int nread;
    size_t total_read;
    gpointer ctx = SELF(input)->_priv->ctx;
    GGobiGsfInputHTTP *self = SELF(input);
    
    if (buffer == NULL) {
      if (selfp->buf_size < num_bytes) {
        selfp->buf_size = num_bytes;
        g_free (selfp->buf);
        selfp->buf = g_new (guint8, selfp->buf_size);
      }
      buffer = selfp->buf;
    }
  
    for (total_read = 0; total_read < num_bytes; total_read += nread) {
      nread = xmlNanoHTTPRead(ctx, buffer, num_bytes - total_read);
      if (nread <= 0)
        return NULL;
    }
    return buffer;
  }
  
  override (Gsf:Input) gboolean
  Seek(GsfInput *input, gsf_off_t offset, GSeekType whence)
  {
    return FALSE;
  }
  
}
