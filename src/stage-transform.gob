%h{
  #include "ggobi-stage.h"
  #include "ggobi-transform.h"
%}

%{
  // temporary of course
  #include "vars.h"
  #include "externs.h"
  
  static void
  get_transformed_cols_func(gpointer key, gpointer value, gpointer data)
  {
    gint **array = (gint **)data;
    (*array)[0] = GPOINTER_TO_INT(key);
    (*array)++;
  }
  
  static gchar *
  name_tform_func(const gchar *name, gpointer data)
  {
    GGobiTransform *tform = GGOBI_TRANSFORM(data);
    return(ggobi_transform_variable_name(tform, name));
  }
%}

/* This stage caches every value, even those it does not transform */

class GGobi:Stage:Transform from GGobi:Stage {
  private array_f tform destroy {
    if(&(VAR)) 
      arrayf_free(&(VAR), 0, 0);
  };
  
  private GHashTable *active_tforms = { 
    g_hash_table_new_full(NULL, NULL, NULL, g_object_unref) 
  } destroywith g_hash_table_destroy;
  
  private signal NONE (UINT, OBJECT) void
  applied(self, guint j, GGobiTransform *tform);
  
  override (GGobi:Stage) void
  process_incoming(GGobiStage *self, GGobiPipelineMessage *msg)
  {
    GSList *changed_cols = ggobi_pipeline_message_get_changed_cols(msg);
    GSList *removed_rows = ggobi_pipeline_message_get_removed_rows(msg);
    GSList *removed_cols = ggobi_pipeline_message_get_removed_cols(msg);
    guint n_added_cols = ggobi_pipeline_message_get_n_added_cols(msg);
    guint n_added_rows = ggobi_pipeline_message_get_n_added_rows(msg);
    guint n_refresh = n_added_cols;
    
    PARENT_HANDLER(self, msg);
    
    arrayf_delete_rows (&(SELF(self)->_priv->tform), removed_rows);
    arrayf_add_rows (&(SELF(self)->_priv->tform), self->n_rows);
    arrayf_delete_cols (&(SELF(self)->_priv->tform), removed_cols);
    arrayf_add_cols (&(SELF(self)->_priv->tform), self->n_cols);
    
    // FIXME: Need to update hash table in response to column deletions
    
    if (removed_rows || n_added_rows)
      n_refresh = self->n_cols; /* if rows changed, refresh all transforms */
    else g_slist_foreach(changed_cols, (GFunc)self_changed_col_foreach, self);
    for (guint j = self->n_cols - n_refresh; j < self->n_cols; j++)
      self_transform(SELF(self), 0, j);

    if (self->gg)
      displays_tailpipe (FULL, self->gg);
    
    g_slist_free(removed_cols);
    g_slist_free(removed_rows);
    g_slist_free(changed_cols);
  }
  
  private void
  changed_col_foreach(guint j, GGobiStageTransform *self)
  {
    self_transform(self, 0, j);
  }
  
  public GObject *
  new(GGobiStage *parent)
  {
    GObject *o = G_OBJECT(GET_NEW_VARG("parent", parent, NULL));
    return(o);
  }
  
  public void 
  apply(self, guint j  (check < N_COLS), GGobiTransform *tform)
  {
    GGobiVariable *var = ggobi_stage_get_variable(GGOBI_STAGE(self), j);
    if (!tform) {
      ggobi_variable_set_name_transform_func(var, NULL, NULL);
      g_hash_table_remove(selfp->active_tforms, GINT_TO_POINTER(j));
    } else {
      g_object_ref(G_OBJECT(tform));
      g_signal_connect(G_OBJECT(tform), "notify", 
        G_CALLBACK(self_transform_notify_cb), self);
      ggobi_variable_set_name_transform_func(var, name_tform_func, tform);
      g_hash_table_insert(selfp->active_tforms, GINT_TO_POINTER(j), tform);
    }
    self_transform(self, 0, j);
    ggobi_stage_flush_changes_here(GGOBI_STAGE(self));
    self_applied(self, j, tform);
  }
  public void
  cancel(self, guint j  (check < N_COLS))
  {
    self_apply(self, j, NULL);
  }
  public void
  cancel_all(self)
  {
    guint j, ncols;
    gint *cols = self_get_transformed_cols(self, &ncols);
    for (j = 0; j < ncols; j++)
      self_cancel(self, cols[j]);
  }
  
  /* don't modify this value */
  public GGobiTransform *
  get_transform(self, guint j (check < N_COLS))
  {
    return(g_hash_table_lookup(selfp->active_tforms, GINT_TO_POINTER(j)));
  }
  
  /**
   * get_transformed_cols:
   * @self: #GGobiStageTransform
   * 
   * Some kind of list of the transformed columns?
  **/
  public gint *
  get_transformed_cols(self, guint *ncols)
  {
    gint *cols = g_new(gint, g_hash_table_size(selfp->active_tforms));
    gint *tmp_cols = cols;
    g_hash_table_foreach(selfp->active_tforms, get_transformed_cols_func, &tmp_cols);
    *ncols = self_get_n_transformed_cols(self);
    return(cols);
  }
  
  public guint
  get_n_transformed_cols(self)
  {
    return (g_hash_table_size(selfp->active_tforms));
  }
  
  override (GGobi:Stage) gdouble
  get_raw_value(GGobi:Stage *self (check null type), guint i, guint j)
  {
    return SELF(self)->_priv->tform.vals[i][j];
  }
  
  // FIXME: make set_raw_value return a gboolean to indicate success?
  override (GGobi:Stage) void
  set_raw_value(GGobi:Stage *self (check null type), guint i, guint j, gdouble value)
  {
    GGobiTransform *tform = self_get_transform(SELF(self), j);
    if (tform) {
      GGobiVariable *var = ggobi_stage_get_variable(self->parent, j);
      gdouble *result = ggobi_transform_reverse(tform, &value, 1, var);
      if (result) {
        PARENT_HANDLER(self, i, j, result[0]);
        g_free(result);
      } else self_transform_error(tform, j);
    } else PARENT_HANDLER(self, i, j, value);
  }
  
  private void
  transform(self, guint start, guint j)
  {
    guint i;
    GGobiTransform *tform = self_get_transform(self, j);
    if (!tform) { /* identity transformation */
      for (i = 0; i < GGOBI_STAGE(self)->n_rows; i++)
        selfp->tform.vals[i][j] = 
          ggobi_stage_get_raw_value(GGOBI_STAGE(self)->parent, i, j);
    } else {
      /*GGobiVariable *var = ggobi_stage_get_variable(GGOBI_STAGE(self)->parent, j);*/
      gdouble *result = ggobi_transform_column(tform, GGOBI_STAGE(self)->parent, 
        start, j); 
      if (result) {
        /* the user limits are deprecated, so I am just disabling this for now */
        /*lims *limits = ggobi_transform_limits(tform, var->lim_specified, var);*/
        for (i = start; i < GGOBI_STAGE(self)->n_rows; i++)
          selfp->tform.vals[i][j] = result[i];
        g_free(result);
        /*if (limits) {
          var->lim_specified.min = limits->min;
          var->lim_specified.max = limits->max;
          g_free(limits);
        }*/
      } else self_transform_error(tform, j);
    }
    // FIXME: world stage should take care of this
    tform_to_world_by_var(GGOBI_STAGE(self), j);
    ggobi_stage_col_data_changed(GGOBI_STAGE(self), j);
  }
  
  private void
  transform_error(GGobiTransform *tform, guint j)
  {
     gchar *name = ggobi_transform_get_name(tform);
     g_critical("Data outside the domain of transform %s at col %d.", name, j);
     g_free(name);
  }
  
  /* whenever a property of the transform changes, assume we need to update */
  // FIXME: This may be too aggressive...
  private void
  transform_notify_cb(GGobiTransform *tform, GParamSpec *pspec, GGobiStageTransform *self)
  {
    guint j, ncols;
    gint *cols = self_get_transformed_cols(self, &ncols);
    for (j = 0; j < ncols; j++)
      if (self_get_transform(self, cols[j]) == tform)
        self_transform(self, 0, cols[j]);
    ggobi_stage_flush_changes_here(GGOBI_STAGE(self));
  }
}
