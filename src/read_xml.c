/* read_xml.c */
/*
 * ggobi
 * Copyright (C) AT&T, Duncan Temple Lang, Dianne Cook 1999-2005
 *
 * ggobi is free software; you may use, redistribute, and/or modify it
 * under the terms of the Common Public License, which is distributed
 * with the source code and displayed on the ggobi web site, 
 * www.ggobi.org.  For more information, contact the authors:
 *
 *   Deborah F. Swayne   dfs@research.att.com
 *   Di Cook             dicook@iastate.edu
 *   Duncan Temple Lang  duncan@wald.ucdavis.edu
 *   Andreas Buja        andreas.buja@wharton.upenn.edu
*/

#include <libxml/parserInternals.h>

/*
   This is a SAX based parser for reading a single input file
   formatted in XML for the DTD specified in ggobi.dtd.

   SAX is an event based parser. As different elements of the document
   are encountered by the parser on its input stream, it invokes
   user-specified callbacks. For our purposes, we currently need only
   handle 3 event types:
      1) the start of a tag
      2) the end of a tag  
      3) regular text data within a tag

   As with all event driven approaches, we can specify a user-level
   data object that can is passed to each event handler/callback.
   This is used to parameterize the particular call. In our case,
   we pass an XMLParserData * object (defined in read_xml.h).
   This basically stores what state in the document we currently have
   and indicates how to interpret the future callbacks, and also
   the ggobid structure which we are attempting to fill in.
   Additionally, it maintains a list of default settings that are 
   to be applied to each row, but which can be set generically in the
   top-level element (ggobidata).
  

   When we encounter the start of tag, we are given the tag name, the
   list of attributes for the tag instance and a reference to the
   parser instance XMLParserData object we specified at the start of the
   parsing. This handler is startXMLElement.  Here, we dispatch
   a call to the appropriate method based on the tag name. Generally,
   this either allocates storage space in the ggobid structure being
   filled in, or stores partial information needed to do this.
   Additionally, for the tag ggobidata, the attributes are processed
   to store the default values for record attributes. These are
   attributes such as color, glyph (size and type). 

   As each tag is encountered, we convert its type to an enumerated
   type and store this as the pending state. This is used to determine
   how to interpret ASCII text within an element.

   When we encounter the end of a tag/element,  the routine
   endXMLElement is called. We use this to increment counters indicating
   which record, variable or edge is next in the stream. These are 
   quasi-global variables that are parser-instance specific and a
   necessary consquence of the event-driven style of parsing.

   Finally, when ASCII text within an XML element is discovered by the
   parser, the routine characters() is called. We call different
   routines (setRecordsValues() and setVariableName()) based on the
   state of the parsing. This was set at the start of each tag/element
   in startXMLElement. 
 
 */

#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <gtk/gtk.h>
#include <glib/gprintf.h>

#include "read_xml.h"

#include "externs.h"

#include "GGobiAPI.h"


void setColorScheme (const xmlChar ** attrs, XMLParserData * data);

void startXMLElement (void *user_data, const xmlChar * name,
                      const xmlChar ** attrs);
void endXMLElement (void *user_data, const xmlChar * name);
void Characters (void *user_data, const xmlChar * ch, gint len);
void cumulateRecordData (XMLParserData * data, const xmlChar * ch, gint len);
static gboolean setRecordValue (const char *tmp, GGobiStage * d,
                                XMLParserData * data);
void resetRecordInfo (XMLParserData * data);
static void releaseCurrentDataInfo (XMLParserData * parserData);
static void endVariable (XMLParserData *data);

/*
 The different XML element names we recognize in the input format.

 countervariable is an automatic convenience  variable that generates
 a new variable in the dataset that does not have corresponding entries
 in the input file. For each record, we generate a value which is the
 index in the dataset of that record (starting at 1).

 Along the same lines, we now have randomuniformvariable. This
 is another automatic variable whose values are generated by the
 act of reading the dataset. 
 I am not certain that this belongs here. It is not reproducible.
 It doesn't generalize to different distributions, or even transformations
 of the U(0, 1) distribution. Perhaps having this feature implemented via
 a plugin which uses the new_datad event signal to add variables to a dataset.
 There is a disconnect between what the author of the dataset wants and
 what the plugin knows. So, having this may well be necessary. 
 One can of course use a scripting language (e.g. R, Python, ...) to 
 create the dataset externall.
 
 One can have any number of randomuniformvariable elements in a dataset,
 which is different from the countervariable. This is implemented by 
 introducing a new variable type (like categorical, real, ...)
 in the GGobiVariableType enumeration in ggobi-variable.h. This means that we have
 to update code to handle this element in the switch statements
 and this is error-prone. (We can easily overlook some of the switch statements
 and get odd behavior). We would rather have the  GGobiVariable data structure as
 a class and have methods for it. Switch statements are simply not extensible.
 For this case, we only have to update vartable_nbook.c.

*/
const gchar *const xmlDataTagNames[] = {
  "ggobidata",
  "data",                       /* DATASET */
  "description",
  "record",
  "records",
  "variables",
  "variable",
  "colormap",
  "color",
  /* variables */
  "realvariable",
  "categoricalvariable",
  "integervariable",
  "countervariable",
  "randomuniformvariable",
  "levels",
  "level",
  /* color scheme */
  "activeColorScheme",
  /* brushing attributes: color first; later, glyph type and size */
  "brush",
  /* data values */
  "real",
  "int",
  "string",
  "na",
  "quickHelp",
  "edges",
  "edge",
  ""
};


GSList *
read_xml (InputDescription * desc, ggobid * gg, GGobiPluginInfo * plugin)
{
  return (data_xml_read (desc, gg));
}

InputDescription *
read_xml_input_description (const char *const fileName,
                            const char *const modeName, ggobid * gg,
                            GGobiPluginInfo * info)
{
  InputDescription *desc;
  desc = (InputDescription *) g_malloc0 (sizeof (InputDescription));
  desc->fileName = g_strdup (fileName);
  /*
   * If fileName isn't the name of a readable file, append .xml and
   * try again -- but only if it doesn't already end in .xml.
   */
  if (file_is_readable (desc->fileName) == false) {
    gint len = strlen(desc->fileName);
    if (len-4 > 0 && strcmp(&desc->fileName[len-4], ".xml")) {
      g_free (desc->fileName);
      desc->fileName = g_malloc ((strlen (fileName) + 5) * sizeof (gchar));
      sprintf (desc->fileName, "%s.xml", fileName);
    }
  }

  desc->mode = isURL (fileName) ? url_data : xml_data;
  desc->desc_read_input = &read_xml;

  return (desc);
}



void
ggobi_XML_warning_handler (void *data, const gchar * msg, ...)
{
  va_list ap;
  xmlParserCtxtPtr p = (xmlParserCtxtPtr) ((XMLParserData *) data)->parser;

  va_start (ap, msg);
  g_warning ("XML parsing [%d, %d]: ",
           (int) p->input->line, (int) p->input->col);

  g_vfprintf (stderr, msg, ap);

  fflush (stderr);
}

void
ggobi_XML_error_handler (void *data, const gchar * msg, ...)
{
  va_list ap;
  xmlParserCtxtPtr p = (xmlParserCtxtPtr) ((XMLParserData *) data)->parser;

  g_critical ("XML parsing [line %d, column %d]: ",
           (int) p->input->line, (int) p->input->col);

  va_start (ap, msg);
  g_vfprintf (stderr, msg, ap);

  fflush (stderr);
}


/*
  We also need a version that takes a FILE*
  and reads from it. This is so that we can
  handle reading from standard input.

  The DOM style parsing can be initiated very simply.

  xmlDocPtr doc;
    doc = xmlParseFile(name);
 */



GSList *
data_xml_read (InputDescription * desc, ggobid * gg)
{
  xmlSAXHandlerPtr xmlParserHandler;
  xmlParserCtxtPtr ctx =
    (xmlParserCtxtPtr) g_malloc (sizeof (xmlParserCtxtPtr));
  XMLParserData data;
  gchar *name = g_strdup (desc->fileName);  /* find_xml_file(desc->fileName, NULL, gg); */
  GSList *dlist;

  if (name == NULL)
    return (false);

  xmlParserHandler = (xmlSAXHandlerPtr) g_malloc0 (sizeof (xmlSAXHandler));
  /* Make certain this is initialized so that we don't have any references
     to unwanted routines!
   */

  xmlParserHandler->startElement = startXMLElement;
  xmlParserHandler->endElement = endXMLElement;
  xmlParserHandler->characters = Characters;

  xmlParserHandler->error = ggobi_XML_error_handler;
  xmlParserHandler->warning = ggobi_XML_warning_handler;

  initParserData (&data, xmlParserHandler, gg);

  ctx = xmlCreateFileParserCtxt (name);
  if (ctx == NULL) {
    xml_warning ("File error:", name, "Can't open file ", &data);
    g_free (name);
    return (false);
  }

  ctx->validate = 1;

  ctx->userData = &data;
  data.parser = ctx;
  data.input = desc;
  ctx->sax = xmlParserHandler;
  data.dlist = NULL;

  xmlParseDocument (ctx);

  dlist = ((XMLParserData *) (ctx->userData))->dlist;

  ctx->sax = NULL;
  xmlFreeParserCtxt (ctx);

  g_free (xmlParserHandler);
  g_free (name);

  return (dlist);
}

void
initParserData (XMLParserData * data, xmlSAXHandlerPtr handler, ggobid * gg)
{
  data->gg = gg;
  data->current_record = 0;
  data->current_variable = 0;
  data->current_element = 0;
  data->current_data = NULL;
  data->current_level_value = 0;
  data->current_level_name = NULL;

  data->current_color = 0;
  data->reading_colormap_file_p = false;
  data->state = UNKNOWN;
  data->terminateStrings_p = true;
  data->NA_identifier = NULL;

  data->handlers = handler;
  data->defaults.color = -1;
  data->defaults.glyphType = sessionOptions->info->glyph.type;
  data->defaults.glyphSize = sessionOptions->info->glyph.size;
  data->defaults.edgeWidth = -1;  /*-- this has no home in ggobi --*/
  data->defaults.hidden = false;

  data->recordString = NULL;
  data->recordStringLength = 0;

  data->autoLevels = NULL;

  data->idNamesTable = NULL;
}

void
startXMLElement (void *user_data, const xmlChar * name,
                 const xmlChar ** attrs)
{
  XMLParserData *data = (XMLParserData *) user_data;
  enum xmlDataState type = tagType (name, false);

  switch (type) {
  case COLORSCHEME:
    setColorScheme (attrs, data);
    break;
  case VARIABLES:
    allocVariables (attrs, data);
    break;
  case VARIABLE:
  case REAL_VARIABLE:
  case INTEGER_VARIABLE:
  case CATEGORICAL_VARIABLE:
  case UNIFORM_VARIABLE:
    newVariable (attrs, data, name);
    break;
  case COUNTER_VARIABLE:
    newVariable (attrs, data, name);
    data->counterVariableIndex = data->current_variable;
    break;

  case CATEGORICAL_LEVELS:
    categoricalLevels (attrs, data);
    break;
  case CATEGORICAL_LEVEL:
    setLevelIndex (attrs, data);
    break;

  case RECORDS:
    setDatasetInfo (attrs, data);
    break;
  case TOP:
    setGeneralInfo (attrs, data);
    break;
  case EDGE:
  case RECORD:
    newRecord (attrs, data);
    break;
  case COLORMAP:
    /*setColorMap(attrs, data); *//* requires some thought ... */
    break;
  case BRUSHSTYLE:
    setBrushStyle (attrs, data);
    break;
  case COLOR:
    /*setColormapEntry(attrs, data); *//* ditto .... */
    break;
  case DESCRIPTION:
    /* description text pending */
    break;
  case EDGES:
  case DATASET:
    setDataset (attrs, data, type);
    break;

  case REAL:
  case INTEGER:
  case STRING:
  case NA:
    if (data->recordString) {
      setRecordValues (data, data->recordString, data->recordStringLength);
      if (type != NA && type != STRING)
        data->current_element++;
      resetRecordInfo (data);
    }
    break;
  case QUICK_HELP:
    break;
  default:
    fprintf (stderr, "Unrecognized XML state %s\n", name);
    fflush (stderr);
    break;
  }

  data->state = type;
}

void
setColorScheme (const xmlChar ** attrs, XMLParserData * data)
{
  const gchar *tmp;

  tmp = getAttribute (attrs, "file");
  if (tmp) {
    /* process this file to append its color schemes into the global list. */
    read_colorscheme ((gchar *) tmp, &data->gg->colorSchemes);
  }

  tmp = getAttribute (attrs, "name");
  if (tmp) {
    /* resolve the color scheme by name */

    colorschemed *scheme;
    scheme = findColorSchemeByName (data->gg->colorSchemes, tmp);
    if (scheme) {
      data->gg->activeColorScheme = scheme;
      colorscheme_init (scheme);
    }
    else
      ggobi_XML_error_handler (data,
                               "Invalid colorscheme name %s. No such scheme.\n",
                               tmp);
  }
  else {
    ggobi_XML_error_handler (data, "No colorscheme name specified\n");
  }
}

gint
setLevelIndex (const xmlChar ** attrs, XMLParserData * data)
{
  const gchar *tmp = getAttribute (attrs, "value");
  gint itmp;
  GGobiStage *d = getCurrentXMLData (data);

/*-- dfs: placeholder for proper debugging --*/
  if (data->current_level >= data->current_nlevels) {
    ggobi_XML_warning_handler (data, "adding too many levels to %s\n",
                             ggobi_stage_get_col_name(d, data->current_variable));
  }
/* */

  itmp = data->current_level + 1;
  if (tmp != NULL) {
    itmp = atoi (tmp);
  }
  data->current_level_value = itmp;
  
  return (data->current_level++);
}

void
categoricalLevels (const xmlChar ** attrs, XMLParserData * data)
{
  GGobiStage *d = getCurrentXMLData (data);

  const gchar *tmp = getAttribute (attrs, "count");

  data->current_nlevels = G_MAXINT;
  if (tmp != NULL) {
    data->current_nlevels = atoi (tmp);
    if (data->current_nlevels < 1) {
      ggobi_XML_error_handler (stderr, "Level count for %s mis-specified\n", 
        ggobi_stage_get_col_name(d, data->current_variable));
    }
  }

  data->current_level = 0;
}

void
addLevel (XMLParserData * data, const gchar * c, gint len)
{
  /*
   * This is a kludge, I admit, but if a level name includes special
   * characters (such as &), the string is somehow fed into this
   * routine in pieces.  This section of code glues the separate
   * pieces back together again.  -- dfs
  */
  if (data->current_level_name) {
    gchar *tmp = g_strconcat(data->current_level_name, c, NULL);
    g_free(data->current_level_name);
    data->current_level_name = tmp;
  } else data->current_level_name = g_strdup(c);
}

void
endCategoricalLevel (XMLParserData *data)
{
  GGobiStage *d = getCurrentXMLData (data);
  GGobiVariable *var = ggobi_stage_get_variable(d, data->current_variable);
  ggobi_variable_add_level(var, data->current_level_name, 
    data->current_level_value);
  g_free (data->current_level_name);
  data->current_level_name = NULL;
}

void
resetRecordInfo (XMLParserData * data)
{
  if (data->recordString)
    g_free (data->recordString);

  data->recordString = NULL;
  data->recordStringLength = 0;
}

void
resolveEdgeIds (XMLParserData * parserData)
{

}

void
resolveAllEdgeIds (XMLParserData * parserData)
{

}

gint
edgecompare (const void *val1, const void *val2)
{
  const SortableEndpoints *e1 = (const SortableEndpoints *) val1;
  const SortableEndpoints *e2 = (const SortableEndpoints *) val2;
  gint acomp, bcomp;

  acomp = strcmp (e1->a, e2->a);
  bcomp = strcmp (e1->b, e2->b);

  if (acomp < 0 || (acomp == 0 && bcomp < 0))
    return (-1);
  else if (acomp == 0 && bcomp == 0)
    return (0);
  else
    return (1);
}

void
setEdgePartners (XMLParserData * parserData)
{
  GGobiStage *e = getCurrentXMLData (parserData);
  SortableEndpoints *ep;
  gint i, k, n;
  gboolean dups = false;

  if (!ggobi_stage_get_n_edges(e))
    return;

  n = 2 * ggobi_stage_get_n_edges(e);
  ep = (SortableEndpoints *)
    g_malloc (n * sizeof (SortableEndpoints));

  /*-- Assume that we have no edges from i to i --*/

  /*
   * Before setting partners, check for duplicate edges.  If we find
   * one, bail out -- we don't handle them correctly, and we don't
   * want them around.
   */

  for (i = 0, k = 0; i < ggobi_stage_get_n_edges(e); i++) {
    ep[k].a = g_strdup ((gchar *) ggobi_stage_get_edge_data(e)->sym_endpoints[i].a);
    ep[k].b = g_strdup ((gchar *) ggobi_stage_get_edge_data(e)->sym_endpoints[i].b);
    ep[k].jcase = i;
    k++;
  }
  qsort ((gchar *) ep, ggobi_stage_get_n_edges(e), sizeof (SortableEndpoints), edgecompare);

  for (i = 1; i < ggobi_stage_get_n_edges(e); i++) {
    k = i - 1;
    if (strcmp (ep[i].a, ep[k].a) == 0 && strcmp (ep[i].b, ep[k].b) == 0) {
      g_critical ("Found duplicate edge from %s to %s",
                  (gchar *) ggobi_stage_get_edge_data(e)->sym_endpoints[ep[i].jcase].a,
                  (gchar *) ggobi_stage_get_edge_data(e)->sym_endpoints[ep[i].jcase].b);
      dups = true;
    }
  }
  if (dups)
    g_error ("Duplicate edges found");


  /*-- If there are no dups, add the reverse of each edge and re-sort --*/
  for (i = 0, k = ggobi_stage_get_n_edges(e); i < ggobi_stage_get_n_edges(e); i++) {
    ep[k].a = g_strdup ((gchar *) ggobi_stage_get_edge_data(e)->sym_endpoints[i].b);
    ep[k].b = g_strdup ((gchar *) ggobi_stage_get_edge_data(e)->sym_endpoints[i].a);
    ep[k].jcase = i;
    k++;
  }
  qsort ((gchar *) ep, n, sizeof (SortableEndpoints), edgecompare);


  for (i = 1; i < n; i++) {
    k = i - 1;
    if (strcmp (ep[i].a, ep[k].a) == 0 && strcmp (ep[i].b, ep[k].b) == 0) {
      ggobi_stage_get_edge_data(e)->sym_endpoints[ep[i].jcase].jpartner = ep[k].jcase;
      ggobi_stage_get_edge_data(e)->sym_endpoints[ep[k].jcase].jpartner = ep[i].jcase;
    }
  }

  for (i = 0; i < n; i++) {
    g_free (ep[i].a);
    g_free (ep[i].b);
  }
  g_free (ep);
}


void
endXMLElement (void *user_data, const xmlChar * name)
{
  XMLParserData *data = (XMLParserData *) user_data;
  enum xmlDataState type = tagType (name, true);

  switch (type) {
  case EDGES:
    resolveEdgeIds (data);
  case DATASET:
    {
      GGobiStage *d = getCurrentXMLData (data);

      setEdgePartners (data);
      releaseCurrentDataInfo (data);
      if (data->current_record < d->n_rows) {
        g_error ("There are fewer records than declared for '%s': %d < %d.",
                 d->name, data->current_record, d->n_rows);
      }

      data->dlist = g_slist_append (data->dlist, d);

    }
    break;

  case EDGE:
    if (data->current_element < data->current_data->n_cols) {
      ggobi_XML_error_handler (data, "Not enough elements\n");
    }
    data->current_record++;
    break;
  case RECORD:
    setRecordValues (data, data->recordString, data->recordStringLength);
    data->current_record++;
    resetRecordInfo (data);
    break;
  case NA:
    ggobi_stage_set_missing(getCurrentXMLData(data), data->current_record, data->current_element);
    data->current_element++;
    break;
  case REAL:
  case INTEGER:
  case STRING:
    /* This is the individual setRecordValue(), i.e. with no 's' at the end. */
    setRecordValue ((const char *) data->recordString, data->current_data,
                    data);
    data->current_element++;
    break;
  case VARIABLE:
    endVariable(data);
  case REAL_VARIABLE:
  case CATEGORICAL_VARIABLE:
  case COUNTER_VARIABLE:
  case INTEGER_VARIABLE:
  case UNIFORM_VARIABLE:
    data->current_variable++;
    break;
  case COLOR:
    data->current_color++;
    break;
  case COLORMAP:
    break;
  case CATEGORICAL_LEVELS:
    break;
  case CATEGORICAL_LEVEL:
    endCategoricalLevel (data);
    break;
  case TOP:
    /* resolve all the edges */
    resolveAllEdgeIds (data);
    break;
  default:
    data = NULL;                /* just any code so we can stop. */
    break;
  }

  if (data) {
    resetRecordInfo (data);
    data->state = UNKNOWN;
  }
}


XmlTagType
tagType (const xmlChar * name, gboolean endTag)
{
  gint n = sizeof (xmlDataTagNames) / sizeof (xmlDataTagNames)[0] - 1;
  gint i;
  const gchar *tmp = (const gchar *) name;
  /*
     if(endTag) {
     tmp++;
     }
   */

  for (i = 0; i < n; i++) {
    if (strcmp (tmp, xmlDataTagNames[i]) == 0) {
      return ((enum xmlDataState) i);
    }
  }

  return (UNKNOWN);
}


/*
  Called when data within an element is found by the parser.
  Note that the parser does not have to give us all the data
  in one go (although it usually does). Instead,
  it can make several calls to this routine for the same
  element instances. E.g 
    <text>
      a few words
     and another sentence
    </text>
   may result in two calls - one for each sentence.

   This is important to handle as it means that we must be prepared
   to read values within a record across different calls and remember
   which variable/column we last completed for this record.
   This is the current_element field in XMLParserData. 
   Additionally, if a variable name is split across multiple calls
   we must append subsequent calls to the initial value.
  

   Additionally, new lines and leading and trailing white space 
   are not removed. Hence, we must do this ourselves. We use
   skipWhiteSpace to move to first non-whitespace character in the
   string.

   Also, the text is given to us as a a sequence of bytes rather than
   a non-terminated string. Thus, we are told the number of bytes
   rather than being able to use strlen to compute the length of the
   string.
   If the flag terminateStrings is set in the XMLParserData instance,
   this routine takes care of copying the data into a regularly
   NULL-terminated string so that the routines to which the data
   is passed can work with it more easily.
 */
void
Characters (void *user_data, const xmlChar * ch, gint len)
{
  gchar *tmp = NULL;
  gint dlen = len;
  const xmlChar *c;
  XMLParserData *data = (XMLParserData *) user_data;

  c = (const xmlChar *) skipWhiteSpace (ch, &dlen);
  if (dlen < 1 || c[0] == '\n')
    return;

  if (data->terminateStrings_p) {
    tmp = g_strndup(c, (gsize) dlen);
    c = (const xmlChar *) tmp;
  }

  switch (data->state) {
  case NA:
  case RECORD:
  case REAL:
  case STRING:
  case INTEGER:
  case UNKNOWN:
    /* Now we call
       after gathering the entire string for the record so that we
       don't get bizarre splits such as  "1.3 1.4 1"  followed by ".4..."
     */
    cumulateRecordData (data, c, dlen);
    break;
  case VARIABLE:
  case CATEGORICAL_VARIABLE:
  case REAL_VARIABLE:
  case UNIFORM_VARIABLE:
    setVariableName (data, c, dlen);
    break;
  case COLOR:
    break;
  case CATEGORICAL_LEVEL:
    addLevel (data, (const gchar *) c, dlen);
    break;
  default:
    break;
  }

  if (data->terminateStrings_p) {
    g_free (tmp);
  }
}

const xmlChar *
skipWhiteSpace (const xmlChar * ch, gint * len)
{
  const xmlChar *tmp = ch;
  while (*len >= 0) {
    if (*len == 0 || (tmp[0] != ' ' && tmp[0] != '\t' && tmp[0] != '\n'))
      break;
    tmp++;
    (*len)--;
  }

  return (tmp);
}

void
cumulateRecordData (XMLParserData * data, const xmlChar * ch, gint len)
{
  data->recordString = (xmlChar *) g_realloc (data->recordString,
                                              (len +
                                               data->recordStringLength +
                                               1) * sizeof (xmlChar));
  memcpy (data->recordString + data->recordStringLength, ch,
          len * sizeof (xmlChar));
  data->recordStringLength += len;
  data->recordString[data->recordStringLength] = '\0';

  return;
}



/**
  Called in response to a ggobidata tag which contains
  the different datasets. The count element here is the
  number of datasets to expect.
 */
gboolean
setGeneralInfo (const xmlChar ** attrs, XMLParserData * data)
{
  const gchar *tmp = getAttribute (attrs, "count");

  if (tmp != NULL) {
    data->expectedDatasetCount = atoi (tmp);
  }

  tmp = getAttribute (attrs, "ids");

  return (true);
}


gboolean
setDatasetInfo (const xmlChar ** attrs, XMLParserData * data)
{
  const gchar *tmp = getAttribute (attrs, "count");
  GGobiStage *d = getCurrentXMLData (data);

  if (tmp == NULL) {
    g_error ("No count attribute");
  }

  ggobi_data_add_rows(GGOBI_DATA(d), atoi (tmp));

  GGOBI_DATA(d)->edge.n = 0;

  setDefaultDatasetValues (attrs, data);

  data->current_variable = 0;
  data->current_record = 0;
  data->current_variable = 0;
  data->current_element = 0;

  return (true);
}

gboolean
setDefaultDatasetValues (const xmlChar ** attrs, XMLParserData * data)
{
  const gchar *tmp = getAttribute (attrs, "missingValue");
  if (tmp != NULL) {
    data->NA_identifier = g_strdup (tmp);
  }

  setGlyph (attrs, data, -1);
  setColor (attrs, data, -1);
  setHidden (attrs, data, -1);
  return (true);
}

const gchar *
getAttribute (const xmlChar ** attrs, gchar * name)
{
  const xmlChar **tmp = attrs;
  while (tmp && tmp[0]) {
    if (strcmp (name, (const gchar *) tmp[0]) == 0)
      return ((const gchar *) tmp[1]);
    tmp += 2;
  }

  return (NULL);
}

gboolean
newRecord (const xmlChar ** attrs, XMLParserData * data)
{
  readXMLRecord (attrs, data);

  return (true);
}

gboolean
setHidden (const xmlChar ** attrs, XMLParserData * data, gint i)
{
  const gchar *tmp;
  GGobiStage *d = getCurrentXMLData (data);

  tmp = getAttribute (attrs, "hidden");
  if (tmp) {
    gboolean hidden = asLogical (tmp);

    if (i < 0) {
      data->defaults.hidden = hidden;
    }
    else
      ggobi_stage_set_attr_hidden(d, i, hidden, ATTR_SET_PERSISTENT);
  }

  return (tmp != NULL);
}

gboolean
asLogical (const gchar * sval)
{
  guint i;
  gboolean val = false;
  const gchar *const trues[] = { "T", "true", "True", "1" };
  for (i = 0; i < sizeof (trues) / sizeof (trues[0]); i++) {
    if (strcmp (sval, trues[i]) == 0)
      return (true);
  }

  return (val);
}

gboolean
setColor (const xmlChar ** attrs, XMLParserData * data, gint i)
{
  const gchar *tmp;
  gint value = data->defaults.color;
  GGobiStage *d = getCurrentXMLData (data);
  colorschemed *scheme = data->gg->activeColorScheme;

  tmp = getAttribute (attrs, "color");
  if (tmp) {
    value = atoi (tmp);
  }

  if (value < 0 || value >= scheme->n) {
    if (tmp)
      xml_warning ("color", tmp, "Out of range", data);
  } else {
    if (i < 0)
      data->defaults.color = value;
    else
      ggobi_stage_set_attr_color(d, i, value, ATTR_SET_PERSISTENT);
  }

  return (value != -1);
}

gboolean
setGlyph (const xmlChar ** attrs, XMLParserData * data, gint i)
{
  const gchar *tmp;
  gint size, type;
  GGobiStage *d = getCurrentXMLData (data);

/*
 * glyphSize  0:7
*/
  size = data->defaults.glyphSize;
  tmp = getAttribute (attrs, "glyphSize");
  if (tmp) {
    size = atoi (tmp);
  }

  if (size < 0 || size >= NGLYPHSIZES) {
    if (tmp)
      xml_warning ("glyphSize", tmp, "Out of range", data);
  }
  else {
    if (i < 0)
      data->defaults.glyphSize = size;
  }

/*
 * glyphType  0:6
*/
  type = data->defaults.glyphType;
  tmp = getAttribute (attrs, "glyphType");
  if (tmp) {
    /*
     * make sure this attribute is an integer; if someone puts a
     * string here, like "plus" or "fc", value = 0 and the mistake
     * isn't caught later when value is tested.
     */
    type = mapGlyphName (tmp);
    if (type == UNKNOWN_GLYPH) {
      if (tmp[0] < '0' || tmp[0] > '6') {
        g_error ("%s is an illegal value for glyphType; it must be on [0,6]",
                 tmp);
      }

      type = atoi (tmp);
    }
  }
  if (type < 0 || type >= NGLYPHTYPES) {
    if (tmp)
      xml_warning ("glyphType", tmp, "Out of range", data);
  }
  else {
    if (i < 0)
      data->defaults.glyphType = type;
  }
    
/*
 * glyph:  strings like "plus 3" or "."
*/
  tmp = getAttribute (attrs, "glyph");
  if (tmp != NULL) {
    const gchar *next;
    gint j;
    next = tmp;
    next = strtok ((gchar *) tmp, " ");
    j = 0;
    while (next) {
      if (j == 0) {             /* type */
        type = mapGlyphName (next);
        if (i < 0) {
          data->defaults.glyphType = type;
        }
      }
      else {                    /* size */
        size = atoi (next);
        if (i < 0) {
          if (size >= 0 && size < NGLYPHTYPES) {
            data->defaults.glyphSize = size;
          }
          else {
            xml_warning ("File error:", next, "glyph improperly specified",
                         data);
          }
        }
      }
      j++;
      next = strtok (NULL, " ");
    }
  }

  if (i >= 0)
    ggobi_stage_set_attr_glyph_parts(d, i, type || data->defaults.glyphType, size || data->defaults.glyphSize, ATTR_SET_PERSISTENT);


  return (size != -1 && type != -1);
}


void
xml_warning (const gchar * attribute, const gchar * value, const gchar * msg,
             XMLParserData * data)
{
  ggobi_XML_warning_handler(data, "%s %s: value = %s\n", 
    attribute, msg, value);
}

static void
xml_set_value (GGobiStage* d, XMLParserData* data, gdouble value) {
  guint col = data->var_to_col[data->current_element];
  ggobi_stage_set_raw_value(d, data->current_record, col, value);
}

static void
applyRandomUniforms (GGobiStage * d, XMLParserData * data)
{
  gint j, ncols = ggobi_stage_get_n_cols(d);
  for (j = data->current_element; j < ncols && 
   ggobi_stage_get_col_type(d, j) == GGOBI_VARIABLE_UNIFORM; j++) {
     xml_set_value(d, data, randvalue());
  }
}

static gboolean
setRecordValue (const char *tmp, GGobiStage * d, XMLParserData * data)
{
  gdouble value;

  /* If we have a counter variable in this dataset, check whether the
     cursor is at that. */
  if (data->counterVariableIndex > -1 &&
      data->current_element == data->counterVariableIndex) {
    xml_set_value(d, data, data->current_record + 1);
    data->current_element++;
  }

  /* If reading past the last column or row, stop */
  if (data->current_record >= d->n_rows||
      data->current_element >= d->n_cols) {
    g_printerr ("Row %d (counting from 1) has too many elements\n",
                data->current_record + 1);
    data->current_element = 0;
    return (false);
  }

  applyRandomUniforms (d, data);
  if (!ggobi_stage_get_n_cols(d))
    return (true);

  /*
   * this is a missing value if 
   *  1. the file does not specify a string and this string is either
   *     "na", "NA", or ".", or
   *  2. the file specifies a string for NA and this is that string
   */
  if ((data->NA_identifier == NULL &&
       (strcmp (tmp, "na") == 0 ||
        strcmp (tmp, "NA") == 0 ||
        strcmp (tmp, ".") == 0)) ||
      (data->NA_identifier && strcmp (tmp, data->NA_identifier) == 0)) {
    ggobi_stage_set_missing(d, data->current_record, data->current_element);    
  }  else {
    GGobiVariable *var = ggobi_stage_get_variable(d, data->current_element);
    value = asNumber (tmp);
    if (GGOBI_VARIABLE_IS_CATEGORICAL(var)) {
      if (data->autoLevels && data->autoLevels[data->current_element]) {
        ggobi_stage_set_categorical_value(d, data->current_record, 
          data->current_element, tmp);
      }
      else {
        if (!ggobi_variable_has_level(var, value)) {
          ggobi_XML_warning_handler (data,
            "incorrect level in record %d, variable `%s', dataset `%s' in the XML input file\n",
            (int) data->current_record + 1, ggobi_variable_get_name(var),
            data->current_data->name ? 
              data->current_data->name : "");
        }
        xml_set_value(d, data, value);
      }
    }
    else if (data->state == STRING) {
      ggobi_XML_error_handler (data,
        "<string> element for non categorical variable (%s) in record %d\n",
        ggobi_variable_get_name(var), (int) data->current_record + 1);
      value = 0;
    } else xml_set_value(d, data, value);
  }

  return (true);
}

/*
  Read the values for this record from free-formatted text. The entries
  are white-space delimited. They should not have quotes or anything
  that needs to be escaped.
*/
gboolean
setRecordValues (XMLParserData * data, const xmlChar * line, gint len)
{
  const gchar *tmp;
  GGobiStage *d = getCurrentXMLData (data);

  gint ncols = ggobi_stage_get_n_vars(d);

  if (!line) {
    applyRandomUniforms (d, data);
    return (false);
  }
  tmp = strtok ((gchar *) line, " \t\n");

  while (tmp && (tmp < (gchar *) (line + len))) {
    /*
       g_printerr("current element %d token %s\n", data->current_element,
       tmp);
     */
    if (setRecordValue (tmp, d, data) == false)
      return (false);
    data->current_element++;
    tmp = strtok (NULL, " \t\n");
    /*    printf("%d %d \n",data->current_record,ncols); */
  }
  if (data->current_element < ncols) {
    ggobi_XML_error_handler (data, "Not enough elements\n");
    /*    printf("%d %d \n",data->current_record,data->current_element); */
    /*
       g_printerr ("Record %d has insufficient elements: %d < %d\n",
       data->current_record, data->current_element,
       ggobi_stage_get_n_vars(d));
     */
  }

  //applyRandomUniforms (d, data);
  return (true);
}

/*
  Convert the specified string to a numeric value.
  This is now done in a locale-insensitive way, so all input that uses this
  function needs to use the C locale (ie decimal points are '.')
 */
gdouble
asNumber (const char *sval)
{
  return (g_ascii_strtod (sval, NULL));
}

/*
   Read the declaration of a variable, gathering its information
   from the specified attributes.
   This includes its name, transformation name, etc.

   Called in response to a <variable>, <realvariable> or
   <categoricalvariable> tag.
 */

gboolean
newVariable (const xmlChar ** attrs, XMLParserData * data,
             const xmlChar * tagName)
{
  const gchar *tmp, *tmp1;
  GGobiStage *d = getCurrentXMLData (data);
  GGobiVariable *el;
  
  if (data->current_variable >= ggobi_stage_get_n_vars(d)) {
    ggobi_XML_error_handler
      (data, "More variables (%d) than given in the <variables count='%d'> element for dataset %s\n",
       data->current_variable, ggobi_stage_get_n_vars(d), d->name);
    return (false);
  }

  el = ggobi_stage_get_variable(d, data->current_variable);

  data->variable_transform_name_as_attribute = false;

  tmp = getAttribute (attrs, "name");
  ggobi_variable_set_name(el, (gchar *)tmp);

  tmp = getAttribute (attrs, "nickname");
  if (tmp != NULL) ggobi_variable_set_nickname(el, (gchar *)tmp);


  tmp = getAttribute (attrs, "min");
  tmp1 = getAttribute (attrs, "max");
  if (tmp && tmp1) {
    gdouble mn, mx;
    mn = asNumber (tmp);
    mx = asNumber (tmp1);
    el->lim_specified.min = mn < mx ? mn : mx;
    el->lim_specified.max = mn > mx ? mn : mx;
    /* ? */
    el->lim_specified_tform.min = el->lim_specified.min;
    el->lim_specified_tform.max = el->lim_specified.max;

    if (mn > mx) {
      g_printerr ("Minimum is greater than maximum for variable %s\n",
                  ggobi_variable_get_name(el));
    }
    el->lim_specified_p = true;
  }


  if (strcmp ((const char *) tagName, "categoricalvariable") == 0) {
    ggobi_data_set_col_type(GGOBI_DATA(d), data->current_variable, GGOBI_VARIABLE_CATEGORICAL);

    /* Mark this as being a variable for which we must compute the levels. */
    if ((tmp = getAttribute (attrs, "levels")) && strcmp (tmp, "auto") == 0) {
      if (data->autoLevels == NULL) {
        data->autoLevels = g_new0(gboolean, data->current_data->n_cols);
      }
      data->autoLevels[data->current_variable] = true;
    }
  }
  else if (strcmp ((const char *) tagName, "integervariable") == 0) {
    ggobi_data_set_col_type(GGOBI_DATA(d), data->current_variable, GGOBI_VARIABLE_INTEGER);
  }
  else if (strcmp ((const char *) tagName, "countervariable") == 0) {
    ggobi_data_set_col_type(GGOBI_DATA(d), data->current_variable, GGOBI_VARIABLE_COUNTER);
  }
  else if (strcmp ((const char *) tagName, "randomuniformvariable") == 0) {
    ggobi_data_set_col_type(GGOBI_DATA(d), data->current_variable, GGOBI_VARIABLE_UNIFORM);
  }                             /* real by default */

/* This is now disabled - sorry if people like it
  tmp = getAttribute (attrs, "time");
  if (tmp && (strcmp (tmp, "yes") == 0 || strcmp (tmp, "true") == 0)) {
    el->isTime = true;
  }
*/

  return (true);
}


/*
   Reads the number of variables in the dataset from the attributes
   and allocates space for them in the ggobid structure.
   At this point, we have the number of records and variables
   and can initialize the data areas of the ggobid structure.

    Called in response to a <variables> tag. (Note the plural.)
 */
gboolean
allocVariables (const xmlChar ** attrs, XMLParserData * data)
{
  const gchar *tmp = getAttribute (attrs, "count");
  GGobiStage *d = getCurrentXMLData (data);

  if (tmp == NULL) {
    g_error ("No count for variables attribute\n");
  }

  ggobi_data_add_cols(GGOBI_DATA(d), atoi (tmp));
  ggobi_data_add_attributes(GGOBI_DATA(d));
  data->var_to_col = ggobi_stage_translate_var_to_col(d);
  
  return (true);
}

static void
endVariable (XMLParserData *data)
{
  GGobiStage *d = getCurrentXMLData (data);
  ggobi_stage_set_col_name(d, data->current_element, data->current_name);
  g_free(data->current_name);
  data->current_name = NULL;
}

/*
  Reads the text in name and assigns it as the name of the
  variable currently being read within the 
  <variable> tag. The index for the variable is stored in 
  data->current_variable.

   Called when parsing free-formatted text within a <variable> tag.
 */
gboolean
setVariableName (XMLParserData * data, const xmlChar * name, gint len)
{
  gchar *tmp = g_strndup(name, (gsize) len);
  
  /* Handle the case where we have multiple calls to the characters
     handler for the same variable because the data is split
   */
  if (data->current_name != NULL) {
    /* need to append tmp to the existing value. */
    gchar *name = g_strconcat(data->current_name, tmp, NULL);
    g_free(data->current_name);
    data->current_name = name;
  } else data->current_name = g_strdup(tmp);

  g_free (tmp);

  return (true);
}

/*----------------------------------------------------------------------*/


/*
 Prints the attributes.
 For debugging.
*/
void
showAttributes (const xmlChar ** attrs)
{
  const xmlChar **tmp;
  tmp = attrs;
  while (tmp && tmp[0]) {
    g_printerr ("\t %s=%s\n", tmp[0], tmp[1]);
    tmp += 2;
  }
}

void
freeLevelHashEntry (gpointer key, gpointer value, gpointer data)
{
  g_free (value);
  if (data)
    g_free (key);
}

static void
releaseCurrentDataInfo (XMLParserData * parserData)
{
  if (!parserData->current_data)
    return;

  if (parserData->autoLevels) {
    g_free(parserData->autoLevels);
    parserData->autoLevels = NULL;
  }
}


gboolean
setDataset (const xmlChar ** attrs, XMLParserData * parserData,
            enum xmlDataState type)
{
  GGobiStage *data = GGOBI_STAGE(ggobi_data_new (0, 0));
  const gchar *name, *nickname;

  name = getAttribute (attrs, "name");
  nickname = getAttribute (attrs, "nickname");
  if (!name)
    name = parserData->input->baseName;
  ggobi_stage_set_name(data, (gchar *)name);
  ggobi_data_set_nickname(GGOBI_DATA(data), (gchar *)nickname);

  parserData->current_data = data;
  parserData->counterVariableIndex = -1;

  if (type == EDGES) {
    setDatasetInfo (attrs, parserData);
  }

  return (true);
}


GGobiStage *
getCurrentXMLData (XMLParserData * parserData)
{
  GGobiStage *data = parserData->current_data;
  if (data == NULL) {
    data = GGOBI_STAGE(ggobi_data_new (0, 0));
    parserData->current_data = data;
  }
  if (GGOBI_DATA(data)->input == NULL)
    GGOBI_DATA(data)->input = parserData->input;
  return (data);
}

gboolean
readXMLRecord (const xmlChar ** attrs, XMLParserData * data)
{
  GGobiStage *d = getCurrentXMLData (data);
  const gchar *tmp;
  gint i = data->current_record;

  if (i == d->n_rows) {
    g_error ("There are more records than declared for '%s'; exiting.",
             d->name);
  }

  data->current_element = 0;

  setColor (attrs, data, i);
  setGlyph (attrs, data, i);
  setHidden (attrs, data, i);

/*
 * Probably something's missing here:  if any record has an
 * id, then does every record need one?  I think so.  -- dfs
 */

  tmp = getAttribute (attrs, "id");
  if (tmp) {
    gint m = ggobi_stage_get_row_for_id(d, (gchar*) tmp);
    if (m != -1)
      ggobi_XML_error_handler (data,
        "duplicated id (%s) in records %d and %d of dataset %s\n",
        (gchar *) tmp,
        data->current_record + 1,
        m + 1,
        data->current_data->name);
    ggobi_stage_set_row_id(d, (guint) i, (gchar*) tmp, false);
  }

/*
 * Probably something's missing here:  if edges should be
 * present, then every record should have a source and an
 * endpoint, and there's no validation going on now. --dfs
*/

  /* Read the edge source and destination pair if, present. */
  tmp = getAttribute (attrs, "source");
  if (tmp != (const gchar *) NULL) {
    const gchar *dest;
    dest = getAttribute (attrs, "destination");
    if (!dest) {
      xml_warning ("edge specification error:", tmp,
                   "source but no destination attribute for record.", data);
      return (true);
    }
    if (strcmp (tmp, dest) == 0) {
      xml_warning ("edge specification error:", tmp,
                   "source is the same as destination for record.", data);
      return (true);
    }

    if (ggobi_stage_get_edge_data(d)->sym_endpoints == NULL) {
      GGOBI_DATA(d)->edge.n = d->n_rows;
      GGOBI_DATA(d)->edge.sym_endpoints = (SymbolicEndpoints *)
        g_malloc (sizeof (SymbolicEndpoints) * ggobi_stage_get_n_edges(d));
    }

    ggobi_stage_get_edge_data(d)->sym_endpoints[data->current_record].a = intern (data, tmp);
    ggobi_stage_get_edge_data(d)->sym_endpoints[data->current_record].b = intern (data, dest);
    ggobi_stage_get_edge_data(d)->sym_endpoints[data->current_record].jpartner = -1;
  }

  return (true);
}

gchar *
intern (XMLParserData * data, const char *el)
{
  gchar *ans;

  if (data->idNamesTable == NULL) {
    data->idNamesTable = g_hash_table_new (g_str_hash, g_str_equal);
  }

  ans = g_hash_table_lookup (data->idNamesTable, el);
  if (!ans) {
    ans = g_strdup (el);
    g_hash_table_insert (data->idNamesTable, ans, ans);
  }
  return (ans);
}


gboolean
setBrushStyle (const xmlChar ** attrs, XMLParserData * data)
{
  const gchar *tmp;
  gint value;
  gboolean retval = true;

  tmp = getAttribute (attrs, "color");
  if (tmp != NULL) {
    colorschemed *scheme = data->gg->activeColorScheme;
    value = atoi (tmp);
    if (value >= 0 && value < scheme->n) {
      data->gg->color_id = value;
    }
    else {
      xml_warning ("File error:", tmp, "brushing color improperly specified",
                   data);
      return false;
    }
  }

/*
 * glyphType  0:6
*/
  tmp = getAttribute (attrs, "glyphType");
  if (tmp != NULL) {
    /*
     * make sure this attribute is an integer; if someone puts a
     * string here, like "plus" or "fc", value = 0 and the mistake
     * isn't caught later when value is tested.
     */
    if (tmp[0] < '0' || tmp[0] > '6') {
      xml_warning ("brushing glyphType", tmp, "Must be on [0,6]\n", data);
      return false;
    }
    value = mapGlyphName (tmp);
    if (value == UNKNOWN_GLYPH)
      value = atoi (tmp);

    if (value < 0 || value >= NGLYPHTYPES) {
      xml_warning ("glyphType", tmp, "Out of range", data);
      return false;
    }
    else {
      data->gg->glyph_id.type = value;
    }
  }

/*
 * glyphSize  0:7
*/
  tmp = getAttribute (attrs, "glyphSize");
  if (tmp != NULL) {
    value = atoi (tmp);

    if (value < 0 || value >= NGLYPHSIZES) {
      xml_warning ("glyphSize", tmp, "Out of range", data);
    }
    else {
      data->gg->glyph_id.size = value;
    }
  }


  tmp = getAttribute (attrs, "glyph");
  if (tmp != NULL) {
    const gchar *next;
    gint j;
    next = tmp;
    next = strtok ((gchar *) tmp, " ");
    j = 0;
    while (next) {
      if (j == 0) {             /* type */
        value = mapGlyphName (next);
        data->gg->glyph_id.type = value;
      }
      else {                    /* size */
        value = atoi (next);
        if (value >= 0 && value < NGLYPHTYPES) {
          data->gg->glyph_id.size = value;
        }
        else {
          xml_warning ("File error:", next,
                       "brushing glyph improperly specified", data);
          retval = false;
        }
      }
      j++;
      next = strtok (NULL, " ");
    }
  }

  return retval;
}

/* Routines for walking the hash table and getting all the row labels
   into an array. */

static void
getLabel (gpointer key, gpointer val, gchar ** labels)
{
  if (val) {
    labels[*(guint *) val] = (gchar *) key;
  }
}

gchar **
getRowLabsFromTable (GHashTable * tbl, gchar ** names)
{
  if (!names)
    names = (gchar **) g_malloc (sizeof (gchar *) * g_hash_table_size (tbl));

  g_hash_table_foreach (tbl, (GHFunc) getLabel, names);

  return (names);
}

gboolean
isXMLFile (const gchar * fileName, ggobid * gg, GGobiPluginInfo * info)
{

  FILE *f;
  gint c;
  gchar *tmp;

  if (isURL (fileName))
    return (true);


  tmp = strrchr (fileName, '.');

  if (!tmp) {
    gchar buf[256];
    sprintf (buf, "%s.xml", fileName);
    if (isXMLFile (buf, gg, info))
      return (true);
  }

  if (tmp && (strcmp (tmp, ".xmlz") == 0 || strcmp (tmp, ".gz") == 0)) {
    /* desc->canVerify = false; */
    return (true);
  }


  f = fopen (fileName, "r");
  if (f == NULL)
    return (false);

/*  desc->canVerify = true; */
  while ((c = getc (f)) != EOF) {
    if (c == ' ' || c == '\t' || c == '\n')
      continue;
    if (c == '<') {
      gchar buf[10];
      fgets (buf, 5, f);
      fclose (f);
      if (strcmp (buf, "?xml") == 0) {
        return (true);
      }
      else
        return (false);
    }
  }

  return (false);
}
