%privateheader{
  #include "ggobi-bitset.h"
%}
%h{
  #include "utils.h"
%}
/* Describes changes in the pipeline data matrix. It communicates five different
   types of changes:
   
   1) Remove columns
   2) Remov rows
   3) Change data (indexed by column)
   4) Add columns
   5) Add rows

   Note that insertion is not supported; all addition occur at the ends of the
   matrix. Also there is no event for row changes, because it is redundant with
   column changes, which occur more often and are more efficiently handled by
   embedding environments, since there are usually less columns than rows.

   These changes obviously conflict with each other, so the order in which they
   are considered is important. Changes occur in the following order: deletion,
   update, addition. The reasoning for this is thus: it is wasteful to add or
   change elements that will soon be deleted and we also want to avoid changing
   elements that are still to be added.

   In the case of columns, this means that the indices of the changed columns
   take into account any removals. It also means that it is not possible to
   remove or change indices that have been appended, since appending takes
   place after removal and changing.

   When a message is received, usually from the parent staage, its indexing 
   should be compatible with that of the receiver. Some pipeline stages, 
   specifically filters, change the indexing by removing rows and/or columns. 
   It is the responsibility of those stages to use the filter_rows() and
   filter_cols() convenience methods to modify the indexing by providing the
   indices of the hidden rows and columns, respectively. Filtering blocks
   all types of events: removals, changes, and additions.
   
   Some stages, which are extensions of filters, essentially replace the data
   matrix by column (like in tours) or row or both (like generating a dataset
   describing the variables, ie an experimental design matrix). In the first
   two cases, it may be simpler to allow resetting the message by row or
   column. This means clearing out all previous events and resetting the
   initial dimension. This is achieved by the reset_*() functions. 
   Redefining both rows and columns warrants the generation of a new message.
*/
class GGobi:Pipeline:Message from G:Object {
  /* The GGobiBitset is used essentially as a fast set of indices */
  private GGobiBitset *changed_cols = { ggobi_bitset_new() } 
    unrefwith g_object_unref;
  private GGobiBitset *removed_cols = { ggobi_bitset_new() } 
    unrefwith g_object_unref;
  private GGobiBitset *removed_rows = { ggobi_bitset_new() } 
    unrefwith g_object_unref;
  
  /* since we only append (but not insert) rows/cols, the counts are enough */
  private guint n_added_rows;
  private guint n_added_cols;
  
  /* used to identify whether a row/col index has been appended */
  private guint n_cols;
  private guint n_rows;
  
  /* n_cols and n_rows are now writeable properties, because it is convenient
     to change them when redefining the matrix in terms of rows or cols (tours).
  */
  property UINT n_cols
  (nick = "cols", blurb = "The number of columns that are indexed, not appended",
    minimum = 0, maximum = G_MAXUINT, default_value = 0, export)
    set {
      selfp->n_cols = g_value_get_uint(VAL);
      ggobi_bitset_set_size(selfp->changed_cols, selfp->n_cols);
      ggobi_bitset_set_size(selfp->removed_cols, selfp->n_cols);
    } get {
      g_value_set_uint(VAL, selfp->n_cols);
    };
  property UINT n_rows
  (nick = "rows", blurb = "The number of rows that are indexed, not appended",
    minimum = 0, maximum = G_MAXUINT, default_value = 0, export)
    set {
      selfp->n_rows = g_value_get_uint(VAL);
      ggobi_bitset_set_size(selfp->removed_rows, selfp->n_rows);
    } get {
      g_value_set_uint(VAL, selfp->n_rows);
    };
  
  /**
   * new:
   * @nrows: the number of indexed rows
   * @ncols: the number of indexed columns
   *
   * Creates a new message describing changes to a matrix that was originally
   * of dimensions @nrows by @ncols.
   *
   * Returns: a new #GGobiPipelineMessage with the given dimensions
   */
  public GGobiPipelineMessage *
  new(guint nrows, guint ncols)
  {
    GObject *obj = (GObject *)GET_NEW_VARG("n_rows", nrows, "n_cols", ncols, NULL);
    return GGOBI_PIPELINE_MESSAGE(obj);
  }
  
  /**
   * get_changed_cols:
   * @self: a #GGobiPipelineMessage
   *
   * Lists the indices of the changed columns.
   *
   * Returns: #GSList of integers
   */
  public GSList *
  get_changed_cols(self)
  {
    return ggobi_bitset_get_indices(selfp->changed_cols);
  }
  /**
   * get_removed_cols:
   * @self: a #GGobiPipelineMessage
   *
   * Lists the indices of the removed columns
   *
   * Returns: #GSList of integers
   */
  public GSList *
  get_removed_cols(self)
  {
    return ggobi_bitset_get_indices(selfp->removed_cols);
  }
  
  /**
   * get_removed_rows:
   * @self: a #GGobiPipelineMessage
   *
   * Lists the indices of the removed rows.
   *
   * Returns: #GSList of integers
   */
  public GSList *
  get_removed_rows(self)
  {
    return ggobi_bitset_get_indices(selfp->removed_rows);
  }
  
  /* maybe it would be better to also give ranges here just for convenience? */
  
  /**
   * get_n_added_cols:
   * @self: a #GGobiPipelineMessage
   *
   *
   * Returns: the number of added columns.
   */
  public guint
  get_n_added_cols(self)
  {
    return selfp->n_added_cols;
  }
  /**
   * get_n_added_rows:
   * @self: a #GGobiPipelineMessage
   *
   *
   *
   * Returns: the number of added rows
   */
  public guint
  get_n_added_rows(self)
  {
    return selfp->n_added_rows;
  }
  
  /**
   * get_n_removed_rows:
   * @self: a #GGobiPipelineMessage
   *
   *
   * Returns: the number of removed rows
   */
  public guint
  get_n_removed_rows(self)
  {
    return ggobi_bitset_get_n_indices(selfp->removed_rows);
  }
  /**
   * get_n_changed_cols:
   * @self: a #GGobiPipelineMessage
   *
   *
   *
   * Returns: the number of changed columns
   */
  public guint
  get_n_changed_cols(self)
  {
    return ggobi_bitset_get_n_indices(selfp->changed_cols);
  }
  /**
   * get_n_removed_cols:
   * @self: a #GGobiPipelineMessage
   *
   *
   *
   * Returns: the number of removed columns
   */
  public guint
  get_n_removed_cols(self)
  {
    return ggobi_bitset_get_n_indices(selfp->removed_cols);
  }
  
  /* convenience functions for iterating over changes */
  
  /**
   * changed_cols_foreach:
   * @self: a #GGobiPipelineMessage
   * @func: function to apply to the increasing indices of the changed columns
   * @data: user data for the function
   *
   *
   *
   */
  public void
  changed_cols_foreach(self, GGobiIndexFunc func, gpointer data)
  {
    ggobi_bitset_foreach(selfp->changed_cols, func, data);
  }
  /**
   * removed_cols_foreach:
   * @self: a #GGobiPipelineMessage
   * @func: function to apply to the increasing indices of the removed columns
   * @data: user data for the function
   *
   *
   *
   */
  public void
  removed_cols_foreach(self, GGobiIndexFunc func, gpointer data)
  {
    ggobi_bitset_foreach(selfp->removed_cols, func, data);
  }
  /**
   * removed_cols_foreach_decreasing:
   * @self: a #GGobiPipelineMessage
   * @func: function to apply to the decreasing indices of removed columns
   * @data: user data for the function
   *
   * This is useful when shrinking another data structure.
   *
   */
  public void
  removed_cols_foreach_decreasing(self, GGobiIndexFunc func, gpointer data)
  {
    ggobi_bitset_foreach_decreasing(selfp->removed_cols, func, data);
  }
  /**
   * removed_rows_foreach:
   * @self: a #GGobiPipelineMessage
   * @func: function to apply to the increasing indices of removed rows
   * @data: user data for the function
   *
   *
   *
   */
  public void
  removed_rows_foreach(self, GGobiIndexFunc func, gpointer data)
  {
    ggobi_bitset_foreach(selfp->removed_rows, func, data);
  }
  /**
   * removed_rows_foreach_decreasing:
   * @self: a #GGobiPipelineMessage
   * @func: function to apply to the increasing indices of removed rows
   * @data: user data for the function
   *
   *
   *
   */
  public void
  removed_rows_foreach_decreasing(self, GGobiIndexFunc func, gpointer data)
  {
    ggobi_bitset_foreach_decreasing(selfp->removed_rows, func, data);
  }
  /**
   * added_rows_foreach:
   * @self: a #GGobiPipelineMessage
   * @func: function to apply to the increasing indices of added rows
   * @data: user data for the function
   *
   *
   *
   */
  public void
  added_rows_foreach(self, GGobiIndexFunc func, gpointer data)
  {
    for (guint j = selfp->n_rows; j < selfp->n_rows + selfp->n_added_rows; j++)
      func(j, data);
  }
  /**
   * added_cols_foreach:
   * @self: a #GGobiPipelineMessage
   * @func: function to apply to the increasing indices of added columns
   * @data: user data for the function
   *
   *
   *
   */
  public void
  added_cols_foreach(self, GGobiIndexFunc func, gpointer data)
  {
    for (guint j = selfp->n_cols; j < selfp->n_cols + selfp->n_added_cols; j++)
      func(j, data);
  }
  
  /**
   * change_col:
   * @self: a #GGobiPipelineMessage
   * @j: index of the column that changed
   *
   * Registers a change to a specified column. If the column is in the appended
   * set, this has no effect.
   * Note: unlike the events that change the dimensions, this one takes
   * a single element, not a list
   *
   */
  public void
  change_col(self, guint j)
  {
    g_return_if_fail(j < selfp->n_cols + selfp->n_added_cols);
    if (j < selfp->n_cols)
      ggobi_bitset_set(selfp->changed_cols, j);
  }
  
  /**
   * change_cols:
   * @self: a #GGobiPipelineMessage
   * @cols: list of integer indices for changed columns
   *
   * Registers a change to a list of columns. 
   *
   */
  public void
  change_cols(self, GSList *cols)
  {
    for (; cols; cols = cols->next)
      self_change_col(self, GPOINTER_TO_INT(cols->data));
  }
  
  /**
   * remove_cols:
   * @self: a #GGobiPipelineMessage
   * @cols: list of integer indices for removed columns
   *
   * Registers the removal of a list of a columns. Indices of changed columns
   * are automatically shifted, because they are assumed to occur after removal.
   *
   */
  public void
  remove_cols(self, GSList *cols)
  {
    /* ensure sorted for index updating */
    GSList *sorted_cols = g_slist_sort(g_slist_copy(cols), index_compare);
    for (; cols; cols = cols->next) {
      guint index = GPOINTER_TO_INT(cols->data);
      /* add this index to the set */
      g_return_if_fail(index < selfp->n_cols + selfp->n_added_cols);
      if (index < selfp->n_cols)
        ggobi_bitset_set(selfp->removed_cols, index);
    }
    ggobi_bitset_remove_indices(selfp->changed_cols, sorted_cols);
    g_slist_free(sorted_cols);
  }

  /**
   * remove_rows:
   * @self: a #GGobiPipelineMessage
   * @rows: list of integer indices of removed rows
   *
   * Registers the removal of a list of rows.
   *
   */
  public void
  remove_rows(self, GSList *rows)
  {
    for (; rows; rows = rows->next) {
      guint index = GPOINTER_TO_INT(rows->data);
      /* add this index to the set */
      g_return_if_fail(index < selfp->n_rows + selfp->n_added_rows);
      if (index < selfp->n_rows)
        ggobi_bitset_set(selfp->removed_rows, index);
    }
  }
  
  /* easy ones */
  
  /**
   * add_cols:
   * @self: a #GGobiPipelineMessage
   * @n: the number of columns added
   *
   * Registers the appending of @n columns.
   *
   */
  public void
  add_cols(self, guint n)
  {
    selfp->n_added_cols += n;
  }
  /**
   * add_rows:
   * @self: a #GGobiPipelineMessage
   * @n: the number of rows added
   *
   * Registers the appending of @n rows.
   *
   */
  public void
  add_rows(self, guint n)
  {
    selfp->n_added_rows += n;
  }
  
  /* filtering */
  
  /* filter changed_cols and removed_cols */
  
  /**
   * filter_cols:
   * @self: a #GGobiPipelineMessage
   * @cols: the columns that are filtered out
   *
   * This adjusts the message as if the given columns in the original matrix
   * never existed. The indices of changed columns and removed columns are
   * shifted accordingly. This is useful when passing a message through
   * a filter of the data matrix.
   *
   */
  public void
  filter_cols(self, GSList *cols)
  {
    GSList *sorted_cols = g_slist_sort(g_slist_copy(cols), index_compare);
    guint n_cols = selfp->n_cols;
    for (; cols; cols = cols->next)
      if (GPOINTER_TO_INT(cols->data) >= selfp->n_cols)
        selfp->n_added_cols--;
      else n_cols--;
    self_set_n_cols(self, n_cols);
    ggobi_bitset_remove_indices(selfp->changed_cols, sorted_cols);
    ggobi_bitset_remove_indices(selfp->removed_cols, sorted_cols);
    g_slist_free(sorted_cols);
  }
  /**
   * filter_rows:
   * @self: a #GGobiPipelineMessage
   * @rows: the rows that are filtered out
   *
   * This adjusts the message as if the given rows in the original matrix
   * never existed. The indices of removed rows are
   * shifted accordingly. This is useful when passing a message through
   * a filter of the data matrix.
   *
   */
  public void
  filter_rows(self, GSList *rows)
  {
    guint n_rows = selfp->n_rows;
    GSList *sorted_rows = g_slist_sort(g_slist_copy(rows), index_compare);
    for (; rows; rows = rows->next)
      if (GPOINTER_TO_INT(rows->data) >= selfp->n_rows)
        selfp->n_added_rows--;
      else n_rows--;
    self_set_n_rows(self, n_rows);
    ggobi_bitset_remove_indices(selfp->removed_rows, sorted_rows);
    g_slist_free(sorted_rows);
    g_signal_emit_by_name(self, "notify::last_row");
  }
  
  /* consuming events */
  
  /**
   * consume_rows:
   * @self: a #GGobiPipelineMessage
   *
   * Erases all row events. This is usually followed by registration of new row
   * events on different (sorted, shifted, etc) indices. 
   * Useful when the rows of the data matrix are completely rearranged.
   *
   */
  public void
  consume_rows(self)
  {
    ggobi_bitset_clear(selfp->removed_rows);
    selfp->n_added_rows = 0;
  }
  /**
   * consume_cols:
   * @self: a #GGobiPipelineMessage
   *
   * Erases all columns events. This is usually followed by registration of new column
   * events on different (sorted, shifted, etc) indices. 
   * Useful when the columns of the data matrix are completely rearranged.
   *
   */
  public void
  consume_cols(self)
  {
    ggobi_bitset_clear(selfp->removed_cols);
    ggobi_bitset_clear(selfp->changed_cols);
    selfp->n_added_cols = 0;
  }
  
  /* merging messages */
  
  /**
   * merge:
   * @self: a #GGobiPipelineMessage
   * @other: the pipeline message to merge
   *
   * Translates the events in @other into this message. @other is 
   * assumed to contain changes that occurred AFTER the changes in this message.
   * This is important when removal events have occurred in this message.
   *
   */
  public void
  merge(self, GGobiPipelineMessage *other)
  {
    guint over;
    GSList *elements, *elements_shifted;
    
    elements_shifted = self_shift_indices(selfp->removed_rows, 
      other->_priv->removed_rows, &over);
    self_remove_rows(self, elements_shifted);
    selfp->n_added_rows -= over;
    g_slist_free(elements_shifted);
    
    elements_shifted = self_shift_indices(selfp->removed_cols, 
      other->_priv->removed_cols, &over);
    self_remove_cols(self, elements_shifted);
    selfp->n_added_cols -= over;
    g_slist_free(elements_shifted);
    
    elements = self_get_changed_cols(other);
    self_change_cols(self, elements);
    g_slist_free(elements);
    
    self_add_rows(self, self_get_n_added_rows(other));
    self_add_cols(self, self_get_n_added_cols(other));
  }
  
  /* utilities */
  
  private GSList *
  shift_indices(GGobiBitset *first, GGobiBitset *second, guint *over)
  {
    GSList *first_ind = ggobi_bitset_get_indices(first), *shifted, *ind;
    guint my_size = ggobi_bitset_get_size(first);
    second = ggobi_bitset_clone(second);
    ggobi_bitset_set_size(second, my_size);
    ggobi_bitset_insert_indices(second, first_ind);
    shifted = ggobi_bitset_get_indices(second);
    g_object_unref(G_OBJECT(second));
    *over = 0;
    for (ind = first_ind; ind; ind = ind->next)
      if (GPOINTER_TO_INT(ind->data) >= my_size)
        (*over)++;
    g_slist_free(first_ind);
    return shifted;
  }
}
