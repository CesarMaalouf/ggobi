%h{
  typedef void (*GGobiIndexFunc)(guint j, gpointer user_data);
%}
/* Describes changes in the pipeline data matrix. It communicates five different
   types of changes:
   
   1) Remove columns
   2) Remov rows
   3) Change data (indexed by column)
   4) Add columns
   5) Add rows

   Note that insertion is not supported; all addition occur at the ends of the
   matrix. Also there is no event for row changes, because it is redundant with
   column changes, which occur more often and are more efficiently handled by
   embedding environments, since there are usually less columns than rows.

   These changes obviously conflict with each other, so the order in which they
   are considered is important. Changes occur in the following order: deletion,
   update, addition. The reasoning for this is thus: it is wasteful to add or
   change elements that will soon be deleted and we also want to avoid changing
   elements that are still to be added.

   In the case of columns, this means that the indices of the changed columns
   take into account any removals. It also means that it is not possible to
   remove or change indices that have been appended, since appending takes
   place after removal and changing.

   HW: will this work in general for merging messages? eg. when merging two
   messages, the first which creates a column, and the seconding deleting it
   
   ML: the indices in the newer message will be relative to the changes made
   by the previous message. this means that the added elements in the first
   could be deleted in the second. internally this may work in the same way
   that filter stages prevent additions that don't pass (by using filter_*()).

   When a message is received, usually from the parent staage, its indexing 
   should be compatible with that of the receiver. Some pipeline stages, 
   specifically filters, change the indexing by removing rows and/or columns. 
   It is the responsibility of those stages to use the filter_rows() and
   filter_cols() convenience methods to modify the indexing by providing the
   indices of the hidden rows and columns, respectively. Filtering blocks
   all types of events: removals, changes, and additions.
   
   Some stages, which are extensions of filters, essentially replace the data
   matrix by column (like in tours) or row or both (like generating a dataset
   describing the variables, ie an experimental design matrix). In the first
   two cases, it may be simpler to allow resetting the message by row or
   column. This means clearing out all previous events and resetting the
   initial dimension. This is achieved by the reset_*() functions. 
   Redefining both rows and columns warrants the generation of a new message.
   
   HW: So filter stages will modify the event and then pass it on?
   
   ML: That's correct - all stages will potentially modify the event, but 
   filter stages (ie anything that deletes elements) are special in that they 
   modify the indexing. Were you thinking that each stage would produce its
   own messages and then merge those with a message in the queue? That would 
   probably work. I was imagining a system where the current event emission
   functions (like col_data_changed(), cols_added(), etc) are kept, but instead
   of emitting events they make changes to the current message. This could be
   a message received from the parent stage, or, if there isn't one of those,
   a new message could be created. In order to dispatch the message, someone
   (likely the handler that received the original message or the idle callback
   in the case of a tour) would need to call a "flush" method. I see message 
   merging as occurring in some sort of buffering situation, though the same
   code is used whether the message is directly modified or modified by
   another message.
*/
class GGobi:Pipeline:Message from G:Object {
  /* The GByteArray is used essentially as a fast hash-set for indices */
  private GByteArray *changed_cols = { g_byte_array_new() } destroy { 
    if (VAR) g_byte_array_free(VAR, TRUE);
  };
  private GByteArray *removed_cols = { g_byte_array_new() } destroy { 
    if (VAR) g_byte_array_free(VAR, TRUE);
  };
  private GByteArray *removed_rows = { g_byte_array_new() } destroy { 
    if (VAR) g_byte_array_free(VAR, TRUE);
  };
  
  /* since we only append (but not insert) rows/cols, the counts are enough */
  private guint n_added_rows;
  private guint n_added_cols;
  
  /* used to identify whether a row/col index has been appended */
  private guint n_cols;
  private guint n_rows;
  
  /* n_cols and n_rows are now writeable properties, because it is convenient
     to change them when redefining the matrix in terms of rows or cols (tours).
  */
  property UINT n_cols
  (nick = "cols", blurb = "The number of columns that are indexed, not appended",
    minimum = 0, maximum = G_MAXUINT, default_value = 0, export)
    set {
      selfp->n_cols = g_value_get_uint(VAL);
      g_byte_array_set_size(selfp->changed_cols, selfp->n_cols);
      self_byte_array_clear_indices(selfp->changed_cols);
      g_byte_array_set_size(selfp->removed_cols, selfp->n_cols);
      self_byte_array_clear_indices(selfp->removed_cols);
    } get {
      g_value_set_uint(VAL, selfp->n_cols);
    };
  property UINT n_rows
  (nick = "rows", blurb = "The number of rows that are indexed, not appended",
    minimum = 0, maximum = G_MAXUINT, default_value = 0, export)
    set {
      selfp->n_rows = g_value_get_uint(VAL);
      g_byte_array_set_size(selfp->removed_rows, selfp->n_rows);
      self_byte_array_clear_indices(selfp->removed_rows);
    } get {
      g_value_set_uint(VAL, selfp->n_rows);
    };
  
  public GGobiPipelineMessage *
  new(guint nrows, guint ncols)
  {
    GObject *obj = (GObject *)GET_NEW_VARG("n_rows", nrows, "n_cols", ncols, NULL);
    return GGOBI_PIPELINE_MESSAGE(obj);
  }
  
  public GSList *
  get_changed_cols(self)
  {
    return self_byte_array_to_indices(selfp->changed_cols);
  }
  public GSList *
  get_removed_cols(self)
  {
    return self_byte_array_to_indices(selfp->removed_cols);
  }
  public GSList *
  get_removed_rows(self)
  {
    return self_byte_array_to_indices(selfp->removed_rows);
  }
  
  /* maybe it would be better to also give ranges here just for convenience? */
  
  public guint
  get_n_added_cols(self)
  {
    return selfp->n_added_cols;
  }
  public guint
  get_n_added_rows(self)
  {
    return selfp->n_added_rows;
  }
  
  public guint
  get_n_removed_rows(self)
  {
    return self_byte_array_get_n_indices(selfp->removed_rows);
  }
  public guint
  get_n_changed_cols(self)
  {
    return self_byte_array_get_n_indices(selfp->changed_cols);
  }
  public guint
  get_n_removed_cols(self)
  {
    return self_byte_array_get_n_indices(selfp->removed_cols);
  }
  
  /* convenience functions for iterating over changes */
  
  public void
  changed_cols_foreach(self, GGobiIndexFunc func, gpointer data)
  {
    self_byte_array_foreach(selfp->changed_cols, func, data);
  }
  public void
  removed_cols_foreach(self, GGobiIndexFunc func, gpointer data)
  {
    self_byte_array_foreach(selfp->removed_cols, func, data);
  }
  public void
  removed_rows_foreach(self, GGobiIndexFunc func, gpointer data)
  {
    self_byte_array_foreach(selfp->removed_rows, func, data);
  }
  public void
  added_rows_foreach(self, GGobiIndexFunc func, gpointer data)
  {
    for (guint j = selfp->n_rows; j < selfp->n_rows + selfp->n_added_rows; j++)
      func(j, data);
  }
  public void
  added_cols_foreach(self, GGobiIndexFunc func, gpointer data)
  {
    for (guint j = selfp->n_cols; j < selfp->n_cols + selfp->n_added_cols; j++)
      func(j, data);
  }
  
  /* accept only column changes that are not part of the appended set */
  /* (no one cares that a column has changed if it's new to them) */
  /* note: unlike the events that change the dimensions, this one takes
     a single element, not a list */
  public void
  change_col(self, guint j)
  {
    g_return_if_fail(j < selfp->n_cols + selfp->n_added_cols);
    if (j < selfp->n_cols)
      selfp->changed_cols->data[j] = 1;
  }
  
  public void
  change_cols(self, GSList *cols)
  {
    for (; cols; cols = cols->next)
      self_change_col(self, GPOINTER_TO_INT(cols->data));
  }
  
  /* Must update column change indices
  */
  public void
  remove_cols(self, GSList *cols)
  {
    /* ensure sorted for index updating */
    GSList *sorted_cols = g_slist_sort(cols, self_index_compare);
    for (; cols; cols = cols->next) {
      guint index = GPOINTER_TO_INT(cols->data);
      /* add this index to the set */
      g_return_if_fail(index < selfp->n_cols + selfp->n_added_cols);
      if (index < selfp->n_cols)
        selfp->removed_cols->data[index] = 1;
    }
    self_byte_array_remove_indices(selfp->changed_cols, sorted_cols);
    g_slist_free(sorted_cols);
  }

  public void
  remove_rows(self, GSList *rows)
  {
    for (; rows; rows = rows->next) {
      guint index = GPOINTER_TO_INT(rows->data);
      /* add this index to the set */
      g_return_if_fail(index < selfp->n_rows);
      selfp->removed_rows->data[index] = 1;
    }
  }
  
  /* easy ones */
  
  public void
  add_cols(self, guint n)
  {
    selfp->n_added_cols += n;
  }
  public void
  add_rows(self, guint n)
  {
    selfp->n_added_rows += n;
  }
  
  /* filtering */
  
  /* filter changed_cols and removed_cols */
  public void
  filter_cols(self, GSList *cols)
  {
    GSList *sorted_cols = g_slist_sort(cols, self_index_compare);
    guint n_cols = selfp->n_cols;
    for (; cols; cols = cols->next)
      if (GPOINTER_TO_INT(cols->data) >= selfp->n_cols)
        selfp->n_added_cols--;
      else n_cols--;
    self_set_n_cols(self, n_cols);
    self_byte_array_remove_indices(selfp->changed_cols, sorted_cols);
    self_byte_array_remove_indices(selfp->removed_cols, sorted_cols);
    g_slist_free(sorted_cols);
  }
  /* filter removed_rows */
  public void
  filter_rows(self, GSList *rows)
  {
    guint n_rows = selfp->n_rows;
    GSList *sorted_rows = g_slist_sort(rows, self_index_compare);
    for (; rows; rows = rows->next)
      if (GPOINTER_TO_INT(rows->data) >= selfp->n_rows)
        selfp->n_added_rows--;
      else n_rows--;
    self_set_n_rows(self, n_rows);
    self_byte_array_remove_indices(selfp->removed_rows, sorted_rows);
    g_slist_free(sorted_rows);
    g_signal_emit_by_name(self, "notify::last_row");
  }
  
  /* consuming events */
  
  public void
  consume_rows(self)
  {
    self_byte_array_clear_indices(selfp->removed_rows);
    selfp->n_added_rows = 0;
  }
  public void
  consume_cols(self)
  {
    self_byte_array_clear_indices(selfp->removed_cols);
    self_byte_array_clear_indices(selfp->changed_cols);
    selfp->n_added_cols = 0;
  }
  
  /* merging messages */
  
  /* The 'other' message is assumed to contain changes that occurred AFTER
     the changes in 'self' */
  public void
  merge(self, GGobiPipelineMessage *other)
  {
    guint over;
    GSList *elements, *elements_shifted;
    
    elements = self_get_removed_rows(other);
    elements_shifted = self_shift_indices(elements, selfp->removed_rows, &over);
    self_remove_rows(self, elements_shifted);
    selfp->n_added_rows -= over;
    g_slist_free(elements);
    g_slist_free(elements_shifted);
    
    elements = self_get_removed_cols(other);
    elements_shifted = self_shift_indices(elements, selfp->removed_cols, &over);
    self_remove_cols(self, elements_shifted);
    selfp->n_added_cols -= over;
    g_slist_free(elements);
    g_slist_free(elements_shifted);
    
    elements = self_get_changed_cols(other);
    self_change_cols(self, elements);
    g_slist_free(elements);
    
    self_add_rows(self, self_get_n_added_rows(other));
    self_add_cols(self, self_get_n_added_cols(other));
  }
  
  /* utilities */
  // FIXME: This will soon become a separate bitset module.
  private void
  byte_array_remove_indices(GByteArray *array, GSList *indices)
  {
    guint i = indices ? GPOINTER_TO_INT(indices->data) : 0, dec = 0;
    for (; indices; indices = indices->next) {
      guint index = GPOINTER_TO_INT(indices->data);
      /* shift indices */
      while(i < index) {
        array->data[i - dec] = array->data[i];
        i++;
      }
      /* remove col-changed index, if present */
      array->data[i] = 0;
      dec++;
    }
  }
  private void
  byte_array_clear_indices(GByteArray *array)
  {
    guint i;
    // or g_byte_array_remove_range(array, 0, array->len)?
    for (i = 0; i < array->len; i++)
      array->data[i] = 0;
  }
  
  private GSList *
  byte_array_to_indices(GByteArray *array)
  {
    guint i;
    GSList *indices = NULL;
    for (i = 0; i < array->len; i++)
      if (array->data[i])
        indices = g_slist_append(indices, GINT_TO_POINTER(i));
    return indices;
  }
  private guint
  byte_array_get_n_indices(GByteArray *array)
  {
    guint i, n_indices = 0;
    for (i = 0; i < array->len; i++)
      n_indices += array->data[i];
    return n_indices;
  }
  
  private void
  byte_array_foreach(GByteArray *array, GGobiIndexFunc func, gpointer data)
  {
    GSList *indices = self_byte_array_to_indices(array);
    g_slist_foreach(indices, (GFunc)func, data);
    g_slist_free(indices);
  }
  
  // FIXME: Once we have bitsets, we could clone the bitset from which
  // we got 'indices', perform an insertion, and get the indices back out
  private GSList *
  shift_indices(GSList *indices, GByteArray *array, guint *over)
  {
    GSList *sorted = g_slist_sort(indices, self_index_compare), *shifted = NULL;
    guint i = 0, inc = 0;
    *over = 0;
    for (; sorted; sorted = sorted->next) {
      guint index = GPOINTER_TO_INT(sorted->data);
      if (index < array->len) {
        for (; i < index; i++)
          inc += array->data[i];
        shifted = g_slist_append(shifted, GINT_TO_POINTER(index + inc));
      } else (*over)++;
    }
    g_slist_free(sorted);
    return shifted;
  }
  
  private gint
  index_compare(gconstpointer a, gconstpointer b)
  {
    return GPOINTER_TO_INT(a) - GPOINTER_TO_INT(b);
  }
}
