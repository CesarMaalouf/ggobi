%h{

#include "defines.h"
#include "brushing.h"
#include "vartable.h"
#include "fileio.h"

#include <gtk/gtk.h>
#include <math.h>

typedef enum {no_edgesets, edgesets_only, all_datatypes} datatyped;

typedef struct _Subset {
  gint random_n;
  gint string_pos;
 /*-- adjustments from which to get values for blocksize, everyn --*/
  GtkAdjustment *bstart_adj, *bsize_adj;
  GtkAdjustment *estart_adj, *estep_adj;
} Subset;


typedef struct _Jitterd {
  gfloat factor;
  gboolean type;
  gboolean convex;
  gfloat *jitfacv;
} Jitterd;

typedef struct _Varpanel_cboxd {
  GtkWidget *ebox;   /*-- child1 of pane widget --*/
  GtkWidget *swin;   /*-- child of ebox --*/
  GtkWidget *vbox;   /*-- child of swin --*/
  GSList *box;       /*-- single column of hboxes --*/
} Varpanel_cboxd;

typedef struct _Varpanel_circd {
  GtkWidget *ebox;        /*-- child2 of pane widget --*/
  GtkWidget *vbox;        /*-- child of ebox --*/
  GtkWidget *swin, *hbox; /*-- children of vbox --*/
  GtkWidget *table;       /*-- sole child of swin; now a vbox --*/
  GtkWidget *manip_btn, *freeze_btn; /*-- children of hbox --*/

  GdkCursor *cursor;
  gint jcursor;

 /*-- components and properties of the table --*/
  GSList *vb, *da, *label;
  GSList *da_pix;         /*-- backing pixmaps --*/
  gint nvars;
} Varpanel_circd;

typedef struct _Varpaneld {
  GtkWidget *hpane;  /*-- child of the ebox --*/
} Varpaneld;

/*-------------------- transformation --------------------------------*/

/* sphering transformation **/
typedef struct _Sphere_d {
  vector_i vars;        /*-- vars available to be sphered --*/
  vector_i vars_sphered;/*-- vars that have been sphered --*/
  gint npcs;      /*-- the first npcs vars of vars will be sphered --*/
  vector_i pcvars;/*-- vars into which sphered data is written --*/

  vector_f eigenval;
  array_d eigenvec;
  array_f vc;
  vector_f tform_mean;
  vector_f tform_stddev;

  gboolean vars_stdized;
} Sphere_d;


typedef struct _EdgeData {
  gint n;
  SymbolicEndpoints *sym_endpoints;
  GList *endpointList;   
    /* a list of endpointsd elements corresponding to the resolved 
       record ids relative to a given datad. This is akin to a table
       indexed by datad elements. **/

  gint nxed_by_brush;
  vector_b xed_by_brush;
} EdgeData;

typedef struct _BrushBins {
  gint nbins;
  bin_struct **binarray;
  /*
   * bin0 is the bin which contains of the upper left corner of the
   * brush; bin1 is the one containing of the lower right corner.
  */  
  icoords bin0, bin1;
} BrushBins;


%}

%{
#include "vars.h"
#include "externs.h"
%}


enum ATTR_SET {
  PERSISTENT,
  TRANSIENT
} GGobiData:AttrSetMethod;

/**
 * SECTION:GGobiData
 * @short_description: Basic data storage and manipulation class.
 * @stability: Unstable
 *
 * The GGobiData class provides all methods for manipulating 
 * data within GGobi.  It is the starting point for the pipeline.
 * 
 * Eventually this will become an abstract class and subclass will
 * provide the actual implementation.  This will make it easy to treat
 * an R data frame, or a SQL query as the data source for GGobi.
 */
class GGobi:Data from G:Object {

public const gchar *name;
public const gchar *nickname;
public InputDescription *input;

public guint nrows;
public guint ncols;

public guint nattributes = 0;

public gboolean missings;

public struct _ggobid *gg; /*-- a pointer to the parent --*/

/* GUI related */
public Subset  subset;
public Jitterd  jitter;
public Varpanel_cboxd  vcbox_ui;
public Varpanel_circd  vcirc_ui;
public Varpaneld  varpanel_ui;
public Sphere_d  sphere;
public EdgeData  edge;
public BrushBins  brush;

public GtkWidget *vartable_tree_view[all_vartypes];
public GtkTreeModel *vartable_tree_model; /* the root model, with all vars **/
public GtkWidget *cluster_table; /*-- table of symbol groups from brushing --*/
public clusteruid *clusvui;

public GHashTable* idTable;
public GHashTable* var_name_lookup;

/*-- to support brushing by categorical variable --*/
public gchar* linkvar = NULL;  /*-- the linking variable name--*/

// Vectors of length ncol
protected vartabled **vartable;

// Vectors of length nrows
public char **rowIds;
public vector_b excluded;
public vector_b sampled;
public vector_i clusterid;

protected vector_i rows_in_plot;
public vector_i rows_under_brush;
public vector_i rows_under_brush_prev;

// Arrays of ncols x nrows
protected array_f raw;
public array_f tform;
public array_g world;
public array_g jitdata;
public array_s missing; 

public gboolean missings_show_p; /*-- show/hide per datad, not per display --*/
public gint nrows_in_plot;     /*-- how many elements of rows_in_plot to use --*/
public gint nrows_under_brush;
public gint nrows_under_brush_prev;
/*--------------- clusters: hiding, excluding ----------------------*/

public symbol_cell symbol_table[NGLYPHTYPES][NGLYPHSIZES][MAXNCOLORS];
public gint nclusters;
public clusterd *clusv;

/*-- used in identification, line editing, and point motion --*/
public gint nearest_point;
public gint nearest_point_prev;
public GSList *sticky_ids;

/*-------------------- moving points ---------------------------------*/
public GSList *movepts_history; /*-- a list of elements of type celld --*/


property UINT nrows 
  (nick = "nrows", blurb = "Number of rows in the dataset",
   minimum = 0, maximum = INT_MAX, default_value = 0,
   flags = CONSTRUCT_ONLY, link, export);
property UINT ncols 
  (nick = "ncols", blurb = "Number of cols in the dataset",
   minimum = 0, maximum = INT_MAX, default_value = 0,
   flags = CONSTRUCT_ONLY, link, export);
   
private signal first NONE (UINT) void 
rows_in_plot_changed(self, guint n) {
  tform_to_world(self);
  if (self->gg)
    displays_tailpipe (FULL, self->gg);
}

private signal NONE (UINT) void 
col_name_changed(self, guint j);

private signal first NONE (UINT) void 
col_data_changed(self, guint j) {
  limits_set_by_var(self, j, true, true, (self->gg) ? self->gg->lims_use_visible : true);
  tform_to_world_by_var(self, j);
  if (self->gg)
    displays_tailpipe (FULL, self->gg);
}

/**
 * cols_added:
 * @self: #GGobiData
 * @n: number of new columns
 *
 * Columns added signal
 **/
private signal NONE (UINT) void
cols_added(self, guint n);

/**
 * cols_deleted:
 * @self: #GGobiData
 * @j: Column deleted
 *
 * Columns deleted signal
 **/
private signal NONE (UINT) void
col_deleted(self, guint j);

/**
 * rows_added:
 * @self: #GGobiData
 * @n: number of new rows
 * 
 * Rows added signal
 **/
private signal NONE (UINT) void
rows_added(self, guint n);

init (self) {
  sphere_init(self); 
  
  self_set_name(self, "unknown", NULL);

  self->idTable = g_hash_table_new(g_str_hash, g_str_equal);
  self->var_name_lookup = g_hash_table_new(g_str_hash, g_str_equal);

  self->nearest_point = -1;
  self->missings_show_p = true;
  
}

/** 
 * new:
 * @nrows: number of rows
 * @ncols: number of columns
 *
 * Create new #GGobiData object
 * 
 * Returns: #GGobiData object
 **/
public GGobiData* 
new(guint nrows, guint ncols)
{
  GGobiData* d = (GGobiData*) g_object_new(GGOBI_TYPE_DATA, NULL);
  self_add_cols(d, ncols);
  self_add_rows(d, nrows);

  return(d);
}


public void
add_attributes(self) {
  self->nattributes += 12;
  guint first_attr = self_add_cols(self, 12);
  self_set_col_name(self, first_attr++, "_color");
  self_set_col_name(self, first_attr++, "_glyph_size");
  self_set_col_name(self, first_attr++, "_glyph_type");
  self_set_col_name(self, first_attr++, "_hidden");
  self_set_col_name(self, first_attr++, "_color_now");
  self_set_col_name(self, first_attr++, "_glyph_size_now");
  self_set_col_name(self, first_attr++, "_glyph_type_now");
  self_set_col_name(self, first_attr++, "_hidden_now");
  self_set_col_name(self, first_attr++, "_color_prev");
  self_set_col_name(self, first_attr++, "_glyph_size_prev");
  self_set_col_name(self, first_attr++, "_glyph_type_prev");
  self_set_col_name(self, first_attr++, "_hidden_prev");

  gint def_color = self->gg ? self->gg->color_id : 0;
  gint def_type  = self->gg ? self->gg->glyph_id.type : FC;
  gint def_size =  self->gg ? self->gg->glyph_id.size : 1;

  for (guint i = 0; i < self->nrows; i++) {
    self_set_attr_color(self, i, def_color, ATTR_SET_PERSISTENT);
    self_set_attr_glyph_parts(self, i, def_type, def_size, ATTR_SET_PERSISTENT);
    self_set_attr_hidden(self, i, false, ATTR_SET_PERSISTENT);
  }

}

public guint
get_n_data_cols(self) {
  return self->ncols - self->nattributes;
}

/**
 * get_name:
 * @self: #GGobiData
 *
 * Get name of dataset
 * 
 * Returns: duplicate of dataset name
 **/
public gchar *
get_name (self)
{
  return g_strdup(self->name);
}


/**
 * set_name:
 * @self: #GGobiData
 * @name: new name
 * @nickname: new nickname (if NULL, uses first 5 characters of name)
 *
 * Get name of dataset
 **/
public void
set_name (self, const gchar *name, const gchar *nickname)
{
  if (name == NULL) name = g_strdup("unknown");
  if (nickname == NULL) nickname = g_strndup(name, 5);

  self->name = g_strdup(name);
  self->nickname = g_strndup(name, 5);
}

/** 
 * get_n_cols:
 * @self: #GGobiData
 *
 * Get number of columns.  This should be used in preference to referring to ncols
 * directly, as future subclasses may not use the same structure
 **/
public guint
get_n_cols(self) {
  return self->ncols;
}

/** 
 * get_n_cols:
 * @self: #GGobiData
 *
 * Get number of rows
 * This should be used in preference to referring to nrows
 * directly, as future subclasses may not use the same structure
 **/
public guint
get_n_rows(self) {
  return self->nrows;
}

/**
 * get_col_name:
 * @self: #GGobiData
 * @j: column index
 *
 * Returns: duplicate of column name
 **/
public gchar* 
get_col_name(self, guint j) 
{
  vartabled* vt = self_get_vartable(self, j);
  return g_strdup(vt->collab);
}

/**
 * get_col_nickname:
 * @self: #GGobiData
 * @j: column index
 *
 * Returns: duplicate of column nickname
 **/
public gchar* 
get_col_nickname(self, guint j) 
{
  vartabled* vt = self_get_vartable(self, j);
  if (vt->nickname)
    return g_strdup(vt->nickname);
  else
    return NULL;
}

/**
 * get_col_index_for_name:
 * @self: #GGobiData
 * @value: column name
 *
 * Returns: index of column with given name, or -1 if no matching columns
 **/
public guint
get_col_index_for_name(self, const gchar* value) 
{
  gpointer pos, key;
  if (value && g_hash_table_lookup_extended(self->var_name_lookup, value, &key, &pos))
    return GPOINTER_TO_INT(pos);
  return -1;
}

/** 
 * set_col_name:
 * @self: GGobiData object
 * @j: column index
 * @value: new column name (if NULL uses column index)
 *
 * Set column name
 * Also sets nickname to the first two letters.
 * Emits col_name_changed() signal.
 **/
public void 
set_col_name(self, guint j, const gchar* value) 
{
  vartabled* vt = self_get_vartable(self, j);

  if (value == NULL) value = g_strdup_printf("V%d", j + 1);

  vt->collab = g_strdup(value);
  vt->collab_tform = g_strdup(value);
  if (!vt->nickname)
    vt->nickname = g_strndup (vt->collab, 2);

  g_hash_table_replace (self->var_name_lookup, vt->collab, GINT_TO_POINTER(j));
  self_col_name_changed(self, j);
}

/** 
 * set_col_nickname:
 * @self: GGobiData object
 * @j: column index
 * @value: new column nickname
 **/
public void 
set_col_nickname(self, guint j, const gchar* value)
{
  vartabled* vt = self_get_vartable(self, j);
  vt->nickname = g_strdup(value);
}

// FIXME: to be removed once pipeline in place
/** 
 * get_transformed_col_name:
 * @self: GGobiData object
 * @j: column index
 * Returns: duplicate of transformed column name (brief description of transformation
 * applied to variable)
 **/
public gchar* 
get_transformed_col_name(self, guint j) 
{
  gchar *lbl0, *lbl1, *lbl2;
  vartabled *vt = self_get_vartable(self, j);

   /*-- skip the stage0 changes except negation --*/
   switch (vt->tform0) {
     case NEGATE:
       lbl0 = g_strdup_printf ("-%s", self_get_col_name(self, j));
       break;
     default:
       lbl0 = g_strdup (self_get_col_name(self, j));
       break;
   }

   switch (vt->tform1) {
     case BOXCOX:
       lbl1 = g_strdup_printf ("B-C(%s,%.2f)", lbl0, vt->param);
       break;
     case LOG10:
       lbl1 = g_strdup_printf ("log10(%s)", lbl0);
       break;
     case INVERSE:
       lbl1 = g_strdup_printf ("1/%s", lbl0);
       break;
     case ABSVALUE:
       lbl1 = g_strdup_printf ("abs(%s)", lbl0);
       break;
     case SCALE_AB:
       lbl1 = g_strdup_printf ("%s [a,b]", lbl0);
       break;
     default:
       lbl1 = g_strdup (lbl0);
   }

   switch (vt->tform2) {
     case STANDARDIZE:
       lbl2 = g_strdup_printf ("(%s-m)/s", lbl1);
     break;
     case SORT:
       lbl2 = g_strdup_printf ("sort(%s)", lbl1);
     break;
     case RANK:
       lbl2 = g_strdup_printf ("rank(%s)", lbl1);
     break;
     case NORMSCORE:
       lbl2 = g_strdup_printf ("normsc(%s)", lbl1);
     break;
     case ZSCORE:
       lbl2 = g_strdup_printf ("zsc(%s)", lbl1);
     break;
     case DISCRETE2:
       lbl2 = g_strdup_printf ("%s:0,1", lbl1);
     break;
     default:
       lbl2 = g_strdup (lbl1);
   }
   
   return lbl2;
}


/**
 * set_missing:
 * @self: GGobiData object
 * @i: row index
 * @j: column index
 *
 * Set specified cell to be a missing value.  
 * If the variable is categorical, a new level value ("MISSING")
 * will be created, and the raw value set to that.
 **/
public void
set_missing(self, guint i, guint j)
{
  if (self_get_col_type(self, j) == categorical) {
    self_set_categorical_value(self, i, j, "MISSING");
    return;
  }

  self->missing.vals[i][j] = 1;
  self->raw.vals[i][j] = 0;

  self->missings = TRUE;
}


/**
 * is_missing:
 * @self: GGobiData object
 * @i: row index
 * @j: column index
 *
 * Returns: if value at specified positive is missing or not
 **/
public gboolean
is_missing(self, guint i, guint j) 
{
  return (self->missing.vals[i][j] == 1);  
}

/**
 * has_missings:
 * @self: GGobiData object
 * Returns: whether or not dataset contains any missing values
 **/
public gboolean
has_missings(self) 
{
  return self->missings;
}

/**
 * get_col_n_missing:
 * @self: GGobiData object
 * @j: column index
 * Returns: whether or not specified column contains any missing values
 **/
public guint 
get_col_n_missing(self, guint j) {
  guint i, n = 0;

  for(i = 0; i < self->nrows; i++) {
    if (self_is_missing(self, i, j)) n++;
  }
  
  return(n);
}


/**
 * set_raw_values:
 * @self: GGobiData object
 * @j: column index
 * @values: vector of new values, of length self->nrows
 * 
 * Sets all values in the specified column.  
 * Emits self_col_data_changed() signal.
 **/
public void
set_raw_values(self, guint j, gdouble *values)
{
  guint i;
  for (i = 0; i < self->nrows; i++) {
    self_set_raw_value(self, i, j, values[i]);
  }
  self_col_data_changed(self, j);
}


/**
 * set_raw_value:
 * @self: GGobiData object
 * @i: row index
 * @j: column index
 * @values: vector of new values, of length self->nrows
 * 
 * Sets a single value in the specified column.  
 *
 * This will set missing values if necessary and sets
 * tform value as well to keep dataset consistent.
 *
 * You need to manually emits self_col_data_changed() signal after
 * using this function if you want the data to continue down the pipeline.
 **/
public void
set_raw_value(self, guint i, guint j, gdouble value)
{
  if(GGobiMissingValue && GGobiMissingValue(value))
    self_set_missing(self, i, j);
  else {
    if (self_get_col_type(self, j) == categorical)
      if (self_get_col_level_for_value(self, j, (gint) value) == -1) {
        self_add_col_level(self, j, NULL, (gint) value);
      }
    self->raw.vals[i][j] = value;
    self->tform.vals[i][j] = value;
  }
}

// FIXME: should these two really be public?
public gint
get_col_level_for_value(self, guint j, gint value)
{
  gpointer key, level_ptr;
  vartabled *vt = self_get_vartable(self, j);
  g_return_val_if_fail(self_get_col_type(self, j) == categorical, -1);
  if(!g_hash_table_lookup_extended(vt->value_to_level, GINT_TO_POINTER(value), 
      &key, &level_ptr))
    return(-1);
  return(GPOINTER_TO_INT(level_ptr));
}

public gint
get_col_level_for_name(self, guint j, const gchar *name)
{
  gpointer key, level_ptr;
  vartabled *vt = self_get_vartable(self, j);
  g_return_val_if_fail(self_get_col_type(self, j) == categorical, -1);
  if (!g_hash_table_lookup_extended(vt->name_to_level, name, &key, &level_ptr))
    return(-1);
  return(GPOINTER_TO_INT(level_ptr));
}

/**
 * set_categorical_value:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 * @value: new categorical value
 * 
 * This function sets the value of a cell in a categorical variable.
 * It will automatically create a new level if necessary.
 * If the column is not already categorical, this will make it so.
 */
public void
set_categorical_value(self, guint i, guint j, const gchar* value) 
{
  vartabled* vt = self_get_vartable(self, j);
  self_set_col_type(self, j, categorical);
  guint level = self_get_col_level_for_name(self, j, value);
  
  if (level == -1) {
    level = self_add_col_level(self, j, value, -1);
  } else {
    vt->level_counts[level]++;
  }

  self_set_int_value(self, i, j, self_get_col_level_value(self, j, level));
}

/**
 * set_string_value:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 * @value: new value
 *
 * This function provides a convenient method for setting the
 * value from a string.  Empty strings, . and NA will be treated as
 * missings.  Strings that can be converted to an number will store
 * that number.  Otherwise set_categorical_value() will be used
 **/
public void
set_string_value(self, guint i, guint j, const gchar* value) 
{
  if (is_numeric(value)) {
    self_set_raw_value(self, i, j, (gfloat) g_strtod (value, NULL));
  } else {
    if (!g_ascii_strcasecmp (value, "na") || !strcmp (value, ".") || !strcmp(value, ""))  
      self_set_missing(self, i, j);
    else
      self_set_categorical_value(self, i, j, value);
  }
}

/** 
 * get_raw_value:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 **/
public gdouble
get_raw_value(self, guint i, guint j)
{
  return self->raw.vals[i][j];
}

public vartyped 
get_col_type(self, guint j)
{
  vartabled *vt = self_get_vartable(self, j);
  return(vt->vartype);
}

public void 
set_col_type(self, guint j, vartyped value)
{
  vartabled *vt = self_get_vartable(self, j);
  vt->vartype = value;
}

/**
 * get_vartable:
 * @self: #GGobiData object
 * @j: column index
 *
 * Get variable meta data for specified column
 * Replaces vartable_element_get.  Should eventually become private.
 **/
public vartabled*
get_vartable (self, guint j)
{
  g_return_val_if_fail(j < self->ncols, NULL);
  
  return self->vartable[j];
}

/**
 * set_vartable:
 * @self: #GGobiData object
 * @j: column index
 *
 * Set variable meta data for specified column
 * Should eventually become private.
 **/
public void
set_vartable (self, guint j, vartabled* value)
{
  self->vartable[j] = value;
}

/**
 * get_col_n_levels:
 * @self: #GGobiData object
 * @j: column index
 *
 * Get number of levels in a categorical variable
 **/
public gchar  
get_col_n_levels(self, guint j)
{
  vartabled *vt = self_get_vartable(self, j);
  g_return_val_if_fail(self_get_col_type(self, j) == categorical, 0);  
  
  return(vt->nlevels);
}

public gchar* 
get_col_level_name(self, guint j, guint value)
{
  vartabled *vt = self_get_vartable(self, j);
  gint i = self_get_col_level_for_value(self, j, value);

  g_return_val_if_fail(self_get_col_type(self, j) == categorical, NULL);
  
  if (i == -1) return g_strdup("MISSING");
  return(g_strdup(vt->level_names[i]));
}

public guint  
get_col_level_count(self, guint j, guint value)
{
  vartabled *vt = self_get_vartable(self, j);
  gint i = self_get_col_level_for_value(self, j, value);

  g_return_val_if_fail(self_get_col_type(self, j) == categorical, 0);  

  if (i == -1)  return 0;
  return(vt->level_counts[i]);
}


public guint
get_col_level_value(self, guint j, guint k) {
  vartabled *vt = self_get_vartable(self, j);
  return vt->level_values[k];
}

/**
 * get_col_level_value_closest: 
 * @self: #GGobiData object
 * @j: column index
 * @value: target value to search for 
 *
 * Get closest level value
 * For a categorical categorical, this searches through all level
 * values and returns the level value that is closest to the desired
 * value.  Currently seems a little buggy in that it prefers one 
 * direction over another
 *
 * Returns: closest level value to target value
 *
 **/
public guint  
get_col_level_value_closest(self, guint j, guint value)
{
  vartabled *vt = self_get_vartable(self, j);
  g_return_val_if_fail(self_get_col_type(self, j) == categorical, 0);  

  guint k, level = 0, dist = 0, ddist = G_MAXUINT;
  for (k = 0; k < vt->nlevels; k++) {
    dist = fabs ((greal) vt->level_values[k] - value);
    if (dist < ddist) {
        level = k;
        ddist = dist;
    }
  }

  return vt->level_values[level];
}
/**
 * get_col_max:
 * @self: #GGobiData object
 * @j: column index
 * 
 * Find the biggest value in the column.
 * For numerical columns, value is cached by limits_set()
 * Does the right thing for categorical variables too.  
 **/
public gfloat
get_col_max(self, guint j)
{
  vartabled *vt = self_get_vartable(self, j);
  gint level_value, level_value_max=G_MININT, i;

  if (self_get_col_type(self, j) != categorical) {
    return vt->lim.max;
  }

  if (vt->nlevels && vt->nlevels > 0) {
    level_value_max = vt->level_values[0];
    for (i = 0; i < vt->nlevels; i++) {
      level_value = vt->level_values[i];
      if (level_value > level_value_max)
        level_value_max = level_value;
    }
  }
  
  return (gfloat) level_value_max;
}


/**
 * get_col_min:
 * @self: #GGobiData object
 * @j: column index
 * 
 * Find the smallest value in the column.
 * For numerical columns, value is cached by limits_set()
 * Does the right thing for categorical variables too.
 **/
public gfloat
get_col_min(self, guint j)
{
  vartabled *vt = self_get_vartable(self, j);
  guint level_value, level_value_min=G_MAXINT, i;

  if (self_get_col_type(self, j) != categorical) {
    return vt->lim.min;
  }
// FIXME: shouldn't this also be cached?
  if (vt->nlevels && vt->nlevels > 0) {
    level_value_min = vt->level_values[0];
    for (i = 0; i < vt->nlevels; i++) {
      level_value = vt->level_values[i];
      if (level_value < level_value_min)
        level_value_min = level_value;
    }
  }
  
  return(gfloat) level_value_min;
}

public gfloat
get_col_range(self, guint j)
{
  vartabled *vt = self_get_vartable(self, j);
  return vt->lim.max - vt->lim.min;
}

public gfloat
get_col_mean(self, guint j)
{
  vartabled *vt = self_get_vartable(self, j);
  return vt->mean;
}

/**
 * add_col_level:
 * @self: #GGobiData object
 * @j: column index
 * @name: character description of level, if NULL uses value
 * @value: level value, if -1 uses index + 1
 * Returns: index of new level
 **/
public guint
add_col_level(self, guint j, const gchar *name, gint value)
{
  vartabled *vt = self_get_vartable(self, j);
  guint level = vt->nlevels++;

  if (vt->nlevels == 1) {
    vt->level_values = (gint *)   g_malloc (sizeof (gint));
    vt->level_counts = (gint *)   g_malloc (sizeof (gint));
    vt->level_names  = (gchar **) g_malloc (sizeof (gchar *));
  } else {
    vt->level_values =
      (gint *) g_realloc (vt->level_values, sizeof (gint) * vt->nlevels);
    vt->level_counts =
      (gint *) g_realloc (vt->level_counts, sizeof (gint) * vt->nlevels);
    vt->level_names =
      (gchar **) g_realloc (vt->level_names, sizeof (gchar *) * vt->nlevels);
  }
  vt->level_counts[level] = 1;

  if (value == -1)
    value = level+1;
  vt->level_values[level] = value;

  if (!name)
    vt->level_names[level] = g_strdup_printf("%d", value);
  else 
    vt->level_names[level] = g_strdup(name);

  g_hash_table_insert(vt->name_to_level, vt->level_names[level], 
    GINT_TO_POINTER(level));
  g_hash_table_insert(vt->value_to_level, GINT_TO_POINTER(vt->level_values[level]), 
    GINT_TO_POINTER(level));
    
  return level;
}
  
public void  
set_col_levels(self, guint j, guint levels, gchar** names, guint* values, guint* counts)
{
  guint i;
  vartabled *vt = self_get_vartable(self, j);

  self_set_col_type(self, j, categorical);  

  vt->vartype = categorical;
  vt->nlevels = levels;
  vt->level_names = (gchar **) g_malloc(sizeof(gchar*) * levels);
  vt->level_values = (guint *) g_malloc(sizeof(guint) * levels);
  vt->level_counts = (guint *) g_malloc(sizeof(guint) * levels);
  for(i = 0; i < levels; i++) {
    vt->level_names[i]  = g_strdup(names[i]);
    vt->level_counts[i] = (counts) ? counts[i] : 0;
    vt->level_values[i] = (values) ? values[i] : i+1;
    g_hash_table_insert(vt->name_to_level, vt->level_names[i], 
      GINT_TO_POINTER(i));
    g_hash_table_insert(vt->value_to_level, GINT_TO_POINTER(vt->level_values[i]), 
      GINT_TO_POINTER(i));
 }
}

/**
 * get_string_value:
 * @self: #GGobiData object
 * @i: row index
 * @j: column index
 * @transformed: transformed or raw values?
 *
 * Get string representation of value
 * This currently returns a locale insensitive string, suitable for
 * output into csv etc.  It may be sub-optimal for user display, because
 * it does not use the users locale settings, and outputs full precision.
 **/
public gchar*
get_string_value(self, guint i, guint j, gboolean transformed) 
{
  guint lval = -1;
  vartabled *vt = self_get_vartable(self, j);
  gdouble raw = transformed ? self->tform.vals[i][j] : self->raw.vals[i][j];
  
  if (self_is_missing(self, i, j)) 
    return g_strdup("NA");

  if (vt->vartype != categorical) {
    gchar *buf = g_new(gchar, G_ASCII_DTOSTR_BUF_SIZE);
    g_ascii_dtostr(buf, G_ASCII_DTOSTR_BUF_SIZE, raw);
    return buf;
  }
  
  lval = self_get_col_level_for_value(self, j, (gint) raw);
  if (lval == -1) {  //useful for debugging
    g_warning ("Levels for %s specified incorrectly", self_get_col_name(self, j));
    return g_strdup_printf("%g", raw);
  }
  
  return g_strdup(vt->level_names[lval]);
}

/**
 * has_edges:
 * @self: #GGobiData object
 *
 * Test if this dataset has any edges
 **/ 
public gboolean 
has_edges (self) 
{
  return (self->edge.n > 0);
}

/**
 * has_cols:
 * @self: #GGobiData object
 *
 * Test if this dataset has any variables
 **/
public gboolean 
has_cols (self) 
{
  return (self->ncols > 0);
}

/* 
 * set_row_id:
 * @self: #GGobiData object
 * @i: row
 * @value: new string value for row id
 * @check: throw error if id is already used?
 *
 * Set the row id (a string) for specified row
 * A row id is a unique string reference to a given row.
 * These are hashed for O(1) lookup.
 **/ 
public void
set_row_id(self, guint i, gchar* value, gboolean check) {
  if (value == NULL)
    value = g_strdup_printf("%d", i+1);

  //g_return_if_fail(check && self_get_row_for_id(self, value) == -1);

  self->rowIds[i] = g_strdup(value);
  g_hash_table_replace (self->idTable, self->rowIds[i], GINT_TO_POINTER(i));
}

/** 
 * get_row_id:
 * @self: #GGobiData object
 * @i: row
 * 
 * Retrive row id for specified row.
 * Returns: duplicate of row id if present, NULL otherwise
 **/
public gchar*
get_row_id(self, guint i) {
  if (self->rowIds[i]) 
    return g_strdup(self->rowIds[i]);
  else
    return NULL;
}

/** 
 * get_row_for_id:
 * @self: #GGobiData object
 * @id: row id string
 * 
 * Get row index corresponding to row id
 *
 * Returns: row index if found, -1 otherwise
 **/
public gint
get_row_for_id(self, gchar *id) {
  gpointer pos, key;
  if (id && g_hash_table_lookup_extended(self->idTable, id, &key, &pos))
    return GPOINTER_TO_INT(pos);
  return -1;
}

/**
 * add_rows: 
 * @self: #GGobiData object
 * @n: number of rows to add
 *
 * Add n rows to the dataset
 * Adds extra rows, allocating space as needed.
 *
 * This emits the cols_added signal and also runs
 * #set_rows_in_plot which emits the rows_in_plot_changed signal.
 *
 * Returns: index of first new row
 **/
public guint
add_rows(self, guint n) {
  guint i, nprev = self->nrows;
  self->nrows += n;
  
  self->rowIds = (gchar **) g_realloc (self->rowIds, sizeof(gchar *) * self->nrows);
  vectorb_realloc (&self->excluded, self->nrows);
  vectorb_realloc (&self->sampled, self->nrows);
  vectori_realloc (&self->rows_in_plot, self->nrows);
  vectori_realloc (&self->rows_under_brush, self->nrows);
  vectori_realloc (&self->rows_under_brush_prev, self->nrows);
  vectori_realloc (&self->clusterid, self->nrows);

  arrayf_add_rows (&self->raw, self->nrows);
  arrayf_add_rows (&self->tform, self->nrows);
  arrayg_add_rows (&self->jitdata, self->nrows);
  arrayg_add_rows (&self->world, self->nrows);
  arrays_add_rows (&self->missing, self->nrows);

  self->nrows_under_brush = self->nrows_under_brush_prev = 0;

  if (self_has_edges(self))
    vectorb_realloc (&self->edge.xed_by_brush, self->edge.n);

  for (i = nprev; i < self->nrows; i++) {
    self->excluded.els[i] = false;
    self->sampled.els[i] = true;
    
    self->rows_under_brush.els[i] = 0;
    self->rows_under_brush_prev.els[i] = 0;
    
    self->rowIds[i] = NULL;
  }

  if (self->nattributes > 0) {
    gint def_color = self->gg ? self->gg->color_id : 0;
    gint def_type  = self->gg ? self->gg->glyph_id.type : FC;
    gint def_size  = self->gg ? self->gg->glyph_id.size : 1;

    for (i = nprev; i < self->nrows; i++) {
      self_set_attr_color(self, i, def_color, ATTR_SET_PERSISTENT);
      self_set_attr_glyph_parts(self, i, def_type, def_size, ATTR_SET_PERSISTENT);
      self_set_attr_hidden(self, i, false, ATTR_SET_PERSISTENT);
    }
  }
  clusters_set(self);
  self_set_rows_in_plot(self);
  
  self_rows_added(self, n);
  return nprev;
}


/* 
 * add_cols:
 * @self: #GGobiData object
 * @n: number of columns to add
 *
 * Add n empty columns to the dataset.
 * Returns: index of first new column
 **/ 
public guint 
add_cols(self, guint n) {
  guint nprev = self->ncols;
  self->ncols += n;

  self->vartable = (vartabled **) g_realloc (self->vartable, sizeof(vartabled *) * self->ncols);
  for(guint j = nprev; j < self->ncols; j++) {
    vartabled *vt = vartable_element_new(self);
    self_set_vartable(self, j, vt);
  } 
  arrayf_add_cols (&self->raw, self->ncols);
  arrayf_add_cols (&self->tform, self->ncols);
  arrayg_add_cols (&self->jitdata, self->ncols);
  arrayg_add_cols (&self->world, self->ncols);
  arrays_add_cols (&self->missing, self->ncols);

  tour_realloc_up (self, self->ncols);

  self_cols_added(self, n);
  
  return nprev;
}

public guint
delete_cols(self, guint *cols, gint ncols)
{
  gint j;
  gint *keepers, nkeepers;
  
  g_return_val_if_fail(ncols < self->ncols, !self_has_cols(self));

  // FIXME: shouldn't find_keepers be able to handle this allocation??
  keepers = g_malloc ((self->ncols - ncols) * sizeof (gint));
  nkeepers = find_keepers (self->ncols, ncols, cols, keepers);
  if (nkeepers == -1) {
    g_free (keepers);
    g_return_val_if_reached(self->ncols);
  }
  
  for (j = 0; j < nkeepers; j++) {
    vartabled *vt = self_get_vartable(self, keepers[j]);
    self_set_vartable(self, j, vt);
  }

  self->vartable = g_renew(vartabled*, self->vartable, nkeepers);
  
  //FIXME: need function analogous to tour_relloc_up
  tour2d_realloc_down (ncols, cols, self, self->gg);
  tour1d_realloc_down (ncols, cols, self, self->gg);
  tourcorr_realloc_down (ncols, cols, self, self->gg);

  arrayf_delete_cols (&self->raw, ncols, cols);
  arrayf_delete_cols (&self->tform, ncols, cols);
  arrayg_delete_cols (&self->jitdata, ncols, cols);
  arrayg_delete_cols (&self->world, ncols, cols);
  arrays_delete_cols (&self->missing, ncols, cols);
  
  self->ncols -= ncols;
  for (j = 0; j < ncols; j++) /* emit col deleted signal */
    self_col_deleted(self, cols[j]);
  
  
  /*-- emit a single variable_list_changed signal when finished --*/
  /*-- doesn't need to give a variable index any more, really --*/
  // FIXME: emission of this is deprecated
/*  g_signal_emit_by_name(self->gg, "variable_list_changed", 0, self);*/

    /*-- run the first part of the pipeline  --*/
  tform_to_world(self);
                 
  g_free (keepers);
  
  return(self->ncols);
}

public void
free (self) 
{
  vectorb_free (&self->excluded);
  vectorb_free (&self->sampled);
  vectori_free (&self->rows_in_plot);
  vectori_free (&self->clusterid);

  arrayf_free (&self->raw, self->nrows, self->ncols);
  arrayf_free (&self->tform, self->nrows, self->ncols);
  arrayg_free (&self->jitdata, self->nrows, self->ncols);
  arrayg_free (&self->world, self->nrows, self->ncols);
  arrays_free (&self->missing, self->nrows, self->ncols);

  for (gint j = self->ncols-1; j >= 0; j--) {
    vartabled *vt = self_get_vartable(self, (guint)j); 
    if (vt->collab != NULL) g_free (vt->collab);
    if (vt->collab_tform != NULL) g_free (vt->collab_tform);
    g_hash_table_destroy(vt->name_to_level);
    g_hash_table_destroy(vt->value_to_level);
    g_free(vt);
  }
  g_free (self->vartable);

  g_hash_table_destroy(self->idTable); 
  g_hash_table_destroy(self->var_name_lookup); 

  g_free(self->rowIds);
  g_free(self);
}

/**
 * attach:
 * @self: #GGobiData object
 * @gg: GGobi object
 * @cleanup: should cleanup occur?
 *
 * Attach a GGobi object to this dataset
 * The purpose of this function is to hook up the #GGobiData object
 * to all the gui components and make sure they stay in sync by
 * listening to the correct signals.  This function still needs a lot of
 * work.
 **/
public void 
attach (self, ggobid *gg, gboolean cleanup)
{
  self->gg = gg;
  gg->d = g_slist_append (gg->d, self);
  displayd *display = NULL;

  gint *vars = (gint *) g_malloc(self->ncols * sizeof(gint));
  
  self->brush.bin0.x = self->brush.bin1.x = BRUSH_NBINS;
  self->brush.bin0.y = self->brush.bin1.y = BRUSH_NBINS;

  gint iv, ih;
  self->brush.nbins = BRUSH_NBINS;

  edgeedit_init (self->gg);
  if (self_has_edges(self))
    vectorb_realloc (&self->edge.xed_by_brush, self->edge.n);

  /* binning the plot window; no need to realloc these **/
  self->brush.binarray = (bin_struct **)
    g_malloc (self->brush.nbins * sizeof (bin_struct *));
  for (ih = 0; ih < self->brush.nbins; ih++) {
    self->brush.binarray[ih] = (bin_struct *)
      g_malloc (self->brush.nbins * sizeof (bin_struct));

    for (iv = 0; iv < self->brush.nbins; iv++) {
      self->brush.binarray[ih][iv].nels = 0;
      self->brush.binarray[ih][iv].nblocks = 1;
      self->brush.binarray[ih][iv].els = (gulong *)
        g_malloc (BINBLOCKSIZE * sizeof (gulong));
    }
  }

  /**
   * If there are missings, they've been initialized with a value
   * of 0.  Here, re-set that value to 15% below the minimum for each
   * variable.  (dfs -- done at Di's request, September 2004)
   **/
  limits_set (self, true, true, self->gg->lims_use_visible);
  for (guint j = 0; j < self->ncols; j++) vars[j] = j;
  impute_fixed (IMP_BELOW, 15.0, self->ncols, vars, self);
  limits_set (self, true, true, self->gg->lims_use_visible);
  g_free(vars);

  for(guint j = 0; j < self_get_n_data_cols(self); j++) 
    self_col_data_changed(self, j);

  clusters_set(self);  /*-- find the clusters for data just read in --*/

  display_menu_build (gg);
  
  // Set up variable table and listen to important events
  self_connect__col_data_changed(self, vartable_stats_set_by_var, NULL);
  self_connect__col_data_changed(self, vartable_limits_set_by_var, NULL);
  self_connect__col_name_changed(self, vartable_collab_set_by_var, NULL);
  self_connect__col_name_changed(self, vartable_collab_tform_set_by_var, NULL);

  varcircles_populate (self, gg);
  self_connect__col_name_changed(self, varcircle_label_set, NULL);

  if (cleanup)
    varpanel_clear (self, gg);
  varpanel_populate (self, gg);   
  if (gg->current_display != NULL)
    varpanel_refresh (gg->current_display, gg);
  if (g_slist_index(gg->d, (gpointer)self) == 0)
    varpanel_set_sensitive (self, true, gg);
  self_connect__col_name_changed(self, varpanel_label_set, NULL);

  
  if (cleanup || g_list_length(gg->displays) == 0) {
    display_free_all (gg);  /*-- destroy any existing displays --*/
    gg->pmode = NULL_PMODE;

    /*-- initialize the first display --*/
    if(sessionOptions->info->createInitialScatterPlot && self_has_cols(self)) {
      display = scatterplot_new (false, NULL, self, gg);

      gg->displays = g_list_append (gg->displays, (gpointer) display);
      gg->current_splot = (splotd *)
      g_list_nth_data (display->splots, 0);
      display->current_splot = gg->current_splot;
      display_set_current (display, gg);

      sp_event_handlers_toggle (gg->current_splot, on, gg->pmode, gg->imode);
    }
  }
  g_signal_emit_by_name (G_OBJECT (gg), "datad_added", self);
}

/**
 * set_rows_in_plot:
 * @self: #GGobiData object
 *
 * Combine the values in two arrays:
 *   excluded[] (which comes from the exclusion panel or from linking)
 *   sampled[] (which come from the subset panel)
 * to determine which cases should be plotted.
 *
 * rows_in_plot = sampled && !excluded
 **/
public void
set_rows_in_plot(self)
{
  guint i;
  self->nrows_in_plot = 0;

  for (i = 0; i < self->nrows; i++)
    if (self->sampled.els[i] && !self->excluded.els[i])
      self->rows_in_plot.els[self->nrows_in_plot++] = i;
  
  self_rows_in_plot_changed(self, (guint) self->nrows_in_plot); 
}


/* Attributes
 * ============================================================================
 */

/* [[[cog
   import cog, attraccessor
   cog.outl(attraccessor.attr_accessor("color", "gushort", "short"))
   cog.outl(attraccessor.attr_accessor("hidden", "gboolean", "boolean"))
   cog.outl(attraccessor.attr_accessor("glyph_type", "gint", "int"))
   cog.outl(attraccessor.attr_accessor("glyph_size", "gint", "int"))
   ]]]*/
/**
 * reset_attr_color:
 * @self: #GGobiData 
 * @i: row index
 * @brush: persistent or transient
 *
 * Resets color attribute to previous value
**/
public gboolean
reset_attr_color(self, guint i, GGobiDataAttrSetMethod brush)
{
  gushort value;
  // This code is autogenerated, do not edit by hand
  switch(brush) {
    case ATTR_SET_PERSISTENT:
      value = self_get_short_value_for_col_name(self, i, "_color_prev");
    default:
      value = self_get_short_value_for_col_name(self, i, "_color");
  }
  
  return self_set_attr_color(self, i, value, brush);

}

/**
 * set_attr_color:
 * @self: #GGobiData
 * @i: row index
 * @brush: persistent or transient
 *
 * Sets color attribute to new value.
 * Returns: true if value has changed, false otherwise
**/
public gboolean
set_attr_color(self, guint i, gushort value, GGobiDataAttrSetMethod brush)
{
  // This code is autogenerated, do not edit by hand
  if (brush == ATTR_SET_TRANSIENT ?
    (self_get_short_value_for_col_name(self, i, "_color_now") == value) :
    (self_get_short_value_for_col_name(self, i, "_color") == value))
    return false;

  if (brush == ATTR_SET_PERSISTENT) {
    self_set_short_value_for_col_name(self, i, "_color_prev", 
      self_get_short_value_for_col_name(self, i, "_color"));
    self_set_short_value_for_col_name(self, i, "_color", value);
  }

  self_set_short_value_for_col_name(self, i, "_color_now", value);
  return true;
}

/**
 * get_attr_color:
 * @self: #GGobiData
 * @i: row index
 * 
 * Retrieve current color
**/
public gushort
get_attr_color(self, guint i)
{
  // This code is autogenerated, do not edit by hand
  return self_get_short_value_for_col_name(self, i, "_color_now");
}
/**
 * reset_attr_hidden:
 * @self: #GGobiData 
 * @i: row index
 * @brush: persistent or transient
 *
 * Resets hidden attribute to previous value
**/
public gboolean
reset_attr_hidden(self, guint i, GGobiDataAttrSetMethod brush)
{
  gboolean value;
  // This code is autogenerated, do not edit by hand
  switch(brush) {
    case ATTR_SET_PERSISTENT:
      value = self_get_boolean_value_for_col_name(self, i, "_hidden_prev");
    default:
      value = self_get_boolean_value_for_col_name(self, i, "_hidden");
  }
  
  return self_set_attr_hidden(self, i, value, brush);

}

/**
 * set_attr_hidden:
 * @self: #GGobiData
 * @i: row index
 * @brush: persistent or transient
 *
 * Sets hidden attribute to new value.
 * Returns: true if value has changed, false otherwise
**/
public gboolean
set_attr_hidden(self, guint i, gboolean value, GGobiDataAttrSetMethod brush)
{
  // This code is autogenerated, do not edit by hand
  if (brush == ATTR_SET_TRANSIENT ?
    (self_get_boolean_value_for_col_name(self, i, "_hidden_now") == value) :
    (self_get_boolean_value_for_col_name(self, i, "_hidden") == value))
    return false;

  if (brush == ATTR_SET_PERSISTENT) {
    self_set_boolean_value_for_col_name(self, i, "_hidden_prev", 
      self_get_boolean_value_for_col_name(self, i, "_hidden"));
    self_set_boolean_value_for_col_name(self, i, "_hidden", value);
  }

  self_set_boolean_value_for_col_name(self, i, "_hidden_now", value);
  return true;
}

/**
 * get_attr_hidden:
 * @self: #GGobiData
 * @i: row index
 * 
 * Retrieve current hidden
**/
public gboolean
get_attr_hidden(self, guint i)
{
  // This code is autogenerated, do not edit by hand
  return self_get_boolean_value_for_col_name(self, i, "_hidden_now");
}
/**
 * reset_attr_glyph_type:
 * @self: #GGobiData 
 * @i: row index
 * @brush: persistent or transient
 *
 * Resets glyph_type attribute to previous value
**/
public gboolean
reset_attr_glyph_type(self, guint i, GGobiDataAttrSetMethod brush)
{
  gint value;
  // This code is autogenerated, do not edit by hand
  switch(brush) {
    case ATTR_SET_PERSISTENT:
      value = self_get_int_value_for_col_name(self, i, "_glyph_type_prev");
    default:
      value = self_get_int_value_for_col_name(self, i, "_glyph_type");
  }
  
  return self_set_attr_glyph_type(self, i, value, brush);

}

/**
 * set_attr_glyph_type:
 * @self: #GGobiData
 * @i: row index
 * @brush: persistent or transient
 *
 * Sets glyph_type attribute to new value.
 * Returns: true if value has changed, false otherwise
**/
public gboolean
set_attr_glyph_type(self, guint i, gint value, GGobiDataAttrSetMethod brush)
{
  // This code is autogenerated, do not edit by hand
  if (brush == ATTR_SET_TRANSIENT ?
    (self_get_int_value_for_col_name(self, i, "_glyph_type_now") == value) :
    (self_get_int_value_for_col_name(self, i, "_glyph_type") == value))
    return false;

  if (brush == ATTR_SET_PERSISTENT) {
    self_set_int_value_for_col_name(self, i, "_glyph_type_prev", 
      self_get_int_value_for_col_name(self, i, "_glyph_type"));
    self_set_int_value_for_col_name(self, i, "_glyph_type", value);
  }

  self_set_int_value_for_col_name(self, i, "_glyph_type_now", value);
  return true;
}

/**
 * get_attr_glyph_type:
 * @self: #GGobiData
 * @i: row index
 * 
 * Retrieve current glyph_type
**/
public gint
get_attr_glyph_type(self, guint i)
{
  // This code is autogenerated, do not edit by hand
  return self_get_int_value_for_col_name(self, i, "_glyph_type_now");
}
/**
 * reset_attr_glyph_size:
 * @self: #GGobiData 
 * @i: row index
 * @brush: persistent or transient
 *
 * Resets glyph_size attribute to previous value
**/
public gboolean
reset_attr_glyph_size(self, guint i, GGobiDataAttrSetMethod brush)
{
  gint value;
  // This code is autogenerated, do not edit by hand
  switch(brush) {
    case ATTR_SET_PERSISTENT:
      value = self_get_int_value_for_col_name(self, i, "_glyph_size_prev");
    default:
      value = self_get_int_value_for_col_name(self, i, "_glyph_size");
  }
  
  return self_set_attr_glyph_size(self, i, value, brush);

}

/**
 * set_attr_glyph_size:
 * @self: #GGobiData
 * @i: row index
 * @brush: persistent or transient
 *
 * Sets glyph_size attribute to new value.
 * Returns: true if value has changed, false otherwise
**/
public gboolean
set_attr_glyph_size(self, guint i, gint value, GGobiDataAttrSetMethod brush)
{
  // This code is autogenerated, do not edit by hand
  if (brush == ATTR_SET_TRANSIENT ?
    (self_get_int_value_for_col_name(self, i, "_glyph_size_now") == value) :
    (self_get_int_value_for_col_name(self, i, "_glyph_size") == value))
    return false;

  if (brush == ATTR_SET_PERSISTENT) {
    self_set_int_value_for_col_name(self, i, "_glyph_size_prev", 
      self_get_int_value_for_col_name(self, i, "_glyph_size"));
    self_set_int_value_for_col_name(self, i, "_glyph_size", value);
  }

  self_set_int_value_for_col_name(self, i, "_glyph_size_now", value);
  return true;
}

/**
 * get_attr_glyph_size:
 * @self: #GGobiData
 * @i: row index
 * 
 * Retrieve current glyph_size
**/
public gint
get_attr_glyph_size(self, guint i)
{
  // This code is autogenerated, do not edit by hand
  return self_get_int_value_for_col_name(self, i, "_glyph_size_now");
}
/* [[[end]]] */

/**
 * reset_attr_glyph:
 * @self: #GGobiData 
 * @i: row index
 * @brush: persistent or transient
 *
 * Resets glyph attribute to previous value
**/
public gboolean
reset_attr_glyph(self, guint i, GGobiDataAttrSetMethod brush)
{
  gboolean changed = false;
  changed = self_reset_attr_glyph_size(self, i, brush) || changed;
  changed = self_reset_attr_glyph_type(self, i, brush) || changed;
  return changed;
}

/**
 * set_attr_glyph:
 * @self: #GGobiData
 * @i: row index
 * @brush: persistent or transient
 *
 * Sets glyph attribute to new value.
 * Returns: true if value has changed, false otherwise
**/
public gboolean
set_attr_glyph_parts(self, guint i, GlyphType type, guint size, GGobiDataAttrSetMethod brush)
{
    gboolean changed = false;
    changed = self_set_attr_glyph_size(self, i, type, brush) || changed;
    changed = self_set_attr_glyph_type(self, i, size, brush) || changed;
    return changed;
}

public gboolean
set_attr_glyph(self, guint i, glyphd* value, GGobiDataAttrSetMethod brush)
{
  return self_set_attr_glyph_parts(self, i, value->type, value->size, brush);
}

/**
 * get_attr_glyph:
 * @self: #GGobiData
 * @i: row index
 * 
 * Retrieve current glyph
**/
public glyphd* 
get_attr_glyph(self, guint i)
{
  glyphd* glyph = (glyphd*) g_malloc (sizeof (glyphd)); 
  glyph->type = self_get_attr_glyph_type(self, i);
  glyph->size = self_get_attr_glyph_size(self, i);
  return glyph;
}

public gboolean 
reset_attr(self, guint i, GGobiDataAttrSetMethod brush) {
  gboolean changed = false;
  changed = self_reset_attr_hidden(self, i, brush) || changed;
  changed = self_reset_attr_glyph(self, i, brush) || changed;
  changed = self_reset_attr_color(self, i, brush) || changed;
  
  return changed;
}

public gboolean
brush_point(self, guint i, gboolean condition, BrushTargetType brush_mode, GGobiDataAttrSetMethod brush) {
  if (condition) {
   switch (brush_mode) {
    case br_candg:
      self_set_attr_color(self, i, self->gg->color_id, brush);
      self_set_attr_glyph(self, i, &self->gg->glyph_id, brush);
      break;
    case br_color:
      self_set_attr_color(self, i, self->gg->color_id, brush);
      break;
    case br_glyph:
      self_set_attr_glyph(self, i, &self->gg->glyph_id, brush);
      break;
    case br_shadow:
      self_set_attr_hidden(self, i, true, brush);
      break;
    case br_unshadow:
      self_set_attr_hidden(self, i, false, brush);
      break;
    default:
      break;
    }
  } else if (brush == ATTR_SET_TRANSIENT) {  
    switch (brush_mode) {
    case br_candg:
      self_reset_attr_color(self, i, ATTR_SET_TRANSIENT);
      self_reset_attr_glyph(self, i, ATTR_SET_TRANSIENT);
      break;
    case br_color:
      self_reset_attr_color(self, i, ATTR_SET_TRANSIENT);
      break;
    case br_glyph:
      self_reset_attr_glyph(self, i, ATTR_SET_TRANSIENT);
      break;
    case br_unshadow:
    case br_shadow:
      self_reset_attr_hidden(self, i, ATTR_SET_TRANSIENT);
      break;
    default:
      break;
    }
  }
  return false;
}


/* [[[cog
   import cog, attraccessor
   cog.outl(attraccessor.column_accessor("boolean", "gboolean"))
   cog.outl(attraccessor.column_accessor("short", "gshort"))
   cog.outl(attraccessor.column_accessor("int", "gint"))
   ]]] */
/** 
 * get_boolean_value:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 *
 * Convenience method for getting boolean value.
 **/
public gboolean
get_boolean_value(self, guint i, guint j)
{
  // This code is autogenerated, do not edit by hand
  return (gboolean) self_get_raw_value(self, i, j);
}


/** 
 * get_boolean_values:
 * @self: #GGobiData
 * @i: row index
 *
 * Convenience method for creating a new array of type gboolean
 * from the specified column.
 **/
public gboolean*
get_boolean_values(self, guint j)
{
  // This code is autogenerated, do not edit by hand
  gboolean* values = g_new(gboolean, self->nrows);
  for (guint i = 0; i < self->nrows; i++)
    values[i] = self_get_boolean_value(self, i, j);
  return(values);
}

/** 
 * set_boolean_value:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 * @value: new value
 *
 * Convenience method for setting boolean value.
 **/
public void
set_boolean_value(self, guint i, guint j, gboolean value)
{
  // This code is autogenerated, do not edit by hand
  self_set_raw_value(self, i, j, (gdouble) value);
}

/** 
 * set_boolean_values:
 * @self: #GGobiData
 * @i: row index
 * @value: array of boolean of length self->nrows
 *
 * Convenience method for setting entire column of booleans.
 * Emits self_col_data_changed() signal.
 **/
public void
set_boolean_values(self, guint j, gboolean *values)
{
  // This code is autogenerated, do not edit by hand
  for (guint i = 0; i < self->nrows; i++) {
    self_set_boolean_value(self, i, j, values[i]);
  }
  self_col_data_changed(self, j);
}


/** 
 * get_boolean_value_for_col_name:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 *
 * Convenience method for getting boolean value.
 **/
public gboolean
get_boolean_value_for_col_name(self, guint i, gchar* name)
{
  // This code is autogenerated, do not edit by hand
  guint j = self_get_col_index_for_name(self, name);
  g_assert(j != -1);
  
  return self_get_boolean_value(self, i, j);
}


/** 
 * get_boolean_values_for_col_names:
 * @self: #GGobiData
 * @i: row index
 *
 * Convenience method for creating a new array of type gboolean
 * from the specified column.
 **/
public gboolean*
get_boolean_values_for_col_name(self, gchar* name)
{
  // This code is autogenerated, do not edit by hand
  guint j = self_get_col_index_for_name(self, name);
  g_assert(j != -1);
  
  return self_get_boolean_values(self, j);
}

/** 
 * set_boolean_value_for_col_name:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 * @value_for_col_name: new value_for_col_name
 *
 * Convenience method for setting boolean value.
 **/
public void
set_boolean_value_for_col_name(self, guint i, gchar* name, gboolean value)
{
  // This code is autogenerated, do not edit by hand
  guint j = self_get_col_index_for_name(self, name);
  g_assert(j != -1);
  
  self_set_boolean_value(self, i, j, value);
}

/** 
 * set_boolean_values_for_col_name:
 * @self: #GGobiData
 * @i: row index
 * @value_for_col_name: array of boolean of length self->nrows
 *
 * Convenience method for setting entire column of booleans.
 * Emits self_col_data_changed() signal.
 **/
public void
set_boolean_values_for_col_name(self, gchar* name, gboolean *values)
{
  // This code is autogenerated, do not edit by hand
  guint j = self_get_col_index_for_name(self, name);
  g_assert(j != -1);
  
  self_set_boolean_values(self, j, values);
}

/** 
 * get_short_value:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 *
 * Convenience method for getting short value.
 **/
public gshort
get_short_value(self, guint i, guint j)
{
  // This code is autogenerated, do not edit by hand
  return (gshort) self_get_raw_value(self, i, j);
}


/** 
 * get_short_values:
 * @self: #GGobiData
 * @i: row index
 *
 * Convenience method for creating a new array of type gshort
 * from the specified column.
 **/
public gshort*
get_short_values(self, guint j)
{
  // This code is autogenerated, do not edit by hand
  gshort* values = g_new(gshort, self->nrows);
  for (guint i = 0; i < self->nrows; i++)
    values[i] = self_get_short_value(self, i, j);
  return(values);
}

/** 
 * set_short_value:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 * @value: new value
 *
 * Convenience method for setting short value.
 **/
public void
set_short_value(self, guint i, guint j, gshort value)
{
  // This code is autogenerated, do not edit by hand
  self_set_raw_value(self, i, j, (gdouble) value);
}

/** 
 * set_short_values:
 * @self: #GGobiData
 * @i: row index
 * @value: array of short of length self->nrows
 *
 * Convenience method for setting entire column of shorts.
 * Emits self_col_data_changed() signal.
 **/
public void
set_short_values(self, guint j, gshort *values)
{
  // This code is autogenerated, do not edit by hand
  for (guint i = 0; i < self->nrows; i++) {
    self_set_short_value(self, i, j, values[i]);
  }
  self_col_data_changed(self, j);
}


/** 
 * get_short_value_for_col_name:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 *
 * Convenience method for getting short value.
 **/
public gshort
get_short_value_for_col_name(self, guint i, gchar* name)
{
  // This code is autogenerated, do not edit by hand
  guint j = self_get_col_index_for_name(self, name);
  g_assert(j != -1);
  
  return self_get_short_value(self, i, j);
}


/** 
 * get_short_values_for_col_names:
 * @self: #GGobiData
 * @i: row index
 *
 * Convenience method for creating a new array of type gshort
 * from the specified column.
 **/
public gshort*
get_short_values_for_col_name(self, gchar* name)
{
  // This code is autogenerated, do not edit by hand
  guint j = self_get_col_index_for_name(self, name);
  g_assert(j != -1);
  
  return self_get_short_values(self, j);
}

/** 
 * set_short_value_for_col_name:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 * @value_for_col_name: new value_for_col_name
 *
 * Convenience method for setting short value.
 **/
public void
set_short_value_for_col_name(self, guint i, gchar* name, gshort value)
{
  // This code is autogenerated, do not edit by hand
  guint j = self_get_col_index_for_name(self, name);
  g_assert(j != -1);
  
  self_set_short_value(self, i, j, value);
}

/** 
 * set_short_values_for_col_name:
 * @self: #GGobiData
 * @i: row index
 * @value_for_col_name: array of short of length self->nrows
 *
 * Convenience method for setting entire column of shorts.
 * Emits self_col_data_changed() signal.
 **/
public void
set_short_values_for_col_name(self, gchar* name, gshort *values)
{
  // This code is autogenerated, do not edit by hand
  guint j = self_get_col_index_for_name(self, name);
  g_assert(j != -1);
  
  self_set_short_values(self, j, values);
}

/** 
 * get_int_value:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 *
 * Convenience method for getting int value.
 **/
public gint
get_int_value(self, guint i, guint j)
{
  // This code is autogenerated, do not edit by hand
  return (gint) self_get_raw_value(self, i, j);
}


/** 
 * get_int_values:
 * @self: #GGobiData
 * @i: row index
 *
 * Convenience method for creating a new array of type gint
 * from the specified column.
 **/
public gint*
get_int_values(self, guint j)
{
  // This code is autogenerated, do not edit by hand
  gint* values = g_new(gint, self->nrows);
  for (guint i = 0; i < self->nrows; i++)
    values[i] = self_get_int_value(self, i, j);
  return(values);
}

/** 
 * set_int_value:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 * @value: new value
 *
 * Convenience method for setting int value.
 **/
public void
set_int_value(self, guint i, guint j, gint value)
{
  // This code is autogenerated, do not edit by hand
  self_set_raw_value(self, i, j, (gdouble) value);
}

/** 
 * set_int_values:
 * @self: #GGobiData
 * @i: row index
 * @value: array of int of length self->nrows
 *
 * Convenience method for setting entire column of ints.
 * Emits self_col_data_changed() signal.
 **/
public void
set_int_values(self, guint j, gint *values)
{
  // This code is autogenerated, do not edit by hand
  for (guint i = 0; i < self->nrows; i++) {
    self_set_int_value(self, i, j, values[i]);
  }
  self_col_data_changed(self, j);
}


/** 
 * get_int_value_for_col_name:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 *
 * Convenience method for getting int value.
 **/
public gint
get_int_value_for_col_name(self, guint i, gchar* name)
{
  // This code is autogenerated, do not edit by hand
  guint j = self_get_col_index_for_name(self, name);
  g_assert(j != -1);
  
  return self_get_int_value(self, i, j);
}


/** 
 * get_int_values_for_col_names:
 * @self: #GGobiData
 * @i: row index
 *
 * Convenience method for creating a new array of type gint
 * from the specified column.
 **/
public gint*
get_int_values_for_col_name(self, gchar* name)
{
  // This code is autogenerated, do not edit by hand
  guint j = self_get_col_index_for_name(self, name);
  g_assert(j != -1);
  
  return self_get_int_values(self, j);
}

/** 
 * set_int_value_for_col_name:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 * @value_for_col_name: new value_for_col_name
 *
 * Convenience method for setting int value.
 **/
public void
set_int_value_for_col_name(self, guint i, gchar* name, gint value)
{
  // This code is autogenerated, do not edit by hand
  guint j = self_get_col_index_for_name(self, name);
  g_assert(j != -1);
  
  self_set_int_value(self, i, j, value);
}

/** 
 * set_int_values_for_col_name:
 * @self: #GGobiData
 * @i: row index
 * @value_for_col_name: array of int of length self->nrows
 *
 * Convenience method for setting entire column of ints.
 * Emits self_col_data_changed() signal.
 **/
public void
set_int_values_for_col_name(self, gchar* name, gint *values)
{
  // This code is autogenerated, do not edit by hand
  guint j = self_get_col_index_for_name(self, name);
  g_assert(j != -1);
  
  self_set_int_values(self, j, values);
}

/* [[[end]]] */

}