%h{

  #include "defines.h"
  #include "brushing.h"
  #include "vartable.h"
  #include "fileio.h"
  
  #include <gtk/gtk.h>
  
  typedef struct _Subset {
    gint random_n;
    gint string_pos;
   /*-- adjustments from which to get values for blocksize, everyn --*/
    GtkAdjustment *bstart_adj, *bsize_adj;
    GtkAdjustment *estart_adj, *estep_adj;
  } Subset;


  typedef struct _Jitterd {
    gfloat factor;
    gboolean type;
    gboolean convex;
    gfloat *jitfacv;
  } Jitterd;

  typedef struct _Varpanel_cboxd {
    GtkWidget *ebox;   /*-- child1 of pane widget --*/
    GtkWidget *swin;   /*-- child of ebox --*/
    GtkWidget *vbox;   /*-- child of swin --*/
    GSList *box;       /*-- single column of hboxes --*/
  } Varpanel_cboxd;

  typedef struct _Varpanel_circd {
    GtkWidget *ebox;        /*-- child2 of pane widget --*/
    GtkWidget *vbox;        /*-- child of ebox --*/
    GtkWidget *swin, *hbox; /*-- children of vbox --*/
    GtkWidget *table;       /*-- sole child of swin; now a vbox --*/
    GtkWidget *manip_btn, *freeze_btn; /*-- children of hbox --*/

    GdkCursor *cursor;
    gint jcursor;

   /*-- components and properties of the table --*/
    GSList *vb, *da, *label;
    GSList *da_pix;         /*-- backing pixmaps --*/
    gint nvars;
  } Varpanel_circd;

  typedef struct _Varpaneld {
    GtkWidget *hpane;  /*-- child of the ebox --*/
  } Varpaneld;

  /*-------------------- transformation --------------------------------*/

  /* sphering transformation */
  typedef struct _Sphere_d {
    vector_i vars;        /*-- vars available to be sphered --*/
    vector_i vars_sphered;/*-- vars that have been sphered --*/
    gint npcs;      /*-- the first npcs vars of vars will be sphered --*/
    vector_i pcvars;/*-- vars into which sphered data is written --*/

    vector_f eigenval;
    array_d eigenvec;
    array_f vc;
    vector_f tform_mean;
    vector_f tform_stddev;

    gboolean vars_stdized;
  } Sphere_d;


  typedef struct _EdgeData {
    gint n;
    SymbolicEndpoints *sym_endpoints;
    GList *endpointList;   
      /* a list of endpointsd elements corresponding to the resolved 
         record ids relative to a given datad. This is akin to a table
         indexed by datad elements. */

    gint nxed_by_brush;
    vector_b xed_by_brush;
  } EdgeData;

  typedef struct _BrushBins {
    gint nbins;
    bin_struct **binarray;
    icoords bin0, bin1;
  } BrushBins;
  
  
%}

%{
  #include "vars.h"
  #include "externs.h"
%}

class GGobi:Data from G:Object {
  
  
  /* Holds the name given to the dataset in an XML file and by which it
     can be indexed in the list of data elements within the ggobid structure.
   */
  public const gchar *name;
  public const gchar *nickname;
  public InputDescription *input;

  public struct _ggobid *gg; /*-- a pointer to the parent --*/

  public guint nrows;
  public GArray *rowlab; /*-- allocates memory in chunks --*/

  /*-- row ids to support generalized linking --*/
  public GHashTable *idTable;
  public char **rowIds;


  public Subset  subset;
  public Jitterd  jitter;
  public Varpanel_cboxd  vcbox_ui;
  public Varpanel_circd  vcirc_ui;
  public Varpaneld  varpanel_ui;
  public Sphere_d  sphere;
  public EdgeData  edge;
  public BrushBins  brush;
  
  
  /*-- to support brushing by categorical variable --*/
  public vartabled *linkvar_vt;  /*-- the linking variable --*/
  /*-- --*/

  public gint ncols;
  public GSList *vartable;
  public GtkWidget *vartable_tree_view[all_vartypes];
  public GtkTreeModel *vartable_tree_model; /* the root model, with all vars */

  public array_f raw;
  public array_f tform;
  public array_g world;
  public array_g jitdata;

  /*----------------------- missing values ---------------------------*/

  public gint nmissing;
  public array_s missing; /*-- array of shorts --*/
  public gboolean missings_show_p; /*-- show/hide per datad, not per display --*/

  /*---------------- deleting the hidden points; subsetting ----------*/

  public vector_i rows_in_plot;  /*-- always of length self->nrows --*/
  public gint nrows_in_plot;     /*-- how many elements of rows_in_plot to use --*/
  public vector_b sampled;
  public vector_b excluded;

  
  

  /*--------------- clusters: hiding, excluding ----------------------*/

  public symbol_cell symbol_table[NGLYPHTYPES][NGLYPHSIZES][MAXNCOLORS];

  public GtkWidget *cluster_table; /*-- table of symbol groups from brushing --*/

  public gint nclusters;
  public clusterd *clusv;
  public clusteruid *clusvui;
  public vector_i clusterid;  /* cluster membership for each record */

  /*------------------------ jittering --------------------------------*/


  /*------------------------ brushing ----------------------------------*/

  /*-- it's odd to have these in datad; let me think about that --*/
  public gint npts_under_brush;
  public vector_b pts_under_brush;

  /*-- --*/

  public vector_s color;
  public vector_s color_now; 
  public vector_s color_prev;
  public vector_b hidden;
  public vector_b hidden_now;
  public vector_b hidden_prev;
  public vector_g glyph;
  public vector_g glyph_now;
  public vector_g glyph_prev;


  /*---------------------- identification ------------------------------*/

  /*-- used in identification, line editing, and point motion --*/
  public gint nearest_point;
  public gint nearest_point_prev;
  public GSList *sticky_ids;

  /*-------------------- moving points ---------------------------------*/

  public GSList *movepts_history; /*-- a list of elements of type celld --*/

  property UINT nrows 
    (nick = "nrows", blurb = "Number of rows in the dataset",
     minimum = 0, maximum = INT_MAX, default_value = 0,
     flags = CONSTRUCT_ONLY, link, export);
  property UINT ncols 
    (nick = "ncols", blurb = "Number of cols in the dataset",
     minimum = 0, maximum = INT_MAX, default_value = 0,
     flags = CONSTRUCT_ONLY, link, export);
     
  signal private NONE (INT, INT, POINTER) void rows_in_plot_changed(self, int arg1, int arg2, ggobid* arg3);
  
  init (self) {
    sphere_init(self); 

    self->nearest_point = -1;
    self->missings_show_p = true;
  }
  
  override (G:Object) GObject*
  constructor (GType type, guint n_construct_properties, GObjectConstructParam *construct_properties)
  {
    GGobiData* d = (GGobiData*) PARENT_HANDLER(type, n_construct_properties, construct_properties);
    /* we can put these here OR we can put them in the setter for the 'ncols'
       property, since we know that comes last (after 'nrows' has been set) */
    
    d->nrows_in_plot = d->nrows;  /*-- for now --*/

	  arrayf_alloc (&d->raw, d->nrows, d->ncols); //FIXME: probably leaks memory
	  arrays_alloc_zero (&d->missing, d->nrows, d->ncols);

    rowlabels_alloc (d);

    vartable_alloc (d);
    vartable_init (d);

    br_glyph_ids_alloc (d);
    br_glyph_ids_init (d);

    br_color_ids_alloc (d);
    br_color_ids_init (d);

    br_hidden_alloc (d);
    br_hidden_init (d);

    return((GObject *)d);
  }
  
  public GGobiData* new(guint nrows, guint ncols)
  {
    GGobiData* d = (GGobiData*) g_object_new(GGOBI_TYPE_DATA, "ncols", ncols, "nrows", nrows, NULL);
    return(d);
  }
  
  /* General comments: 
    1) the (broken) datad_free function may not be necessary, since we can specify
       finalizers for all the fields using GOB
    2) the (evil) datad_init function must be vanquished asap
    3) an API needs to be defined for populating a dataset
    ...
  */


  public gchar *
  get_name (self)
  {
    gchar *lbl;
    if (self->name && self->name[0])
      lbl = g_strdup(self->name);
    else
      lbl = g_strdup("unknown");

    return (lbl);
  }
  
  public void
  set_name (self, const gchar *name)
  {
  	self->name = g_strdup(name);
  }
 
 
  /**
   * set_missing:
   * 
   * Set specified cell to be a missing value
   */
  public void
  set_missing (self, int i, int j)
  {
    vartabled *vt = vartable_element_get (j, self);
    
    if (self->nmissing == 0) {
      arrays_alloc (&self->missing, self->nrows, self->ncols);
      arrays_zero (&self->missing);
    }
    self->missing.vals[i][j] = 1;
    self->raw.vals[i][j] = 0;

    vt->nmissing++;
    self->nmissing++;
  }
  
}


%h{

  void datad_instance_init(GGobiData * d);

  void freeLevelHashEntry(gpointer key, gpointer value, gpointer data);

  /*-- used as an attribute of variable notebooks --*/
  typedef enum {no_edgesets, edgesets_only, all_datatypes} datatyped;

  extern endpointsd *resolveEdgePoints(GGobiData *e, GGobiData *d);
  void unresolveAllEdgePoints(GGobiData *e);

  void datad_record_ids_set(GGobiData *d, gchar **ids, gboolean duplicate);
  void ggobi_data_set_integer_column(GGobiData *d, gint j, gint *values);
  void ggobi_data_set_double_column(GGobiData *d, gint j, gdouble *values);
  void ggobi_data_set_row_labels(GGobiData *d, gchar **labels);
%}

%{
  void
  datad_free (GGobiData *d, ggobid *gg) 
  {
    arrayf_free (&d->raw, 0, 0);
    pipeline_arrays_free (d, gg);

    if (d->nmissing)
      arrays_free (&d->missing, 0, 0);

     /* rowIds and idTable are intrinsically linked !*/
    if(d->idTable) {
      g_hash_table_foreach(d->idTable, freeLevelHashEntry, d->idTable);
      g_hash_table_destroy(d->idTable); 
    }

    if(d->rowIds) 
      g_free(d->rowIds);

    g_free (d);
  }

  displayd *
  datad_init (GGobiData *d, ggobid *gg, gboolean cleanup)
  {
    d->gg = gg;
    gg->d = g_slist_append (gg->d, d);
    displayd *display = NULL;

    if (cleanup) {
      varpanel_clear (d, gg);
    }

    varpanel_populate (d, gg);   /*-- toggles */
    /*-- circles: build but don't show --*/
    varcircles_populate (d, gg);

    pipeline_init (d, gg);
    clusters_set (d, gg);  /*-- find the clusters for data just read in --*/

    if (cleanup || g_list_length(gg->displays) == 0) {
      display_free_all (gg);  /*-- destroy any existing displays --*/
      gg->pmode = NULL_PMODE;

      /*-- initialize the first display --*/
      if(sessionOptions->info->createInitialScatterPlot && d->ncols > 0) {
  /*XXX allow this to be specified as a gtk type name on the command
        line, initialization file, etc.  and invoke the corresponding
        create() method. */
        display = scatterplot_new (false, NULL, d, gg);
          /* Need to make certain this is the only one there. */

        if (display != NULL) {
          gg->displays = g_list_append (gg->displays, (gpointer) display);
  	    gg->current_splot = (splotd *)
          	g_list_nth_data (display->splots, 0);
          display->current_splot = gg->current_splot;
          display_set_current (display, gg);

          /*-- turn on event handling in the very first plot --*/
          /*-- ... but will it cause trouble for later plots?  ok so far
  	  --*/
  	/* Is imode set yet?  I hope so. */
          sp_event_handlers_toggle (gg->current_splot, on, gg->pmode, gg->imode);
        }
      }
    }

    if (gg->current_display != NULL)
      varpanel_refresh (gg->current_display, gg);

    if (g_slist_index(gg->d, (gpointer)d) == 0)
      varpanel_set_sensitive (d, true, gg);

    g_signal_emit (G_OBJECT (gg), GGobiSignals[DATAD_ADDED_SIGNAL], 0, d);

    display_menu_build (gg);

    return (display);
  }

  /* This initializes rowIds to row numbers if ids are not provided */
  void
  datad_record_ids_set(GGobiData *d, gchar **ids, gboolean duplicate)
  {
    gint i;
    guint *index;
    gchar *tmp;

    d->idTable = g_hash_table_new(g_str_hash, g_str_equal);
    d->rowIds = (gchar **) g_malloc(sizeof(gchar *) * d->nrows);
    for(i = 0; i < d->nrows; i++) {
       if(ids)
         tmp = duplicate ? g_strdup(ids[i]) : ids[i];
       else {
         char buf[10];
         sprintf(buf, "%d", i+1);
         tmp = g_strdup(buf);
       }
       index = (guint *) g_malloc(sizeof(guint));
       *index = i;
       g_hash_table_insert(d->idTable, tmp, index);
       d->rowIds[i] = tmp;     
       /* do not free anything here */
    }
  }

  /* Add a record id */
  void
  datad_record_id_add (gchar *id, GGobiData *d)
  {
    gint i;
    guint *index;

    d->rowIds = (gchar **) g_realloc (d->rowIds, sizeof(gchar *) * d->nrows);
    i = d->nrows - 1;

    index = (guint *) g_malloc(sizeof(guint));
    *index = i;
    g_hash_table_insert (d->idTable, id, index);
    d->rowIds[i] = id;

  /*
   * I don't really understand why I can't free this
   * when it's freed in datad_record_ids_set, but purify is
   * quite clear on this point.  -- dfs
  */
    /*g_free (index);*/
  }

  void
  ggobi_data_set_integer_column(GGobiData *d, gint j, gint *values)
  {
  	gint i;
  	vartabled *vt = vartable_element_get(j, d);
  	for (i = 0; i < d->nrows; i++) {
  		gint value = values[i];
  		if (vt->vartype == categorical) {
  			gint level = checkLevelValue(vt, value);
  			vt->level_counts[level]++;
  		}
  		if(GGobiMissingValue && GGobiMissingValue(value))
           ggobi_data_set_missing(d, i, j);
          else d->raw.vals[i][j] = (gdouble)value;
  	}
  }
  void
  ggobi_data_set_double_column(GGobiData *d, gint j, gdouble *values)
  {
  	gint i;
  	vartabled *vt = vartable_element_get(j, d);
  	for (i = 0; i < d->nrows; i++) {
  		if(GGobiMissingValue && GGobiMissingValue(values[i]))
           ggobi_data_set_missing(d, i, j);
          else d->raw.vals[i][j] = values[i];
  	}
  }

  /* FIXME: this only works the first time */
  void
  ggobi_data_set_row_labels(GGobiData *d, gchar **labels)
  {
  	gint i;
  	for (i = 0; i < d->nrows; i++) {
  		gchar *label;
  		if (labels && labels[i])
  			label = g_strdup(labels[i]);
  		else label = g_strdup_printf("%d", i);
  		g_array_append_val(d->rowlab, label);
  	}
  }



  /*
   * Several tables use notebook widgets to separate the controls
   * corresponding to different datad's.  This is a way to figure
   * out which datad we should be operating on in that case.
  */
  GGobiData*
  datad_get_from_notebook (GtkWidget *notebook, ggobid *gg) {
    GGobiData *d = NULL;
    gint nd = g_slist_length (gg->d);

    if (nd == 1) {
      d = gg->d->data;
    } else {
      GtkNotebook *nb = GTK_NOTEBOOK (notebook);
      gint indx = gtk_notebook_get_current_page (nb);
      GtkWidget *page = gtk_notebook_get_nth_page (nb, indx);

      /*
       * Assume that each notebook page has a datad attached.
      */
      if (page) {
        d = g_object_get_data (G_OBJECT(page), "datad");
      }

      /*
       * k indexes gg->d
       * n indexes the notebook pages, so it increments only if d has variables
      */
  /*
      gint k, n;
    datatyped dtype;
      dtype = (vartyped) g_object_get_data(G_OBJECT(notebook), "datatype");
      for (k = 0, n = 0; k < nd; k++) {
        d = (GGobiData *) g_slist_nth_data (gg->d, k);

        if ((dtype == all_datatypes) ||
            (dtype == no_edgesets && d->edge.n == 0) ||
            (dtype == edgesets_only && d->edge.n > 0))
        {
          if (datad_has_variables(d)) {
            if (n == indx)
               return (d);
            n++;
          }
        }
      }
    return ((GGobiData *) NULL);
  */
    }

    return d;
  }

  gint
  ndatad_with_vars_get (ggobid *gg)
  {
    gint nd;
    GSList *l;
    GGobiData *d;

    /*-- silly to do this every time, perhaps, but harmless, I think --*/
    if (g_slist_length (gg->d) > 1) {
      nd = 0;
      for (l = gg->d; l; l = l->next) {
        d = (GGobiData *) l->data;
        if (g_slist_length (d->vartable) > 0)
          nd++;
      }
    }  else nd = 1;

    return nd;
  }



  gboolean datad_has_edges (GGobiData *d) 
  {
    return (d->edge.n > 0);
  }

  gboolean datad_has_variables (GGobiData *d) 
  {
    return (d->ncols > 0);
  }


  /*------------------------------------------------------------------------*/
  /*                          row labels                                    */
  /*------------------------------------------------------------------------*/

  void 
  rowlabels_free (GGobiData *d)
  {
    g_array_free (d->rowlab, true);
  }


  void
  rowlabels_alloc (GGobiData *d) 
  {
    if (d->rowlab != NULL) rowlabels_free (d);
    d->rowlab = g_array_sized_new (false, false, sizeof (gchar *), d->nrows);
  }

  void
  rowlabel_add (gchar *label, GGobiData *d) 
  {
    g_array_append_val (d->rowlab, label);

    g_assert (d->rowlab->len == d->nrows);
  }
  
  
%}
