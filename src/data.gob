%h{

#include "ggobi-variable.h"
#include "ggobi-stage.h"
#include "fileio.h"

#include <math.h>

/* used for variable notebooks - this will go in variable_nbook.h */
typedef enum {no_edgesets, edgesets_only, all_datatypes} datatyped;

%}

%{
#include "vars.h"
#include "externs.h"
%}

/**
 * SECTION:GGobiData
 * @short_description: Basic data storage and manipulation class.
 * @stability: Unstable
 *
 * The GGobiData class provides all methods for manipulating 
 * data within GGobi.  It is the starting point for the pipeline.
 * 
 * Eventually this will become an abstract class and subclass will
 * provide the actual implementation.  This will make it easy to treat
 * an R data frame, or a SQL query as the data source for GGobi.
 */
class GGobi:Data from GGobi:Stage {

public gchar *nickname;
property STRING nickname
  (nick = "alias", blurb = "The nickname of the dataset",
   default_value = "dataset", link, export);

/* A description of the source of the GGobiData */
// FIXME: this should be a boxed type and the field private
public InputDescription *input;

/* The actual data in this default implementation */
protected array_f raw;
/* Tracking missing values per cell */
protected array_s missing; 

/* Maps row labels to row indices */
protected GHashTable* idTable;

/* The row ids */
protected gchar **rowIds;

/* We'll fix edge/polygon stuff after pipeline */
protected EdgeData  edge;

init(self) {
  ggobi_stage_set_name(GGOBI_STAGE(self), "unknown");
  self->idTable = g_hash_table_new(g_str_hash, g_str_equal);
}

/** 
 * new:
 * @nrows: number of rows
 * @ncols: number of columns
 *
 * Create new #GGobiData object
 * 
 * Returns: #GGobiData object
 **/
public GGobiData* 
new(guint nrows, guint ncols)
{
  GObject* d = (GObject *)GET_NEW;
  self_add_cols(GGOBI_DATA(d), ncols);
  self_add_rows(GGOBI_DATA(d), nrows);

  return(GGOBI_DATA(d));
}

// FIXME: this stuff is _G_Gobi-specific, so it has to be added to every
// GGobiData that participates in _G_Gobi, regardless of source.
// Thus, this should probably be done when the GGobiData is added to the 
// GGobiApp (ggobid) object.
public void
add_attributes(self) {
  GGobiStage *stage = GGOBI_STAGE(self);
  gdouble def_color = (gdouble) (stage->gg ? stage->gg->color_id : 0);
  gdouble def_type  = (gdouble) (stage->gg ? stage->gg->glyph_id.type : FC);
  gdouble def_size =  (gdouble) (stage->gg ? stage->gg->glyph_id.size : 1);
  
  // FIXME: we set the default value here, even though the ggobid fields
  // change to match the current brush colour
  self_add_attribute(self, "_color", def_color);
  self_add_attribute(self, "_color_now", def_color);
  self_add_attribute(self, "_color_prev", def_color);

  self_add_attribute(self, "_size", def_size);
  self_add_attribute(self, "_size_now", def_size);
  self_add_attribute(self, "_size_prev", def_size);

  self_add_attribute(self, "_type", def_type);
  self_add_attribute(self, "_type_now", def_type);
  self_add_attribute(self, "_type_prev", def_type);

  self_add_attribute(self, "_hidden", 0);
  self_add_attribute(self, "_hidden_now", 0);
  self_add_attribute(self, "_hidden_prev", 0);

  self_add_attribute(self, "_cluster", 0);
  self_add_attribute(self, "_sampled", (gdouble) true);
  self_add_attribute(self, "_excluded", 0);

} 

/**
 * add_attribute:
 * @self: GGobiData object
 * @i: attribute name (should begin with _)
 * @j: default value
 *
 * Adds a new attribute column with specified name and default value.
 *
 * FIXME: should automatically check if attribute is already present
 **/
public void 
add_attribute(self, const gchar* name, gdouble value) {
  GGobiStage *stage = GGOBI_STAGE(self);

  if (ggobi_stage_get_col_index_for_name(stage, name) != -1)
    return;
  
  guint j = self_add_cols(self, 1);
  stage->n_attributes += 1;

  ggobi_stage_set_col_name(stage, j, name);
  self_set_col_default_value(self, j, value);	
  
  for(guint i = 0; i < ggobi_stage_get_n_rows(stage); i++) {
    ggobi_stage_set_raw_value(stage, i, j, value);
  }

  GGobiVariable* vt = ggobi_stage_get_variable(stage, j);
  vt->is_attribute = true;
}

public void 
set_col_default_value(self, guint j, gdouble value)
{
  GGobiVariable* vt = ggobi_stage_get_variable(GGOBI_STAGE(self), j);
  ggobi_variable_set_default_value(vt, value);
}

public gdouble
get_col_default_value(self, guint j)
{
  GGobiVariable* vt = ggobi_stage_get_variable(GGOBI_STAGE(self), j);
  return ggobi_variable_get_default_value(vt);
}



/**
 * set_missing:
 * @self: GGobiData object
 * @i: row index
 * @j: column index
 *
 * Set specified cell to be a missing value.  
 * If the variable is categorical, a new level value ("MISSING")
 * will be created, and the raw value set to that.
 **/
override (GGobi:Stage) void
set_missing(GGobi:Stage *self (check null type), guint i, guint j)
{
  // FIXME: would be nice to treat all variables types the same wrt missingness
  if (GGOBI_STAGE_IS_COL_CATEGORICAL(self, j)) {
    ggobi_stage_set_categorical_value(self, i, j, "MISSING");
    return;
  }
  SELF(self)->raw.vals[i][j] = 0;
  SELF(self)->missing.vals[i][j] = 1;
}


/**
 * is_missing:
 * @self: GGobiData object
 * @i: row index
 * @j: column index
 *
 * Returns: if value at specified positive is missing or not
 **/
override (GGobi:Stage) gboolean
is_missing(GGobi:Stage *self, guint i, guint j) 
{
  return (SELF(self)->missing.vals[i][j] == 1);  
}

/**
 * set_raw_value:
 * @self: GGobiData object
 * @i: row index
 * @j: column index
 * @values: vector of new values, of length self->nrows
 * 
 * Sets a single value in the specified column.  
 *
 * This will set missing values if necessary and sets
 * tform value as well to keep dataset consistent.
 *
 * You need to manually emits self_col_data_changed() signal after
 * using this function if you want the data to continue down the pipeline.
 **/
override (GGobi:Stage) void
set_raw_value(GGobi:Stage *self (check null type), guint i, guint j, gdouble value)
{
  if(GGobiMissingValue && GGobiMissingValue(value))
    ggobi_stage_set_missing(self, i, j);
  else {
    SELF(self)->raw.vals[i][j] = value;
    SELF(self)->missing.vals[i][j] = 0;
    self->tform.vals[i][j] = value;
  }
}

/** 
 * get_raw_value:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 **/
override (GGobi:Stage) gdouble
get_raw_value(GGobi:Stage *self (check null type), guint i, guint j)
{
  return SELF(self)->raw.vals[i][j];
}

public void 
set_col_type(self, guint j, GGobiVariableType value)
{
  GGobiVariable *vt = ggobi_stage_get_variable(GGOBI_STAGE(self), j);
  ggobi_variable_set_vartype(vt, value);
}

override (GGobi:Stage) guint
get_n_edges (GGobiStage *self)
{
  return SELF(self)->edge.n; 
}

override (GGobi:Stage) EdgeData *
get_edge_data (GGobiStage *self)
{
  return &(SELF(self)->edge);
}

/** 
 * set_row_id:
 * @self: #GGobiData object
 * @i: row
 * @value: new string value for row id
 * @check: throw error if id is already used?
 *
 * Set the row id (a string) for specified row
 * A row id is a unique string reference to a given row.
 * These are hashed for O(1) lookup.
 **/ 
override (GGobi:Stage) void
set_row_id(GGobiStage *self, guint i, gchar* value, gboolean check) {
  if (value == NULL)
    value = g_strdup_printf("%d", i+1);

  //g_return_if_fail(check && self_get_row_for_id(self, value) == -1);

  SELF(self)->rowIds[i] = g_strdup(value);
  g_hash_table_replace (SELF(self)->idTable, SELF(self)->rowIds[i], GINT_TO_POINTER(i));
}

/** 
 * get_row_id:
 * @self: #GGobiData object
 * @i: row
 * 
 * Retrive row id for specified row.
 * Returns: duplicate of row id if present, NULL otherwise
 **/
override (GGobi:Stage) gchar*
get_row_id(GGobi:Stage *self, guint i) {
  if (SELF(self)->rowIds[i]) 
    return g_strdup(SELF(self)->rowIds[i]);
  else
    return NULL;
}

/** 
 * get_row_for_id:
 * @self: #GGobiData object
 * @id: row id string
 * 
 * Get row index corresponding to row id
 *
 * Returns: row index if found, -1 otherwise
 **/
override (GGobi:Stage) gint
get_row_for_id(GGobi:Stage *self, gchar *id) {
  gpointer pos, key;
  if (id && g_hash_table_lookup_extended(SELF(self)->idTable, id, &key, &pos))
    return GPOINTER_TO_INT(pos);
  return -1;
}

/**
 * add_rows: 
 * @self: #GGobiData object
 * @n: number of rows to add
 *
 * Add n rows to the dataset
 * Adds extra rows, allocating space as needed.
 *
 * This emits the cols_added signal and also runs
 * #set_rows_in_plot which emits the rows_in_plot_changed signal.
 *
 * Returns: index of first new row
 **/
 // FIXME: This code should be the default handler for the n_rows property.
 // Then this function would just increment that property.
 // -- We won't be able to set the property if we make it read-only in the
 //    stage. In that case, this is probably OK.
public guint
add_rows(self, guint n) {
  guint i, nprev = GGOBI_STAGE(self)->n_rows;
  guint nrows = nprev + n;
  
  self->rowIds = (gchar **) g_realloc (self->rowIds, sizeof(gchar *) * nrows);

  arrayf_add_rows (&self->raw, nrows);
  arrays_add_rows (&self->missing, nrows);

  if (ggobi_stage_get_n_edges(GGOBI_STAGE(self)))
    vectorb_realloc (&self->edge.xed_by_brush, self->edge.n);

  for (i = nprev; i < nrows; i++) {    
    self->rowIds[i] = NULL;
  }
  
  ggobi_stage_rows_added(GGOBI_STAGE(self), n);
  self_reset_rows(self, nprev, nrows);
  /* set default values here */
  // FIXME: this can probably be moved before rows_added emission and not
  // emit col_data_changed, once we have tform stage in place
  
  return nprev;
}

/**
 * reset_rows:
 * @self: #GGobiData object
 * @from: row index to start at
 * @to: row index to end at
 *
 * Resets values to their defaults for the specified 
 * rows.  This is mainly used to set default values for 
 * the attributes at the moment.
 **/ 
public void
reset_rows(self, guint from, guint to) {
  for (guint j = 0; j < GGOBI_STAGE(self)->n_cols; j++) {
    gdouble default_val = self_get_col_default_value(self, j);
    for (guint i = from; i < to; i++)
      ggobi_stage_set_raw_value(GGOBI_STAGE(self), i, j, default_val);
    ggobi_stage_col_data_changed(GGOBI_STAGE(self), j);
  }
}

/**
 * add_cols:
 * @self: #GGobiData object
 * @n: number of columns to add
 *
 * Add n empty columns to the dataset.
 * Returns: index of first new column
 **/ 
 // FIXME: This code should be the default handler for the n_cols property.
 // Then this function would just increment that property.
 // -- or not, see above
public guint 
add_cols(self, guint n) {
  guint nprev = GGOBI_STAGE(self)->n_cols;
  guint ncols = nprev + n;
  
  arrayf_add_cols (&self->raw, ncols);
  arrays_add_cols (&self->missing, ncols);

  ggobi_stage_cols_added(GGOBI_STAGE(self), n);
  
  return nprev;
}

public guint
delete_cols(self, guint *cols, gint ncols)
{
  gint j;
  gint *keepers, nkeepers, old_ncols = GGOBI_STAGE(self)->n_cols;
  
  g_return_val_if_fail(ncols < old_ncols, old_ncols);

  // FIXME: shouldn't find_keepers be able to handle this allocation??
  keepers = g_malloc ((old_ncols - ncols) * sizeof (gint));
  nkeepers = find_keepers (old_ncols, ncols, (gint *) cols, keepers);
  if (nkeepers == -1) {
    g_free (keepers);
    g_return_val_if_reached(old_ncols);
  }
  
  for (j = 0; j < nkeepers; j++) {
    GGobiVariable *vt = ggobi_stage_get_variable(GGOBI_STAGE(self), keepers[j]);
    ggobi_stage_set_variable(GGOBI_STAGE(self), j, vt);
  }

  arrayf_delete_cols (&self->raw, ncols, (gint *) cols);
  arrays_delete_cols (&self->missing, ncols, (gint *) cols);
  
  g_object_set(G_OBJECT(self), GGOBI_STAGE_PROP_N_COLS(old_ncols - ncols), NULL);
  for (j = 0; j < ncols; j++) /* emit col deleted signal */
    ggobi_stage_col_deleted(GGOBI_STAGE(self), cols[j]);
  
  /*-- emit a single variable_list_changed signal when finished --*/
  /*-- doesn't need to give a variable index any more, really --*/
  // FIXME: emission of this is deprecated
/*  g_signal_emit_by_name(self->gg, "variable_list_changed", 0, self);*/

    /*-- run the first part of the pipeline  --*/
           
  g_free (keepers);
  
  return(GGOBI_STAGE(self)->n_cols);
}
}