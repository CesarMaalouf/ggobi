%h{

#include "defines.h"
#include "brushing.h"
#include "ggobi-variable.h"
#include "ggobi-stage.h"
#include "fileio.h"

#include <gtk/gtk.h>
#include <math.h>

typedef enum {no_edgesets, edgesets_only, all_datatypes} datatyped;

typedef struct _Subset {
  gint random_n;
  gint string_pos;
 /*-- adjustments from which to get values for blocksize, everyn --*/
  GtkAdjustment *bstart_adj, *bsize_adj;
  GtkAdjustment *estart_adj, *estep_adj;
} Subset;


typedef struct _Jitterd {
  gfloat factor;
  gboolean type;
  gboolean convex;
  gfloat *jitfacv;
} Jitterd;

typedef struct _Varpanel_cboxd {
  GtkWidget *ebox;   /*-- child1 of pane widget --*/
  GtkWidget *swin;   /*-- child of ebox --*/
  GtkWidget *vbox;   /*-- child of swin --*/
  GSList *box;       /*-- single column of hboxes --*/
} Varpanel_cboxd;

typedef struct _Varpanel_circd {
  GtkWidget *ebox;        /*-- child2 of pane widget --*/
  GtkWidget *vbox;        /*-- child of ebox --*/
  GtkWidget *swin, *hbox; /*-- children of vbox --*/
  GtkWidget *table;       /*-- sole child of swin; now a vbox --*/
  GtkWidget *manip_btn, *freeze_btn; /*-- children of hbox --*/

  GdkCursor *cursor;
  gint jcursor;

 /*-- components and properties of the table --*/
  GSList *vb, *da, *label;
  GSList *da_pix;         /*-- backing pixmaps --*/
  gint nvars;
} Varpanel_circd;

typedef struct _Varpaneld {
  GtkWidget *hpane;  /*-- child of the ebox --*/
} Varpaneld;

/*-------------------- transformation --------------------------------*/

/* sphering transformation **/
typedef struct _Sphere_d {
  vector_i vars;        /*-- vars available to be sphered --*/
  vector_i vars_sphered;/*-- vars that have been sphered --*/
  gint npcs;      /*-- the first npcs vars of vars will be sphered --*/
  vector_i pcvars;/*-- vars into which sphered data is written --*/

  vector_f eigenval;
  array_d eigenvec;
  array_f vc;
  vector_f tform_mean;
  vector_f tform_stddev;

  gboolean vars_stdized;
} Sphere_d;


typedef struct _EdgeData {
  gint n;
  SymbolicEndpoints *sym_endpoints;
  GList *endpointList;   
    /* a list of endpointsd elements corresponding to the resolved 
       record ids relative to a given datad. This is akin to a table
       indexed by datad elements. **/

  gint nxed_by_brush;
  vector_b xed_by_brush;
} EdgeData;

typedef struct _BrushBins {
  gint nbins;
  bin_struct **binarray;
  /*
   * bin0 is the bin which contains of the upper left corner of the
   * brush; bin1 is the one containing of the lower right corner.
  */  
  icoords bin0, bin1;
} BrushBins;


%}

%{
#include "vars.h"
#include "externs.h"
%}


enum ATTR_SET {
  PERSISTENT,
  TRANSIENT
} GGobiData:AttrSetMethod;

/**
 * SECTION:GGobiData
 * @short_description: Basic data storage and manipulation class.
 * @stability: Unstable
 *
 * The GGobiData class provides all methods for manipulating 
 * data within GGobi.  It is the starting point for the pipeline.
 * 
 * Eventually this will become an abstract class and subclass will
 * provide the actual implementation.  This will make it easy to treat
 * an R data frame, or a SQL query as the data source for GGobi.
 */
class GGobi:Data from GGobi:Stage {

  // FIXME: make these fields private or get rid of them!
public gchar *nickname;
property STRING nickname
  (nick = "alias", blurb = "The nickname of the dataset",
   default_value = "dataset", link, export);
   
public InputDescription *input;

public guint nattributes = 0;

public gboolean missings;

public struct _ggobid *gg; /*-- a pointer to the parent --*/

/* GUI related */
public Subset  subset;
public Jitterd  jitter;
public Varpanel_cboxd  vcbox_ui;
public Varpanel_circd  vcirc_ui;
public Varpaneld  varpanel_ui;
public Sphere_d  sphere;
public EdgeData  edge;
public BrushBins  brush;

public GtkWidget *vartable_tree_view[GGOBI_VARIABLE_ALL_VARTYPES];
public GtkTreeModel *vartable_tree_model; /* the root model, with all vars **/
public GtkWidget *cluster_table; /*-- table of symbol groups from brushing --*/
public clusteruid *clusvui;

public GHashTable* idTable;

/*-- to support brushing by categorical variable --*/
public gchar* linkvar = NULL;  /*-- the linking variable name--*/

// Vectors of length nrows
public char **rowIds;
public vector_b excluded;
public vector_b sampled;
public vector_i clusterid;

protected vector_i rows_in_plot;
public vector_i rows_under_brush;
public vector_i rows_under_brush_prev;

// Arrays of ncols x nrows
protected array_f raw;
public array_f tform;
public array_g world;
public array_g jitdata;
public array_s missing; 

public gboolean missings_show_p; /*-- show/hide per datad, not per display --*/
public gint nrows_in_plot;     /*-- how many elements of rows_in_plot to use --*/
public gint nrows_under_brush;
public gint nrows_under_brush_prev;
/*--------------- clusters: hiding, excluding ----------------------*/

public symbol_cell symbol_table[NGLYPHTYPES][NGLYPHSIZES][MAXNCOLORS];
public gint nclusters;
public clusterd *clusv;

/*-- used in identification, line editing, and point motion --*/
public gint nearest_point;
public gint nearest_point_prev;
public GSList *sticky_ids;

/*-------------------- moving points ---------------------------------*/
public GSList *movepts_history; /*-- a list of elements of type celld --*/
   
private signal first NONE (UINT) void 
rows_in_plot_changed(self, guint n) {
  tform_to_world(self);
  if (self->gg)
    displays_tailpipe (FULL, self->gg);
}

override (GGobi:Stage) void 
col_data_changed(GGobi:Stage *self (check null type), guint j) {
  limits_set_by_var(SELF(self), j, true, true, (SELF(self)->gg) ? SELF(self)->gg->lims_use_visible : true);
  tform_to_world_by_var(SELF(self), j);
  if (SELF(self)->gg)
    displays_tailpipe (FULL, SELF(self)->gg);
  PARENT_HANDLER(self, j);
}

init (self) {
  sphere_init(self); 
  
  ggobi_stage_set_name(GGOBI_STAGE(self), "unknown");

  self->idTable = g_hash_table_new(g_str_hash, g_str_equal);

  self->nearest_point = -1;
  self->missings_show_p = true;
}

/** 
 * new:
 * @nrows: number of rows
 * @ncols: number of columns
 *
 * Create new #GGobiData object
 * 
 * Returns: #GGobiData object
 **/
public GGobiData* 
new(guint nrows, guint ncols)
{
  GGobiData* d = (GGobiData*) g_object_new(GGOBI_TYPE_DATA, NULL);
  self_add_cols(d, ncols);
  self_add_rows(d, nrows);

  return(d);
}

// FIXME: abstract into a GGobiDataFactory
public void
add_attributes(self) {
  GGobiStage *stage = GGOBI_STAGE(self);
  self->nattributes += 12;
  guint first_attr = self_add_cols(self, 12);
  ggobi_stage_set_col_name(stage, first_attr++, "_color");
  ggobi_stage_set_col_name(stage, first_attr++, "_glyph_size");
  ggobi_stage_set_col_name(stage, first_attr++, "_glyph_type");
  ggobi_stage_set_col_name(stage, first_attr++, "_hidden");
  ggobi_stage_set_col_name(stage, first_attr++, "_color_now");
  ggobi_stage_set_col_name(stage, first_attr++, "_glyph_size_now");
  ggobi_stage_set_col_name(stage, first_attr++, "_glyph_type_now");
  ggobi_stage_set_col_name(stage, first_attr++, "_hidden_now");
  ggobi_stage_set_col_name(stage, first_attr++, "_color_prev");
  ggobi_stage_set_col_name(stage, first_attr++, "_glyph_size_prev");
  ggobi_stage_set_col_name(stage, first_attr++, "_glyph_type_prev");
  ggobi_stage_set_col_name(stage, first_attr++, "_hidden_prev");

  gint def_color = self->gg ? self->gg->color_id : 0;
  gint def_type  = self->gg ? self->gg->glyph_id.type : FC;
  gint def_size =  self->gg ? self->gg->glyph_id.size : 1;

  for (guint i = 0; i < ggobi_stage_get_n_rows(stage); i++) {
    self_set_attr_color(self, i, def_color, ATTR_SET_PERSISTENT);
    self_set_attr_glyph_parts(self, i, def_type, def_size, ATTR_SET_PERSISTENT);
    self_set_attr_hidden(self, i, false, ATTR_SET_PERSISTENT);
  }

}

// FIXME: data/attribute distinction should be made by a pipeline stage
public guint
get_n_data_cols(self) {
  return ggobi_stage_get_n_cols(GGOBI_STAGE(self)) - self->nattributes;
}

// FIXME: to be removed once pipeline in place
/** 
 * get_transformed_col_name:
 * @self: GGobiData object
 * @j: column index
 * Returns: duplicate of transformed column name (brief description of transformation
 * applied to variable)
 **/
public gchar* 
get_transformed_col_name(self, guint j) 
{
  gchar *lbl0, *lbl1, *lbl2;
  GGobiVariable *vt = ggobi_stage_get_variable(GGOBI_STAGE(self), j);

   /*-- skip the stage0 changes except negation --*/
   switch (vt->tform0) {
     case NEGATE:
       lbl0 = g_strdup_printf ("-%s", ggobi_stage_get_col_name(GGOBI_STAGE(self), j));
       break;
     default:
       lbl0 = g_strdup (ggobi_stage_get_col_name(GGOBI_STAGE(self), j));
       break;
   }

   switch (vt->tform1) {
     case BOXCOX:
       lbl1 = g_strdup_printf ("B-C(%s,%.2f)", lbl0, vt->param);
       break;
     case LOG10:
       lbl1 = g_strdup_printf ("log10(%s)", lbl0);
       break;
     case INVERSE:
       lbl1 = g_strdup_printf ("1/%s", lbl0);
       break;
     case ABSVALUE:
       lbl1 = g_strdup_printf ("abs(%s)", lbl0);
       break;
     case SCALE_AB:
       lbl1 = g_strdup_printf ("%s [a,b]", lbl0);
       break;
     default:
       lbl1 = g_strdup (lbl0);
   }

   switch (vt->tform2) {
     case STANDARDIZE:
       lbl2 = g_strdup_printf ("(%s-m)/s", lbl1);
     break;
     case SORT:
       lbl2 = g_strdup_printf ("sort(%s)", lbl1);
     break;
     case RANK:
       lbl2 = g_strdup_printf ("rank(%s)", lbl1);
     break;
     case NORMSCORE:
       lbl2 = g_strdup_printf ("normsc(%s)", lbl1);
     break;
     case ZSCORE:
       lbl2 = g_strdup_printf ("zsc(%s)", lbl1);
     break;
     case DISCRETE2:
       lbl2 = g_strdup_printf ("%s:0,1", lbl1);
     break;
     default:
       lbl2 = g_strdup (lbl1);
   }
   
   return lbl2;
}


/**
 * set_missing:
 * @self: GGobiData object
 * @i: row index
 * @j: column index
 *
 * Set specified cell to be a missing value.  
 * If the variable is categorical, a new level value ("MISSING")
 * will be created, and the raw value set to that.
 **/
override (GGobi:Stage) void
set_missing(GGobi:Stage *self (check null type), guint i, guint j)
{
  if (GGOBI_STAGE_IS_COL_CATEGORICAL(self, j)) {
    ggobi_stage_set_categorical_value(self, i, j, "MISSING");
    return;
  }

  SELF(self)->missing.vals[i][j] = 1;
  SELF(self)->raw.vals[i][j] = 0;

  SELF(self)->missings = TRUE;
}


/**
 * is_missing:
 * @self: GGobiData object
 * @i: row index
 * @j: column index
 *
 * Returns: if value at specified positive is missing or not
 **/
override (GGobi:Stage) gboolean
is_missing(GGobi:Stage *self, guint i, guint j) 
{
  return (SELF(self)->missing.vals[i][j] == 1);  
}

/**
 * has_missings:
 * @self: GGobiData object
 * Returns: whether or not dataset contains any missing values
 **/
override (GGobi:Stage) gboolean
has_missings(GGobi:Stage *self (check null type)) 
{
  return SELF(self)->missings;
}


/**
 * set_raw_value:
 * @self: GGobiData object
 * @i: row index
 * @j: column index
 * @values: vector of new values, of length self->nrows
 * 
 * Sets a single value in the specified column.  
 *
 * This will set missing values if necessary and sets
 * tform value as well to keep dataset consistent.
 *
 * You need to manually emits self_col_data_changed() signal after
 * using this function if you want the data to continue down the pipeline.
 **/
override (GGobi:Stage) void
set_raw_value(GGobi:Stage *self (check null type), guint i, guint j, gdouble value)
{
  if(GGobiMissingValue && GGobiMissingValue(value))
    ggobi_stage_set_missing(self, i, j);
  else {
    GGobiVariable *var = ggobi_stage_get_variable(self, j);
    if (GGOBI_VARIABLE_IS_CATEGORICAL(var))
      if (!ggobi_variable_has_level(var, (gint) value))
        ggobi_variable_add_level(var, NULL, (gint) value);
    SELF(self)->raw.vals[i][j] = value;
    SELF(self)->tform.vals[i][j] = value;
  }
}

/** 
 * get_raw_value:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 **/
override (GGobi:Stage) gdouble
get_raw_value(GGobi:Stage *self (check null type), guint i, guint j)
{
  return SELF(self)->raw.vals[i][j];
}

public void 
set_col_type(self, guint j, GGobiVariableType value)
{
  GGobiVariable *vt = ggobi_stage_get_variable(GGOBI_STAGE(self), j);
  ggobi_variable_set_vartype(vt, value);
}

/**
 * set_variable:
 * @self: #GGobiData object
 * @j: column index
 *
 * Set variable meta data for specified column
 **/
public void
set_variable (self, guint j, GGobiVariable* value)
{
  // FIXME: This function should not exist
  if (GGOBI_STAGE(self)->vartable[j])
    g_object_unref(GGOBI_STAGE(self)->vartable[j]);
  GGOBI_STAGE(self)->vartable[j] = value;
}

override (GGobi:Stage) guint
get_n_edges (GGobiStage *self)
{
  return SELF(self)->edge.n; 
}

/** 
 * set_row_id:
 * @self: #GGobiData object
 * @i: row
 * @value: new string value for row id
 * @check: throw error if id is already used?
 *
 * Set the row id (a string) for specified row
 * A row id is a unique string reference to a given row.
 * These are hashed for O(1) lookup.
 **/ 
override (GGobi:Stage) void
set_row_id(GGobiStage *self, guint i, gchar* value, gboolean check) {
  if (value == NULL)
    value = g_strdup_printf("%d", i+1);

  //g_return_if_fail(check && self_get_row_for_id(self, value) == -1);

  SELF(self)->rowIds[i] = g_strdup(value);
  g_hash_table_replace (SELF(self)->idTable, SELF(self)->rowIds[i], GINT_TO_POINTER(i));
}

/** 
 * get_row_id:
 * @self: #GGobiData object
 * @i: row
 * 
 * Retrive row id for specified row.
 * Returns: duplicate of row id if present, NULL otherwise
 **/
override (GGobi:Stage) gchar*
get_row_id(GGobi:Stage *self, guint i) {
  if (SELF(self)->rowIds[i]) 
    return g_strdup(SELF(self)->rowIds[i]);
  else
    return NULL;
}

/** 
 * get_row_for_id:
 * @self: #GGobiData object
 * @id: row id string
 * 
 * Get row index corresponding to row id
 *
 * Returns: row index if found, -1 otherwise
 **/
override (GGobi:Stage) gint
get_row_for_id(GGobi:Stage *self, gchar *id) {
  gpointer pos, key;
  if (id && g_hash_table_lookup_extended(SELF(self)->idTable, id, &key, &pos))
    return GPOINTER_TO_INT(pos);
  return -1;
}

/**
 * add_rows: 
 * @self: #GGobiData object
 * @n: number of rows to add
 *
 * Add n rows to the dataset
 * Adds extra rows, allocating space as needed.
 *
 * This emits the cols_added signal and also runs
 * #set_rows_in_plot which emits the rows_in_plot_changed signal.
 *
 * Returns: index of first new row
 **/
 // FIXME: This code should be the default handler for the n_rows property.
 // Then this function would just increment that property.
public guint
add_rows(self, guint n) {
  guint i, nrows, nprev = GGOBI_STAGE(self)->n_rows;
  GGOBI_STAGE(self)->n_rows += n;
  nrows = GGOBI_STAGE(self)->n_rows;
  
  self->rowIds = (gchar **) g_realloc (self->rowIds, sizeof(gchar *) * nrows);
  vectorb_realloc (&self->excluded, nrows);
  vectorb_realloc (&self->sampled, nrows);
  vectori_realloc (&self->rows_in_plot, nrows);
  vectori_realloc (&self->rows_under_brush, nrows);
  vectori_realloc (&self->rows_under_brush_prev, nrows);
  vectori_realloc (&self->clusterid, nrows);

  arrayf_add_rows (&self->raw, nrows);
  arrayf_add_rows (&self->tform, nrows);
  arrayg_add_rows (&self->jitdata, nrows);
  arrayg_add_rows (&self->world, nrows);
  arrays_add_rows (&self->missing, nrows);

  self->nrows_under_brush = self->nrows_under_brush_prev = 0;

  if (ggobi_stage_get_n_edges(GGOBI_STAGE(self)))
    vectorb_realloc (&self->edge.xed_by_brush, self->edge.n);

  for (i = nprev; i < nrows; i++) {
    self->excluded.els[i] = false;
    self->sampled.els[i] = true;
    
    self->rows_under_brush.els[i] = 0;
    self->rows_under_brush_prev.els[i] = 0;
    
    self->rowIds[i] = NULL;
  }

  if (self->nattributes > 0) {
    gint def_color = self->gg ? self->gg->color_id : 0;
    gint def_type  = self->gg ? self->gg->glyph_id.type : FC;
    gint def_size  = self->gg ? self->gg->glyph_id.size : 1;

    for (i = nprev; i < nrows; i++) {
      self_set_attr_color(self, i, def_color, ATTR_SET_PERSISTENT);
      self_set_attr_glyph_parts(self, i, def_type, def_size, ATTR_SET_PERSISTENT);
      self_set_attr_hidden(self, i, false, ATTR_SET_PERSISTENT);
    }
  }
  clusters_set(self);
  self_set_rows_in_plot(self);
  
  ggobi_stage_rows_added(GGOBI_STAGE(self), n);
  return nprev;
}


/**
 * add_cols:
 * @self: #GGobiData object
 * @n: number of columns to add
 *
 * Add n empty columns to the dataset.
 * Returns: index of first new column
 **/ 
 // FIXME: This code should be the default handler for the n_cols property.
 // Then this function would just increment that property.
public guint 
add_cols(self, guint n) {
  guint ncols, nprev = GGOBI_STAGE(self)->n_cols;
  ncols = nprev + n;
  
  arrayf_add_cols (&self->raw, ncols);
  arrayf_add_cols (&self->tform, ncols);
  arrayg_add_cols (&self->jitdata, ncols);
  arrayg_add_cols (&self->world, ncols);
  arrays_add_cols (&self->missing, ncols);

  tour_realloc_up (self, ncols);

  g_object_set(G_OBJECT(self), GGOBI_STAGE_PROP_N_COLS(ncols), NULL);
  
  return nprev;
}

public guint
delete_cols(self, guint *cols, gint ncols)
{
  gint j;
  gint *keepers, nkeepers, old_ncols = GGOBI_STAGE(self)->n_cols;
  
  g_return_val_if_fail(ncols < old_ncols, old_ncols);

  // FIXME: shouldn't find_keepers be able to handle this allocation??
  keepers = g_malloc ((old_ncols - ncols) * sizeof (gint));
  nkeepers = find_keepers (old_ncols, ncols, cols, keepers);
  if (nkeepers == -1) {
    g_free (keepers);
    g_return_val_if_reached(old_ncols);
  }
  
  for (j = 0; j < nkeepers; j++) {
    GGobiVariable *vt = ggobi_stage_get_variable(GGOBI_STAGE(self), keepers[j]);
    self_set_variable(self, j, vt);
  }
  
  //FIXME: need function analogous to tour_relloc_up
  tour2d_realloc_down (ncols, cols, self, self->gg);
  tour1d_realloc_down (ncols, cols, self, self->gg);
  tourcorr_realloc_down (ncols, cols, self, self->gg);

  arrayf_delete_cols (&self->raw, ncols, cols);
  arrayf_delete_cols (&self->tform, ncols, cols);
  arrayg_delete_cols (&self->jitdata, ncols, cols);
  arrayg_delete_cols (&self->world, ncols, cols);
  arrays_delete_cols (&self->missing, ncols, cols);
  
  g_object_set(G_OBJECT(self), GGOBI_STAGE_PROP_N_COLS(old_ncols - ncols), NULL);
  for (j = 0; j < ncols; j++) /* emit col deleted signal */
    ggobi_stage_col_deleted(GGOBI_STAGE(self), cols[j]);
  
  /*-- emit a single variable_list_changed signal when finished --*/
  /*-- doesn't need to give a variable index any more, really --*/
  // FIXME: emission of this is deprecated
/*  g_signal_emit_by_name(self->gg, "variable_list_changed", 0, self);*/

    /*-- run the first part of the pipeline  --*/
  tform_to_world(self);
                 
  g_free (keepers);
  
  return(GGOBI_STAGE(self)->n_cols);
}

/**
 * attach:
 * @self: #GGobiData object
 * @gg: GGobi object
 * @cleanup: should cleanup occur?
 *
 * Attach a GGobi object to this dataset
 * The purpose of this function is to hook up the #GGobiData object
 * to all the gui components and make sure they stay in sync by
 * listening to the correct signals.  This function still needs a lot of
 * work.
 **/
 // FIXME: This should not exist.. we need a ggobi_add_data()
public void 
attach (self, ggobid *gg, gboolean cleanup)
{
  self->gg = gg;
  gg->d = g_slist_append (gg->d, self);
  displayd *display = NULL;

  gint *vars = (gint *) g_malloc(GGOBI_STAGE(self)->n_cols * sizeof(gint));
  
  self->brush.bin0.x = self->brush.bin1.x = BRUSH_NBINS;
  self->brush.bin0.y = self->brush.bin1.y = BRUSH_NBINS;

  gint iv, ih;
  self->brush.nbins = BRUSH_NBINS;

  edgeedit_init (self->gg);
  if (ggobi_stage_get_n_edges(GGOBI_STAGE(self)))
    vectorb_realloc (&self->edge.xed_by_brush, self->edge.n);

  /* binning the plot window; no need to realloc these **/
  self->brush.binarray = (bin_struct **)
    g_malloc (self->brush.nbins * sizeof (bin_struct *));
  for (ih = 0; ih < self->brush.nbins; ih++) {
    self->brush.binarray[ih] = (bin_struct *)
      g_malloc (self->brush.nbins * sizeof (bin_struct));

    for (iv = 0; iv < self->brush.nbins; iv++) {
      self->brush.binarray[ih][iv].nels = 0;
      self->brush.binarray[ih][iv].nblocks = 1;
      self->brush.binarray[ih][iv].els = (gulong *)
        g_malloc (BINBLOCKSIZE * sizeof (gulong));
    }
  }

  /**
   * If there are missings, they've been initialized with a value
   * of 0.  Here, re-set that value to 15% below the minimum for each
   * variable.  (dfs -- done at Di's request, September 2004)
   **/
  limits_set (self, true, true, self->gg->lims_use_visible);
  for (guint j = 0; j < GGOBI_STAGE(self)->n_cols; j++) vars[j] = j;
  impute_fixed (IMP_BELOW, 15.0, GGOBI_STAGE(self)->n_cols, vars, self);
  limits_set (self, true, true, self->gg->lims_use_visible);
  g_free(vars);

  for(guint j = 0; j < self_get_n_data_cols(self); j++) 
    ggobi_stage_col_data_changed(GGOBI_STAGE(self), j);

  clusters_set(self);  /*-- find the clusters for data just read in --*/

  display_menu_build (gg);
  
  // Set up variable table and listen to important events
  ggobi_stage_connect__col_data_changed(GGOBI_STAGE(self), vartable_stats_set_by_var, NULL);
  ggobi_stage_connect__col_data_changed(GGOBI_STAGE(self), vartable_limits_set_by_var, NULL);
  ggobi_stage_connect__col_name_changed(GGOBI_STAGE(self), vartable_collab_set_by_var, NULL);
  ggobi_stage_connect__col_name_changed(GGOBI_STAGE(self), vartable_collab_tform_set_by_var, NULL);

  varcircles_populate (self, gg);
  ggobi_stage_connect__col_name_changed(GGOBI_STAGE(self), varcircle_label_set, NULL);

  if (cleanup)
    varpanel_clear (self, gg);
  varpanel_populate (self, gg);   
  if (gg->current_display != NULL)
    varpanel_refresh (gg->current_display, gg);
  if (g_slist_index(gg->d, (gpointer)self) == 0)
    varpanel_set_sensitive (self, true, gg);
  ggobi_stage_connect__col_name_changed(GGOBI_STAGE(self), varpanel_label_set, NULL);

  
  if (cleanup || g_list_length(gg->displays) == 0) {
    display_free_all (gg);  /*-- destroy any existing displays --*/
    gg->pmode = NULL_PMODE;

    /*-- initialize the first display --*/
    if(sessionOptions->info->createInitialScatterPlot && 
        ggobi_stage_get_n_cols(GGOBI_STAGE(self))) {
      display = scatterplot_new (false, NULL, self, gg);

      gg->displays = g_list_append (gg->displays, (gpointer) display);
      gg->current_splot = (splotd *)
      g_list_nth_data (display->splots, 0);
      display->current_splot = gg->current_splot;
      display_set_current (display, gg);

      sp_event_handlers_toggle (gg->current_splot, on, gg->pmode, gg->imode);
    }
  }
  g_signal_emit_by_name (G_OBJECT (gg), "datad_added", self);
}

/**
 * set_rows_in_plot:
 * @self: #GGobiData object
 *
 * Combine the values in two arrays:
 *   excluded[] (which comes from the exclusion panel or from linking)
 *   sampled[] (which come from the subset panel)
 * to determine which cases should be plotted.
 *
 * rows_in_plot = sampled && !excluded
 **/
 // FIXME: Needs to go bye-bye
public void
set_rows_in_plot(self)
{
  guint i;
  self->nrows_in_plot = 0;

  for (i = 0; i < GGOBI_STAGE(self)->n_rows; i++)
    if (self->sampled.els[i] && !self->excluded.els[i])
      self->rows_in_plot.els[self->nrows_in_plot++] = i;
  
  self_rows_in_plot_changed(self, (guint) self->nrows_in_plot); 
}


/* Attributes
 * ============================================================================
 */

 // FIXME: Could convert to macros, but in order to handle the documentation
 // we'll probably need to use gob's m4 support
/* [[[cog
   import cog, attraccessor\
   
   cog.outl(attraccessor.attr_accessor("color", "gushort", "short"))
   cog.outl(attraccessor.attr_accessor("hidden", "gboolean", "boolean"))
   cog.outl(attraccessor.attr_accessor("glyph_type", "gint", "int"))
   cog.outl(attraccessor.attr_accessor("glyph_size", "gint", "int"))
   ]]]*/
/**
 * reset_attr_color:
 * @self: #GGobiData 
 * @i: row index
 * @brush: persistent or transient
 *
 * Resets color attribute to previous value
**/
public gboolean
reset_attr_color(self, guint i, GGobiDataAttrSetMethod brush)
{
  gushort value;
  // This code is autogenerated, do not edit by hand
  switch(brush) {
    case ATTR_SET_PERSISTENT:
      value = self_get_short_value_for_col_name(self, i, "_color_prev");
    default:
      value = self_get_short_value_for_col_name(self, i, "_color");
  }
  
  return self_set_attr_color(self, i, value, brush);

}

/**
 * set_attr_color:
 * @self: #GGobiData
 * @i: row index
 * @brush: persistent or transient
 *
 * Sets color attribute to new value.
 * Returns: true if value has changed, false otherwise
**/
public gboolean
set_attr_color(self, guint i, gushort value, GGobiDataAttrSetMethod brush)
{
  // This code is autogenerated, do not edit by hand
  if (brush == ATTR_SET_TRANSIENT ?
    (self_get_short_value_for_col_name(self, i, "_color_now") == value) :
    (self_get_short_value_for_col_name(self, i, "_color") == value))
    return false;

  if (brush == ATTR_SET_PERSISTENT) {
    self_set_short_value_for_col_name(self, i, "_color_prev", 
      self_get_short_value_for_col_name(self, i, "_color"));
    self_set_short_value_for_col_name(self, i, "_color", value);
  }

  self_set_short_value_for_col_name(self, i, "_color_now", value);
  return true;
}

/**
 * get_attr_color:
 * @self: #GGobiData
 * @i: row index
 * 
 * Retrieve current color
**/
public gushort
get_attr_color(self, guint i)
{
  // This code is autogenerated, do not edit by hand
  return self_get_short_value_for_col_name(self, i, "_color_now");
}
/**
 * reset_attr_hidden:
 * @self: #GGobiData 
 * @i: row index
 * @brush: persistent or transient
 *
 * Resets hidden attribute to previous value
**/
public gboolean
reset_attr_hidden(self, guint i, GGobiDataAttrSetMethod brush)
{
  gboolean value;
  // This code is autogenerated, do not edit by hand
  switch(brush) {
    case ATTR_SET_PERSISTENT:
      value = self_get_boolean_value_for_col_name(self, i, "_hidden_prev");
    default:
      value = self_get_boolean_value_for_col_name(self, i, "_hidden");
  }
  
  return self_set_attr_hidden(self, i, value, brush);

}

/**
 * set_attr_hidden:
 * @self: #GGobiData
 * @i: row index
 * @brush: persistent or transient
 *
 * Sets hidden attribute to new value.
 * Returns: true if value has changed, false otherwise
**/
public gboolean
set_attr_hidden(self, guint i, gboolean value, GGobiDataAttrSetMethod brush)
{
  // This code is autogenerated, do not edit by hand
  if (brush == ATTR_SET_TRANSIENT ?
    (self_get_boolean_value_for_col_name(self, i, "_hidden_now") == value) :
    (self_get_boolean_value_for_col_name(self, i, "_hidden") == value))
    return false;

  if (brush == ATTR_SET_PERSISTENT) {
    self_set_boolean_value_for_col_name(self, i, "_hidden_prev", 
      self_get_boolean_value_for_col_name(self, i, "_hidden"));
    self_set_boolean_value_for_col_name(self, i, "_hidden", value);
  }

  self_set_boolean_value_for_col_name(self, i, "_hidden_now", value);
  return true;
}

/**
 * get_attr_hidden:
 * @self: #GGobiData
 * @i: row index
 * 
 * Retrieve current hidden
**/
public gboolean
get_attr_hidden(self, guint i)
{
  // This code is autogenerated, do not edit by hand
  return self_get_boolean_value_for_col_name(self, i, "_hidden_now");
}
/**
 * reset_attr_glyph_type:
 * @self: #GGobiData 
 * @i: row index
 * @brush: persistent or transient
 *
 * Resets glyph_type attribute to previous value
**/
public gboolean
reset_attr_glyph_type(self, guint i, GGobiDataAttrSetMethod brush)
{
  gint value;
  // This code is autogenerated, do not edit by hand
  switch(brush) {
    case ATTR_SET_PERSISTENT:
      value = self_get_int_value_for_col_name(self, i, "_glyph_type_prev");
    default:
      value = self_get_int_value_for_col_name(self, i, "_glyph_type");
  }
  
  return self_set_attr_glyph_type(self, i, value, brush);

}

/**
 * set_attr_glyph_type:
 * @self: #GGobiData
 * @i: row index
 * @brush: persistent or transient
 *
 * Sets glyph_type attribute to new value.
 * Returns: true if value has changed, false otherwise
**/
public gboolean
set_attr_glyph_type(self, guint i, gint value, GGobiDataAttrSetMethod brush)
{
  // This code is autogenerated, do not edit by hand
  if (brush == ATTR_SET_TRANSIENT ?
    (self_get_int_value_for_col_name(self, i, "_glyph_type_now") == value) :
    (self_get_int_value_for_col_name(self, i, "_glyph_type") == value))
    return false;

  if (brush == ATTR_SET_PERSISTENT) {
    self_set_int_value_for_col_name(self, i, "_glyph_type_prev", 
      self_get_int_value_for_col_name(self, i, "_glyph_type"));
    self_set_int_value_for_col_name(self, i, "_glyph_type", value);
  }

  self_set_int_value_for_col_name(self, i, "_glyph_type_now", value);
  return true;
}

/**
 * get_attr_glyph_type:
 * @self: #GGobiData
 * @i: row index
 * 
 * Retrieve current glyph_type
**/
public gint
get_attr_glyph_type(self, guint i)
{
  // This code is autogenerated, do not edit by hand
  return self_get_int_value_for_col_name(self, i, "_glyph_type_now");
}
/**
 * reset_attr_glyph_size:
 * @self: #GGobiData 
 * @i: row index
 * @brush: persistent or transient
 *
 * Resets glyph_size attribute to previous value
**/
public gboolean
reset_attr_glyph_size(self, guint i, GGobiDataAttrSetMethod brush)
{
  gint value;
  // This code is autogenerated, do not edit by hand
  switch(brush) {
    case ATTR_SET_PERSISTENT:
      value = self_get_int_value_for_col_name(self, i, "_glyph_size_prev");
    default:
      value = self_get_int_value_for_col_name(self, i, "_glyph_size");
  }
  
  return self_set_attr_glyph_size(self, i, value, brush);

}

/**
 * set_attr_glyph_size:
 * @self: #GGobiData
 * @i: row index
 * @brush: persistent or transient
 *
 * Sets glyph_size attribute to new value.
 * Returns: true if value has changed, false otherwise
**/
public gboolean
set_attr_glyph_size(self, guint i, gint value, GGobiDataAttrSetMethod brush)
{
  // This code is autogenerated, do not edit by hand
  if (brush == ATTR_SET_TRANSIENT ?
    (self_get_int_value_for_col_name(self, i, "_glyph_size_now") == value) :
    (self_get_int_value_for_col_name(self, i, "_glyph_size") == value))
    return false;

  if (brush == ATTR_SET_PERSISTENT) {
    self_set_int_value_for_col_name(self, i, "_glyph_size_prev", 
      self_get_int_value_for_col_name(self, i, "_glyph_size"));
    self_set_int_value_for_col_name(self, i, "_glyph_size", value);
  }

  self_set_int_value_for_col_name(self, i, "_glyph_size_now", value);
  return true;
}

/**
 * get_attr_glyph_size:
 * @self: #GGobiData
 * @i: row index
 * 
 * Retrieve current glyph_size
**/
public gint
get_attr_glyph_size(self, guint i)
{
  // This code is autogenerated, do not edit by hand
  return self_get_int_value_for_col_name(self, i, "_glyph_size_now");
}
/* [[[end]]] */

/**
 * reset_attr_glyph:
 * @self: #GGobiData 
 * @i: row index
 * @brush: persistent or transient
 *
 * Resets glyph attribute to previous value
**/
public gboolean
reset_attr_glyph(self, guint i, GGobiDataAttrSetMethod brush)
{
  gboolean changed = false;
  changed = self_reset_attr_glyph_size(self, i, brush) || changed;
  changed = self_reset_attr_glyph_type(self, i, brush) || changed;
  return changed;
}

/**
 * set_attr_glyph:
 * @self: #GGobiData
 * @i: row index
 * @brush: persistent or transient
 *
 * Sets glyph attribute to new value.
 * Returns: true if value has changed, false otherwise
**/
public gboolean
set_attr_glyph_parts(self, guint i, GlyphType type, guint size, GGobiDataAttrSetMethod brush)
{
    gboolean changed = false;
    changed = self_set_attr_glyph_size(self, i, type, brush) || changed;
    changed = self_set_attr_glyph_type(self, i, size, brush) || changed;
    return changed;
}

public gboolean
set_attr_glyph(self, guint i, glyphd* value, GGobiDataAttrSetMethod brush)
{
  return self_set_attr_glyph_parts(self, i, value->type, value->size, brush);
}

/**
 * get_attr_glyph:
 * @self: #GGobiData
 * @i: row index
 * 
 * Retrieve current glyph
**/
public glyphd* 
get_attr_glyph(self, guint i)
{
  glyphd* glyph = (glyphd*) g_malloc (sizeof (glyphd)); 
  glyph->type = self_get_attr_glyph_type(self, i);
  glyph->size = self_get_attr_glyph_size(self, i);
  return glyph;
}

public gboolean 
reset_attr(self, guint i, GGobiDataAttrSetMethod brush) {
  gboolean changed = false;
  changed = self_reset_attr_hidden(self, i, brush) || changed;
  changed = self_reset_attr_glyph(self, i, brush) || changed;
  changed = self_reset_attr_color(self, i, brush) || changed;
  
  return changed;
}

public gboolean
brush_point(self, guint i, gboolean condition, BrushTargetType brush_mode, GGobiDataAttrSetMethod brush) {
  if (condition) {
   switch (brush_mode) {
    case br_candg:
      self_set_attr_color(self, i, self->gg->color_id, brush);
      self_set_attr_glyph(self, i, &self->gg->glyph_id, brush);
      break;
    case br_color:
      self_set_attr_color(self, i, self->gg->color_id, brush);
      break;
    case br_glyph:
      self_set_attr_glyph(self, i, &self->gg->glyph_id, brush);
      break;
    case br_shadow:
      self_set_attr_hidden(self, i, true, brush);
      break;
    case br_unshadow:
      self_set_attr_hidden(self, i, false, brush);
      break;
    default:
      break;
    }
  } else if (brush == ATTR_SET_TRANSIENT) {  
    switch (brush_mode) {
    case br_candg:
      self_reset_attr_color(self, i, ATTR_SET_TRANSIENT);
      self_reset_attr_glyph(self, i, ATTR_SET_TRANSIENT);
      break;
    case br_color:
      self_reset_attr_color(self, i, ATTR_SET_TRANSIENT);
      break;
    case br_glyph:
      self_reset_attr_glyph(self, i, ATTR_SET_TRANSIENT);
      break;
    case br_unshadow:
    case br_shadow:
      self_reset_attr_hidden(self, i, ATTR_SET_TRANSIENT);
      break;
    default:
      break;
    }
  }
  return false;
}

// FIXME: Should become macros
/* [[[cog
   import cog, attraccessor
   cog.outl(attraccessor.column_accessor("boolean", "gboolean"))
   cog.outl(attraccessor.column_accessor("short", "gshort"))
   cog.outl(attraccessor.column_accessor("int", "gint"))
   ]]] */
/** 
 * get_boolean_value:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 *
 * Convenience method for getting boolean value.
 **/
public gboolean
get_boolean_value(self, guint i, guint j)
{
  // This code is autogenerated, do not edit by hand
  return (gboolean) ggobi_stage_get_raw_value(GGOBI_STAGE(self), i, j);
}


/** 
 * get_boolean_values:
 * @self: #GGobiData
 * @i: row index
 *
 * Convenience method for creating a new array of type gboolean
 * from the specified column.
 **/
public gboolean*
get_boolean_values(self, guint j)
{
  // This code is autogenerated, do not edit by hand
  gboolean* values = g_new(gboolean, GGOBI_STAGE(self)->n_rows);
  for (guint i = 0; i < GGOBI_STAGE(self)->n_rows; i++)
    values[i] = self_get_boolean_value(self, i, j);
  return(values);
}

/** 
 * set_boolean_value:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 * @value: new value
 *
 * Convenience method for setting boolean value.
 **/
public void
set_boolean_value(self, guint i, guint j, gboolean value)
{
  // This code is autogenerated, do not edit by hand
  ggobi_stage_set_raw_value(GGOBI_STAGE(self), i, j, (gdouble) value);
}

/** 
 * set_boolean_values:
 * @self: #GGobiData
 * @i: row index
 * @value: array of boolean of length self->nrows
 *
 * Convenience method for setting entire column of booleans.
 * Emits self_col_data_changed() signal.
 **/
public void
set_boolean_values(self, guint j, gboolean *values)
{
  // This code is autogenerated, do not edit by hand
  for (guint i = 0; i < GGOBI_STAGE(self)->n_rows; i++) {
    self_set_boolean_value(self, i, j, values[i]);
  }
  ggobi_stage_col_data_changed(GGOBI_STAGE(self), j);
}


/** 
 * get_boolean_value_for_col_name:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 *
 * Convenience method for getting boolean value.
 **/
public gboolean
get_boolean_value_for_col_name(self, guint i, gchar* name)
{
  // This code is autogenerated, do not edit by hand
  guint j = ggobi_stage_get_col_index_for_name(GGOBI_STAGE(self), name);
  g_assert(j != -1);
  
  return self_get_boolean_value(self, i, j);
}


/** 
 * get_boolean_values_for_col_names:
 * @self: #GGobiData
 * @i: row index
 *
 * Convenience method for creating a new array of type gboolean
 * from the specified column.
 **/
public gboolean*
get_boolean_values_for_col_name(self, gchar* name)
{
  // This code is autogenerated, do not edit by hand
  guint j = ggobi_stage_get_col_index_for_name(GGOBI_STAGE(self), name);
  g_assert(j != -1);
  
  return self_get_boolean_values(self, j);
}

/** 
 * set_boolean_value_for_col_name:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 * @value_for_col_name: new value_for_col_name
 *
 * Convenience method for setting boolean value.
 **/
public void
set_boolean_value_for_col_name(self, guint i, gchar* name, gboolean value)
{
  // This code is autogenerated, do not edit by hand
  guint j = ggobi_stage_get_col_index_for_name(GGOBI_STAGE(self), name);
  g_assert(j != -1);
  
  self_set_boolean_value(self, i, j, value);
}

/** 
 * set_boolean_values_for_col_name:
 * @self: #GGobiData
 * @i: row index
 * @value_for_col_name: array of boolean of length self->nrows
 *
 * Convenience method for setting entire column of booleans.
 * Emits self_col_data_changed() signal.
 **/
public void
set_boolean_values_for_col_name(self, gchar* name, gboolean *values)
{
  // This code is autogenerated, do not edit by hand
  guint j = ggobi_stage_get_col_index_for_name(GGOBI_STAGE(self), name);
  g_assert(j != -1);
  
  self_set_boolean_values(self, j, values);
}

/** 
 * get_short_value:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 *
 * Convenience method for getting short value.
 **/
public gshort
get_short_value(self, guint i, guint j)
{
  // This code is autogenerated, do not edit by hand
  return (gshort) ggobi_stage_get_raw_value(GGOBI_STAGE(self), i, j);
}


/** 
 * get_short_values:
 * @self: #GGobiData
 * @i: row index
 *
 * Convenience method for creating a new array of type gshort
 * from the specified column.
 **/
public gshort*
get_short_values(self, guint j)
{
  // This code is autogenerated, do not edit by hand
  gshort* values = g_new(gshort, GGOBI_STAGE(self)->n_rows);
  for (guint i = 0; i < GGOBI_STAGE(self)->n_rows; i++)
    values[i] = self_get_short_value(self, i, j);
  return(values);
}

/** 
 * set_short_value:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 * @value: new value
 *
 * Convenience method for setting short value.
 **/
public void
set_short_value(self, guint i, guint j, gshort value)
{
  // This code is autogenerated, do not edit by hand
  ggobi_stage_set_raw_value(GGOBI_STAGE(self), i, j, (gdouble) value);
}

/** 
 * set_short_values:
 * @self: #GGobiData
 * @i: row index
 * @value: array of short of length self->nrows
 *
 * Convenience method for setting entire column of shorts.
 * Emits self_col_data_changed() signal.
 **/
public void
set_short_values(self, guint j, gshort *values)
{
  // This code is autogenerated, do not edit by hand
  for (guint i = 0; i < GGOBI_STAGE(self)->n_rows; i++) {
    self_set_short_value(self, i, j, values[i]);
  }
  ggobi_stage_col_data_changed(GGOBI_STAGE(self), j);
}


/** 
 * get_short_value_for_col_name:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 *
 * Convenience method for getting short value.
 **/
public gshort
get_short_value_for_col_name(self, guint i, gchar* name)
{
  // This code is autogenerated, do not edit by hand
  guint j = ggobi_stage_get_col_index_for_name(GGOBI_STAGE(self), name);
  g_assert(j != -1);
  
  return self_get_short_value(self, i, j);
}


/** 
 * get_short_values_for_col_names:
 * @self: #GGobiData
 * @i: row index
 *
 * Convenience method for creating a new array of type gshort
 * from the specified column.
 **/
public gshort*
get_short_values_for_col_name(self, gchar* name)
{
  // This code is autogenerated, do not edit by hand
  guint j = ggobi_stage_get_col_index_for_name(GGOBI_STAGE(self), name);
  g_assert(j != -1);
  
  return self_get_short_values(self, j);
}

/** 
 * set_short_value_for_col_name:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 * @value_for_col_name: new value_for_col_name
 *
 * Convenience method for setting short value.
 **/
public void
set_short_value_for_col_name(self, guint i, gchar* name, gshort value)
{
  // This code is autogenerated, do not edit by hand
  guint j = ggobi_stage_get_col_index_for_name(GGOBI_STAGE(self), name);
  g_assert(j != -1);
  
  self_set_short_value(self, i, j, value);
}

/** 
 * set_short_values_for_col_name:
 * @self: #GGobiData
 * @i: row index
 * @value_for_col_name: array of short of length self->nrows
 *
 * Convenience method for setting entire column of shorts.
 * Emits self_col_data_changed() signal.
 **/
public void
set_short_values_for_col_name(self, gchar* name, gshort *values)
{
  // This code is autogenerated, do not edit by hand
  guint j = ggobi_stage_get_col_index_for_name(GGOBI_STAGE(self), name);
  g_assert(j != -1);
  
  self_set_short_values(self, j, values);
}

/** 
 * get_int_value:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 *
 * Convenience method for getting int value.
 **/
public gint
get_int_value(self, guint i, guint j)
{
  // This code is autogenerated, do not edit by hand
  return (gint) ggobi_stage_get_raw_value(GGOBI_STAGE(self), i, j);
}


/** 
 * get_int_values:
 * @self: #GGobiData
 * @i: row index
 *
 * Convenience method for creating a new array of type gint
 * from the specified column.
 **/
public gint*
get_int_values(self, guint j)
{
  // This code is autogenerated, do not edit by hand
  gint* values = g_new(gint, GGOBI_STAGE(self)->n_rows);
  for (guint i = 0; i < GGOBI_STAGE(self)->n_rows; i++)
    values[i] = self_get_int_value(self, i, j);
  return(values);
}

/** 
 * set_int_value:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 * @value: new value
 *
 * Convenience method for setting int value.
 **/
public void
set_int_value(self, guint i, guint j, gint value)
{
  // This code is autogenerated, do not edit by hand
  ggobi_stage_set_raw_value(GGOBI_STAGE(self), i, j, (gdouble) value);
}

/** 
 * set_int_values:
 * @self: #GGobiData
 * @i: row index
 * @value: array of int of length self->nrows
 *
 * Convenience method for setting entire column of ints.
 * Emits self_col_data_changed() signal.
 **/
public void
set_int_values(self, guint j, gint *values)
{
  // This code is autogenerated, do not edit by hand
  for (guint i = 0; i < GGOBI_STAGE(self)->n_rows; i++) {
    self_set_int_value(self, i, j, values[i]);
  }
  ggobi_stage_col_data_changed(GGOBI_STAGE(self), j);
}


/** 
 * get_int_value_for_col_name:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 *
 * Convenience method for getting int value.
 **/
public gint
get_int_value_for_col_name(self, guint i, gchar* name)
{
  // This code is autogenerated, do not edit by hand
  guint j = ggobi_stage_get_col_index_for_name(GGOBI_STAGE(self), name);
  g_assert(j != -1);
  
  return self_get_int_value(self, i, j);
}


/** 
 * get_int_values_for_col_names:
 * @self: #GGobiData
 * @i: row index
 *
 * Convenience method for creating a new array of type gint
 * from the specified column.
 **/
public gint*
get_int_values_for_col_name(self, gchar* name)
{
  // This code is autogenerated, do not edit by hand
  guint j = ggobi_stage_get_col_index_for_name(GGOBI_STAGE(self), name);
  g_assert(j != -1);
  
  return self_get_int_values(self, j);
}

/** 
 * set_int_value_for_col_name:
 * @self: #GGobiData
 * @i: row index
 * @j: column index
 * @value_for_col_name: new value_for_col_name
 *
 * Convenience method for setting int value.
 **/
public void
set_int_value_for_col_name(self, guint i, gchar* name, gint value)
{
  // This code is autogenerated, do not edit by hand
  guint j = ggobi_stage_get_col_index_for_name(GGOBI_STAGE(self), name);
  g_assert(j != -1);
  
  self_set_int_value(self, i, j, value);
}

/** 
 * set_int_values_for_col_name:
 * @self: #GGobiData
 * @i: row index
 * @value_for_col_name: array of int of length self->nrows
 *
 * Convenience method for setting entire column of ints.
 * Emits self_col_data_changed() signal.
 **/
public void
set_int_values_for_col_name(self, gchar* name, gint *values)
{
  // This code is autogenerated, do not edit by hand
  guint j = ggobi_stage_get_col_index_for_name(GGOBI_STAGE(self), name);
  g_assert(j != -1);
  
  self_set_int_values(self, j, values);
}

/* [[[end]]] */

}