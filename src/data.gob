%h{

#include "defines.h"
#include "brushing.h"
#include "vartable.h"
#include "fileio.h"

#include <gtk/gtk.h>
#include <math.h>

typedef enum {no_edgesets, edgesets_only, all_datatypes} datatyped;

typedef struct _Subset {
  gint random_n;
  gint string_pos;
 /*-- adjustments from which to get values for blocksize, everyn --*/
  GtkAdjustment *bstart_adj, *bsize_adj;
  GtkAdjustment *estart_adj, *estep_adj;
} Subset;


typedef struct _Jitterd {
  gfloat factor;
  gboolean type;
  gboolean convex;
  gfloat *jitfacv;
} Jitterd;

typedef struct _Varpanel_cboxd {
  GtkWidget *ebox;   /*-- child1 of pane widget --*/
  GtkWidget *swin;   /*-- child of ebox --*/
  GtkWidget *vbox;   /*-- child of swin --*/
  GSList *box;       /*-- single column of hboxes --*/
} Varpanel_cboxd;

typedef struct _Varpanel_circd {
  GtkWidget *ebox;        /*-- child2 of pane widget --*/
  GtkWidget *vbox;        /*-- child of ebox --*/
  GtkWidget *swin, *hbox; /*-- children of vbox --*/
  GtkWidget *table;       /*-- sole child of swin; now a vbox --*/
  GtkWidget *manip_btn, *freeze_btn; /*-- children of hbox --*/

  GdkCursor *cursor;
  gint jcursor;

 /*-- components and properties of the table --*/
  GSList *vb, *da, *label;
  GSList *da_pix;         /*-- backing pixmaps --*/
  gint nvars;
} Varpanel_circd;

typedef struct _Varpaneld {
  GtkWidget *hpane;  /*-- child of the ebox --*/
} Varpaneld;

/*-------------------- transformation --------------------------------*/

/* sphering transformation */
typedef struct _Sphere_d {
  vector_i vars;        /*-- vars available to be sphered --*/
  vector_i vars_sphered;/*-- vars that have been sphered --*/
  gint npcs;      /*-- the first npcs vars of vars will be sphered --*/
  vector_i pcvars;/*-- vars into which sphered data is written --*/

  vector_f eigenval;
  array_d eigenvec;
  array_f vc;
  vector_f tform_mean;
  vector_f tform_stddev;

  gboolean vars_stdized;
} Sphere_d;


typedef struct _EdgeData {
  gint n;
  SymbolicEndpoints *sym_endpoints;
  GList *endpointList;   
    /* a list of endpointsd elements corresponding to the resolved 
       record ids relative to a given datad. This is akin to a table
       indexed by datad elements. */

  gint nxed_by_brush;
  vector_b xed_by_brush;
} EdgeData;

typedef struct _BrushBins {
  gint nbins;
  bin_struct **binarray;
  icoords bin0, bin1;
} BrushBins;


%}

%{
#include "vars.h"
#include "externs.h"
%}

class GGobi:Data from G:Object {

public const gchar *name;
public const gchar *nickname;
public InputDescription *input;

public guint nrows;
public guint ncols;

public gboolean missings;

public struct _ggobid *gg; /*-- a pointer to the parent --*/


/*-- row ids to support generalized linking --*/
public GHashTable *idTable;
/*-- to support brushing by categorical variable --*/
public gchar* linkvar = NULL;  /*-- the linking variable name--*/

public Subset  subset;
public Jitterd  jitter;
public Varpanel_cboxd  vcbox_ui;
public Varpanel_circd  vcirc_ui;
public Varpaneld  varpanel_ui;
public Sphere_d  sphere;
public EdgeData  edge;
public BrushBins  brush;

public GtkWidget *vartable_tree_view[all_vartypes];
public GtkTreeModel *vartable_tree_model; /* the root model, with all vars */

// Vectors of length ncol
public vartabled **vartable;

// Vectors of length nrows
public char **rowIds;
public vector_b excluded;
public vector_b hidden;
public vector_b hidden_now;
public vector_b hidden_prev;
public vector_b pts_under_brush;
public vector_b sampled;
public vector_i clusterid;
public vector_i rows_in_plot;
public vector_g glyph;
public vector_g glyph_now;
public vector_g glyph_prev;
public vector_s color;
public vector_s color_now; 
public vector_s color_prev;

// Arrays of ncols x nrows
public array_f raw;
public array_f tform;
public array_g world;
public array_g jitdata;
public array_s missing; 


public gboolean missings_show_p; /*-- show/hide per datad, not per display --*/
public gint nrows_in_plot;     /*-- how many elements of rows_in_plot to use --*/

/*--------------- clusters: hiding, excluding ----------------------*/

public symbol_cell symbol_table[NGLYPHTYPES][NGLYPHSIZES][MAXNCOLORS];
public GtkWidget *cluster_table; /*-- table of symbol groups from brushing --*/
public gint nclusters;
public clusterd *clusv;
public clusteruid *clusvui;

/*------------------------ brushing ----------------------------------*/

public gint npts_under_brush;

/*-- used in identification, line editing, and point motion --*/
public gint nearest_point;
public gint nearest_point_prev;
public GSList *sticky_ids;

/*-------------------- moving points ---------------------------------*/
public GSList *movepts_history; /*-- a list of elements of type celld --*/


property UINT nrows 
  (nick = "nrows", blurb = "Number of rows in the dataset",
   minimum = 0, maximum = INT_MAX, default_value = 0,
   flags = CONSTRUCT_ONLY, link, export);
property UINT ncols 
  (nick = "ncols", blurb = "Number of cols in the dataset",
   minimum = 0, maximum = INT_MAX, default_value = 0,
   flags = CONSTRUCT_ONLY, link, export);
   
private signal first NONE (UINT) void 
rows_in_plot_changed(self, guint n) {
  g_debug("Rows in plot changed to %i", n);
  tform_to_world(self);
  if (self->gg)
    displays_tailpipe (FULL, self->gg);
}

private signal NONE (UINT) void 
col_name_changed(self, guint j);

private signal first NONE (UINT) void 
col_data_changed(self, guint j) {
  limits_set_by_var(self, j, true, true, (self->gg) ? self->gg->lims_use_visible : true);
  tform_to_world_by_var(self, j);
  if (self->gg)
    displays_tailpipe (FULL, self->gg);
}

private signal NONE (UINT) void
cols_added(self, guint n);

private signal NONE (UINT) void
col_deleted(self, guint j);

private signal NONE (UINT) void
rows_added(self, guint n);

init (self) {
  sphere_init(self); 
  
  self_set_name(self, "unknown", NULL);

  self->idTable = g_hash_table_new(g_str_hash, g_str_equal);

  self->nearest_point = -1;
  self->missings_show_p = true;
}

public GGobiData* 
new(guint nrows, guint ncols)
{
  GGobiData* d = (GGobiData*) g_object_new(GGOBI_TYPE_DATA, NULL);
  self_add_cols(d, ncols);
  self_add_rows(d, nrows);
  return(d);
}

public gchar *
get_name (self)
{
  return g_strdup(self->name);
}

public void
set_name (self, gchar *name, gchar *nickname)
{
  if (name == NULL) name = g_strdup("unknown");
  if (nickname == NULL) nickname = g_strndup(name, 5);

  self->name = g_strdup(name);
  self->nickname = g_strndup(name, 5);
}

public guint
get_n_cols(self) {
  return self->ncols;
}

public guint
get_n_rows(self) {
  return self->nrows;
}

public gchar* 
get_col_name(self, guint j) 
{
  vartabled* vt = self_get_vartable(self, j);
  return g_strdup(vt->collab);
}

public gchar* 
get_col_nickname(self, guint j) 
{
  vartabled* vt = self_get_vartable(self, j);
  return g_strdup(vt->nickname);
}

public guint
get_col_index_by_name(self, gchar* value) 
{
  guint i;

  for(i = 0; i < self->ncols; i++) {
    if (!g_ascii_strcasecmp(self_get_col_name(self, i), value))
      return(i);
  }
  return -1;
}

public void 
set_col_name(self, guint j, gchar* value) 
{
  vartabled* vt = self_get_vartable(self, j);

  if (value == NULL) value = g_strdup_printf("V%d", j + 1);

  vt->collab = g_strdup(value);
  vt->collab_tform = g_strdup(value);
  vt->nickname = g_strndup (vt->collab, 2);

  self_col_name_changed(self, j);
}

// FIXME: to be removed once pipeline in place
public gchar* 
get_transformed_col_name(self, guint j) 
{
  gchar *lbl0, *lbl1, *lbl2;
   vartabled *vt = self_get_vartable(self, j);

   /*-- skip the stage0 changes except negation --*/
   switch (vt->tform0) {
     case NEGATE:
       lbl0 = g_strdup_printf ("-%s", self_get_col_name(self, j));
       break;
     default:
       lbl0 = g_strdup (self_get_col_name(self, j));
       break;
   }

   switch (vt->tform1) {
     case NO_TFORM1:
       lbl1 = g_strdup (lbl0);
       break;
     case BOXCOX:
       lbl1 = g_strdup_printf ("B-C(%s,%.2f)", lbl0, vt->param);
       break;
     case LOG10:
       lbl1 = g_strdup_printf ("log10(%s)", lbl0);
       break;
     case INVERSE:
       lbl1 = g_strdup_printf ("1/%s", lbl0);
       break;
     case ABSVALUE:
       lbl1 = g_strdup_printf ("abs(%s)", lbl0);
       break;
     case SCALE_AB:
       lbl1 = g_strdup_printf ("%s [a,b]", lbl0);
       break;
     default:  // compiler pacification
       lbl1 = "";
   }

   switch (vt->tform2) {
     case STANDARDIZE:
       lbl2 = g_strdup_printf ("(%s-m)/s", lbl1);
     break;
     case SORT:
       lbl2 = g_strdup_printf ("sort(%s)", lbl1);
     break;
     case RANK:
       lbl2 = g_strdup_printf ("rank(%s)", lbl1);
     break;
     case NORMSCORE:
       lbl2 = g_strdup_printf ("normsc(%s)", lbl1);
     break;
     case ZSCORE:
       lbl2 = g_strdup_printf ("zsc(%s)", lbl1);
     break;
     case DISCRETE2:
       lbl2 = g_strdup_printf ("%s:0,1", lbl1);
     break;
     default:
       lbl2 = g_strdup (lbl1);
   }
   
   return lbl2;
}


/**
 * set_missing:
 * 
 * Set specified cell to be a missing value.  
 * 
 * @self: GGobiData object
 * @i: row index
 * @j: column index
 *
 * If the variable is categorical, a new level value ("MISSING")
 * will be created, and the raw value set to that.
 */
public void
set_missing(self, guint i, guint j)
{
  if (self_get_col_type(self, j) == categorical) {
    self_set_categorical_value(self, i, j, "MISSING");
    return;
  }

  self->missing.vals[i][j] = 1;
  self->raw.vals[i][j] = 0;

  self->missings = TRUE;
}

public gboolean
is_missing(self, guint i, guint j) 
{
  return (self->missing.vals[i][j] == 1);  
}

public gboolean
has_missings(self) 
{
  return self->missings;
}


public guint 
get_col_n_missing(self, guint j) {
  guint i, n = 0;

  for(i = 0; i < self->nrows; i++) {
    if (self_is_missing(self, i, j)) n++;
  }
  
  return(n);
}

public void
set_raw_values(self, guint j, gdouble *values)
{
  guint i;
  for (i = 0; i < self->nrows; i++) {
    self_set_raw_value(self, i, j, values[i]);
  }
}

public void
set_raw_value(self, guint i, guint j, gdouble value)
{
  if(GGobiMissingValue && GGobiMissingValue(value))
    self_set_missing(self, i, j);
  else {
    if (self_get_col_type(self, j) == categorical)
      if (self_get_col_level_for_value(self, j, (gint)value) == -1)
        self_add_col_level(self, j, NULL, (gint)value);
    self->raw.vals[i][j] = value;
    self->tform.vals[i][j] = value;
  }
}

// FIXME: should these two really be public?
public gint
get_col_level_for_value(self, guint j, gint value)
{
  gpointer key, level_ptr;
  vartabled *vt = self_get_vartable(self, j);
  g_return_val_if_fail(self_get_col_type(self, j) == categorical, -1);
  if(!g_hash_table_lookup_extended(vt->value_to_level, GINT_TO_POINTER(value), 
      &key, &level_ptr))
    return(-1);
  return(GPOINTER_TO_INT(level_ptr));
}

public gint
get_col_level_for_name(self, guint j, const gchar *name)
{
  gpointer key, level_ptr;
  vartabled *vt = self_get_vartable(self, j);
  g_return_val_if_fail(self_get_col_type(self, j) == categorical, -1);
  if (!g_hash_table_lookup_extended(vt->name_to_level, name, &key, &level_ptr))
    return(-1);
  return(GPOINTER_TO_INT(level_ptr));
}

// replaces getAutoLevelIndex
public void
set_categorical_value(self, guint i, guint j, const gchar* value) 
{
  vartabled *vt = self_get_vartable(self, j);
  guint level;

  self_set_col_type(self, j, categorical);
  
  level = self_get_col_level_for_name(self, j, value);
  
  if (level != -1) {
    vt->level_counts[level]++;
    self_set_raw_value(self, i, j, (gdouble) vt->level_values[level]);
    return;
  }
  
  //not found, must be new level
  self_add_col_level(self, j, value, -1);
  
  self_set_raw_value(self, i, j, (gdouble) vt->level_values[vt->nlevels-1]);
}

public void
set_string_value(self, guint i, guint j, const gchar* value) 
{
  if (is_numeric(value)) {
    self_set_raw_value(self, i, j, (gfloat) g_strtod (value, NULL));
  } else {
    if (!g_ascii_strcasecmp (value, "na") || !strcmp (value, ".") || !strcmp(value, ""))  
      self_set_missing(self, i, j);
    else
      self_set_categorical_value(self, i, j, value);
  }
}

public void
set_integer_values(self, guint j, gint *values)
{
  guint i;
  for (i = 0; i < self->nrows; i++) {
    self_set_integer_value(self, i, j, values[i]);
  }
}

public void
set_integer_value(self, guint i, guint j, gint value)
{
  self_set_raw_value(self, i, j, (gdouble)value);
}

public vartyped 
get_col_type(self, guint j)
{
  vartabled *vt = self_get_vartable(self, j);
  return(vt->vartype);
}

public void 
set_col_type(self, guint j, vartyped value)
{
  vartabled *vt = self_get_vartable(self, j);
  vt->vartype = value;
}

/*
 * get_vartable:
 * Get variable meta data for specified column
 *
 * @self: #GGobiData object
 * @j: column index
 *
 * Replaces vartable_element_get.  Should eventually become private.
 */
public vartabled*
get_vartable (self, guint j)
{
  g_return_val_if_fail(j < self->ncols, NULL);
  
  return self->vartable[j];
}

/*
 * set_vartable:
 * Set variable meta data for specified column
 *
 * @self: #GGobiData object
 * @j: column index
 *
 * Should eventually become private.
 */
public void
set_vartable (self, guint j, vartabled* value)
{
  self->vartable[j] = value;
}


// All the API functions work with value, so you never need
// worry about the actual position in the array
public gchar  
get_col_n_levels(self, guint j)
{
  vartabled *vt = self_get_vartable(self, j);
  g_return_val_if_fail(self_get_col_type(self, j) == categorical, 0);  
  
  return(vt->nlevels);
}

public gchar* 
get_col_level_name(self, guint j, guint value)
{
  vartabled *vt = self_get_vartable(self, j);
  gint i = self_get_col_level_for_value(self, j, value);

  g_return_val_if_fail(self_get_col_type(self, j) == categorical, NULL);
  
  if (i == -1) return g_strdup("MISSING");
  return(g_strdup(vt->level_names[i]));
}

public guint  
get_col_level_count(self, guint j, guint value)
{
  vartabled *vt = self_get_vartable(self, j);
  gint i = self_get_col_level_for_value(self, j, value);

  g_return_val_if_fail(self_get_col_type(self, j) == categorical, 0);  

  if (i == -1)  return 0;
  return(vt->level_counts[i]);
}

/*
 * get_col_level_value_closest: 
 * Get closest level value
 *
 * @self: #GGobiData object
 * @j: column index
 * @value: target value to search for 
 *
 * For a categorical categorical, this searches through all level
 * values and returns the level value that is closest to the desired
 * value.  Currently seems a little buggy in that it prefers one 
 * direction over another
 *
 * Returns: closest level value to target value
 *
*/
public guint  
get_col_level_value_closest(self, guint j, guint value)
{
  vartabled *vt = self_get_vartable(self, j);
  g_return_val_if_fail(self_get_col_type(self, j) == categorical, 0);  

  guint k, level = 0, dist = 0, ddist = G_MAXUINT;
  for (k = 0; k < vt->nlevels; k++) {
    dist = fabs ((greal) vt->level_values[k] - value);
    if (dist < ddist) {
        level = k;
        ddist = dist;
    }
  }

  return vt->level_values[level];
}

public guint
get_col_level_value(self, guint j, guint k) {
  vartabled *vt = self_get_vartable(self, j);
  return vt->level_values[k];
}

/*
 * get_col_max:
 * Find the biggest value in the column.
 *
 * @self: #GGobiData object
 * @j: column index
 * 
 * For numerical columns, value is cached by limits_set()
 * Does the right thing for categorical variables too.  
 */
public gfloat
get_col_max(self, guint j)
{
  vartabled *vt = self_get_vartable(self, j);
  guint level_value, level_value_max=G_MININT, i;

  if (self_get_col_type(self, j) != categorical) {
    return vt->lim.max;
  }

  if (vt->nlevels && vt->nlevels > 0) {
    level_value_max = vt->level_values[0];
    for (i = 0; i < vt->nlevels; i++) {
      level_value = vt->level_values[i];
      if (level_value > level_value_max)
        level_value_max = level_value;
    }
  }
  
  return(gfloat) level_value_max;
}


/*
 * get_col_min:
 * Find the smallest value in the column.
 *
 * @self: #GGobiData object
 * @j: column index
 * 
 * For numerical columns, value is cached by limits_set()
 * Does the right thing for categorical variables too.
 */
public gfloat
get_col_min(self, guint j)
{
  vartabled *vt = self_get_vartable(self, j);
  guint level_value, level_value_min=G_MAXINT, i;

  if (self_get_col_type(self, j) != categorical) {
    return vt->lim.min;
  }

  if (vt->nlevels && vt->nlevels > 0) {
    level_value_min = vt->level_values[0];
    for (i = 0; i < vt->nlevels; i++) {
      level_value = vt->level_values[i];
      if (level_value < level_value_min)
        level_value_min = level_value;
    }
  }
  
  return(gfloat) level_value_min;

}

public gfloat
get_col_range(self, guint j)
{
  vartabled *vt = self_get_vartable(self, j);
  return vt->lim.max - vt->lim.min;
}

public gfloat
get_col_mean(self, guint j)
{
  vartabled *vt = self_get_vartable(self, j);
  return vt->mean;
}

private void
add_col_level(self, guint j, const gchar *name, gint value)
{
  vartabled *vt = self_get_vartable(self, j);
  guint level = vt->nlevels++;
  if (vt->nlevels == 1) {
    vt->level_values = (gint *)   g_malloc (sizeof (gint));
    vt->level_counts = (gint *)   g_malloc (sizeof (gint));
    vt->level_names  = (gchar **) g_malloc (sizeof (gchar *));
  } else {
    vt->level_values =
      (gint *) g_realloc (vt->level_values, sizeof (gint) * vt->nlevels);
    vt->level_counts =
      (gint *) g_realloc (vt->level_counts, sizeof (gint) * vt->nlevels);
    vt->level_names =
      (gchar **) g_realloc (vt->level_names, sizeof (gchar *) * vt->nlevels);
  }
  vt->level_counts[level] = 1;
  if (value == -1)
    value = level+1;
  vt->level_values[level] = value;
  if (!name)
    vt->level_names[level] = g_strdup_printf("%d", value);
  else vt->level_names[level] = g_strdup(name);
  g_hash_table_insert(vt->name_to_level, vt->level_names[level], 
    GINT_TO_POINTER(level));
  g_hash_table_insert(vt->value_to_level, GINT_TO_POINTER(vt->level_values[level]), 
    GINT_TO_POINTER(level));
}
  
public void  
set_col_levels(self, guint j, guint levels, gchar** names, guint* values, guint* counts)
{
  guint i;
  vartabled *vt = self_get_vartable(self, j);

  self_set_col_type(self, j, categorical);  

  vt->vartype = categorical;
  vt->nlevels = levels;
  vt->level_names = (gchar **) g_malloc(sizeof(gchar*) * levels);
  vt->level_values = (guint *) g_malloc(sizeof(guint) * levels);
  vt->level_counts = (guint *) g_malloc(sizeof(guint) * levels);
  for(i = 0; i < levels; i++) {
    vt->level_names[i]  = g_strdup(names[i]);
    vt->level_counts[i] = (counts) ? counts[i] : 0;
    vt->level_values[i] = (values) ? values[i] : i+1;
    g_hash_table_insert(vt->name_to_level, vt->level_names[i], 
      GINT_TO_POINTER(i));
    g_hash_table_insert(vt->value_to_level, GINT_TO_POINTER(vt->level_values[i]), 
      GINT_TO_POINTER(i));
 }
}

/*
 * get_string_value
 * Get string representation of value
 *
 * @self: #GGobiData object
 * @self: row
 * @self: column
 * @self: transformed or raw values?
 *
 * This currently returns a locale insensitive string, suitable for
 * output into csv etc.  It may be sub-optimal for user display.
 */
public gchar*
get_string_value(self, guint i, guint j, gboolean transformed) 
{
  guint lval = -1;
  vartabled *vt = self_get_vartable(self, j);
  gdouble raw = transformed ? self->tform.vals[i][j] : self->raw.vals[i][j];
  
  if (self_is_missing(self, i, j)) 
    return g_strdup("NA");

  if (vt->vartype != categorical) {
    gchar *buf = g_new(gchar, G_ASCII_DTOSTR_BUF_SIZE);
    g_ascii_dtostr(buf, G_ASCII_DTOSTR_BUF_SIZE, raw);
    return buf;
  }
    return g_strdup_printf("%g", raw);
  
  lval = self_get_col_level_for_value(self, j, (gint)raw);
  if (lval == -1) {  //useful for debugging
    g_warning ("Levels for %s specified incorrectly", vt->collab);
    return g_strdup_printf("%g", raw);
  }
  
  return g_strdup(vt->level_names[lval]);
}

public gboolean 
has_edges (self) 
{
  return (self->edge.n > 0);
}

public gboolean 
has_variables (self) 
{
  return (self->ncols > 0);
}

public void
set_row_id(self, guint i, gchar* value, gboolean check) {
  if (value == NULL)
    value = g_strdup_printf("%d", i+1);

  self->rowIds[i] = g_strdup(value);
  g_hash_table_insert (self->idTable, self->rowIds[i], GINT_TO_POINTER(i));
}

public gchar*
get_row_id(self, guint i) {
  return g_strdup(self->rowIds[i]);
}

public guint 
get_row_by_id(self, gchar *id) {
  gpointer pos = g_hash_table_lookup(self->idTable, id);
  if (pos == NULL)
    return -1;
  return GPOINTER_TO_INT(pos);
}

/*
 * add_rows: 
 * Add n rows to the dataset
 * 
 * @self: #GGobiData object
 * @n: number of rows to add
 *
 * Adds extra rows, allocating space as needed.
 *
 * This emits the rows_added signal.  Listeners to this signal should
 * assume that there is no useful data in any of the new rows, and it should
 * be mainly for allocating space in other places.
 *
 * Returns: row index of first new row
 */
public guint
add_rows(self, guint n) {
  gint def_color = self->gg ? self->gg->color_id : 0;
  gint def_type  = self->gg ? self->gg->glyph_id.type : FC;
  gint def_size =  self->gg ? self->gg->glyph_id.size : 1;
  guint i, nprev = self->nrows;
  self->nrows += n;

  self->rowIds = (gchar **) g_realloc (self->rowIds, sizeof(gchar *) * self->nrows);
  vectorb_realloc (&self->excluded, self->nrows);
  vectorb_realloc (&self->hidden, self->nrows);
  vectorb_realloc (&self->hidden_now, self->nrows);
  vectorb_realloc (&self->hidden_prev, self->nrows);
  vectorb_realloc (&self->pts_under_brush, self->nrows);
  vectorb_realloc (&self->sampled, self->nrows);
  vectorg_realloc (&self->glyph, self->nrows);
  vectorg_realloc (&self->glyph_now, self->nrows);
  vectorg_realloc (&self->glyph_prev, self->nrows);
  vectori_realloc (&self->rows_in_plot, self->nrows);
  vectori_realloc (&self->clusterid, self->nrows);
  vectors_realloc (&self->color, self->nrows);
  vectors_realloc (&self->color_now, self->nrows);
  vectors_realloc (&self->color_prev, self->nrows);

  arrayf_add_rows (&self->raw, self->nrows);
  arrayf_add_rows (&self->tform, self->nrows);
  arrayg_add_rows (&self->jitdata, self->nrows);
  arrayg_add_rows (&self->world, self->nrows);
  arrays_add_rows (&self->missing, self->nrows);

  for (i = nprev; i < self->nrows; i++) {    
    self->color.els[i] = def_color;
    self->color_now.els[i] = def_color;
    self->color_prev.els[i] = def_color;
    self->excluded.els[i] = false;
    self->glyph.els[i].type = def_type;
    self->glyph_now.els[i].type = def_type;
    self->glyph_prev.els[i].type = def_type;
    self->glyph.els[i].size = def_size;
    self->glyph_now.els[i].size = def_size;
    self->glyph_prev.els[i].size = def_size;
    self->hidden.els[i] =  false;
    self->hidden_now.els[i] = false;
    self->hidden_prev.els[i] = false;
    self->pts_under_brush.els[i] = false; 
    self->sampled.els[i] = true;
  }
  clusters_set(self);
  self_set_rows_in_plot(self);
  
  self_rows_added(self, n);
  return nprev;
}


/* 
 * add_cols:
 * Add n empty rows to the dataset.
 *
 * @self: #GGobiData object
 * @n: number of rows to add
 *
 */ 
public guint 
add_cols(self, guint n) {
  guint nprev = self->ncols;
  self->ncols += n;

  self->vartable = (vartabled **) g_realloc (self->vartable, sizeof(vartabled *) * self->ncols);
  for(guint j = nprev; j < self->ncols; j++) {
    vartabled *vt = vartable_element_new(self);
    self_set_vartable(self, j, vt);
  } 
  arrayf_add_cols (&self->raw, self->ncols);
  arrayf_add_cols (&self->tform, self->ncols);
  arrayg_add_cols (&self->jitdata, self->ncols);
  arrayg_add_cols (&self->world, self->ncols);
  arrays_add_cols (&self->missing, self->ncols);

  tour_realloc_up (self, self->ncols);

  self_cols_added(self, n);
  
  return nprev;
}

public guint
delete_cols(self, guint *cols, gint ncols)
{
  gint j;
  gint *keepers, nkeepers;
  
  g_return_val_if_fail(ncols < self->ncols, self->ncols);

  // FIXME: shouldn't find_keepers be able to handle this allocation??
  keepers = g_malloc ((self->ncols - ncols) * sizeof (gint));
  nkeepers = find_keepers (self->ncols, ncols, cols, keepers);
  if (nkeepers == -1) {
    g_free (keepers);
    g_return_val_if_reached(self->ncols);
  }
  
  for (j = 0; j < nkeepers; j++) {
    vartabled *vt = self_get_vartable(self, keepers[j]);
    self_set_vartable(self, j, vt);
  }

  self->vartable = g_renew(vartabled*, self->vartable, nkeepers);
  
  //FIXME: need function analogous to tour_relloc_up
  tour2d_realloc_down (ncols, cols, self, self->gg);
  tour1d_realloc_down (ncols, cols, self, self->gg);
  tourcorr_realloc_down (ncols, cols, self, self->gg);

  arrayf_delete_cols (&self->raw, ncols, cols);
  arrayf_delete_cols (&self->tform, ncols, cols);
  arrayg_delete_cols (&self->jitdata, ncols, cols);
  arrayg_delete_cols (&self->world, ncols, cols);
  arrays_delete_cols (&self->missing, ncols, cols);
  
  self->ncols -= ncols;
  
  for (j = 0; j < ncols; j++) /* emit col deleted signal */
    self_col_deleted(self, cols[j]);
  
  /*-- emit a single variable_list_changed signal when finished --*/
  /*-- doesn't need to give a variable index any more, really --*/
  // FIXME: emission of this is deprecated
  g_signal_emit (G_OBJECT (self->gg),
                 GGobiSignals[VARIABLE_LIST_CHANGED_SIGNAL], 0, self);

    /*-- run the first part of the pipeline  --*/
  tform_to_world(self);
                 
  g_free (keepers);
  
  return(self->ncols);
}

// also need delete_cols and delete_rows

public void
free (self) 
{
  vectorb_free (&self->excluded);
  vectorb_free (&self->hidden);
  vectorb_free (&self->hidden_now);
  vectorb_free (&self->hidden_prev);
  vectorb_free (&self->pts_under_brush);
  vectorb_free (&self->sampled);
  vectorg_free (&self->glyph);
  vectorg_free (&self->glyph_now);
  vectorg_free (&self->glyph_prev);
  vectori_free (&self->rows_in_plot);
  vectori_free (&self->clusterid);
  vectors_free (&self->color);
  vectors_free (&self->color_now);
  vectors_free (&self->color_prev);

  arrayf_free (&self->raw, self->nrows, self->ncols);
  arrayf_free (&self->tform, self->nrows, self->ncols);
  arrayg_free (&self->jitdata, self->nrows, self->ncols);
  arrayg_free (&self->world, self->nrows, self->ncols);
  arrays_free (&self->missing, self->nrows, self->ncols);

  for (gint j = self->ncols-1; j >= 0; j--) {
    vartabled *vt = self_get_vartable(self, (guint)j); 
    if (vt->collab != NULL) g_free (vt->collab);
    if (vt->collab_tform != NULL) g_free (vt->collab_tform);
    g_hash_table_destroy(vt->name_to_level);
    g_hash_table_destroy(vt->value_to_level);
    g_free(vt);
  }
  g_free (self->vartable);

  if(self->idTable) {
    //g_hash_table_foreach(self->idTable, freeLevelHashEntry, self->idTable);
    g_hash_table_destroy(self->idTable); 
  }
  g_free(self->rowIds);
  g_free(self);
}

public void 
attach (self, ggobid *gg, gboolean cleanup)
{
  self->gg = gg;
  gg->d = g_slist_append (gg->d, self);
  displayd *display = NULL;

  gint *vars = (gint *) g_malloc(self->ncols * sizeof(gint));
  
  self->brush.bin0.x = self->brush.bin1.x = BRUSH_NBINS;
  self->brush.bin0.y = self->brush.bin1.y = BRUSH_NBINS;

  gint iv, ih;
  self->brush.nbins = BRUSH_NBINS;

  edgeedit_init (self->gg);
  if (self->edge.n)
    vectorb_realloc (&self->edge.xed_by_brush, self->edge.n);

  /* binning the plot window; no need to realloc these */
  self->brush.binarray = (bin_struct **)
    g_malloc (self->brush.nbins * sizeof (bin_struct *));
  for (ih = 0; ih < self->brush.nbins; ih++) {
    self->brush.binarray[ih] = (bin_struct *)
      g_malloc (self->brush.nbins * sizeof (bin_struct));

    for (iv = 0; iv < self->brush.nbins; iv++) {
      self->brush.binarray[ih][iv].nels = 0;
      self->brush.binarray[ih][iv].nblocks = 1;
      self->brush.binarray[ih][iv].els = (gulong *)
        g_malloc (BINBLOCKSIZE * sizeof (gulong));
    }
  }

  /*
   * If there are missings, they've been initialized with a value
   * of 0.  Here, re-set that value to 15% below the minimum for each
   * variable.  (dfs -- done at Di's request, September 2004)
   */
  limits_set (self, true, true, self->gg->lims_use_visible);
  for (guint j = 0; j < self->ncols; j++) vars[j] = j;
  impute_fixed (IMP_BELOW, 15.0, self->ncols, vars, self);
  g_free(vars);

  clusters_set(self);  /*-- find the clusters for data just read in --*/

  display_menu_build (gg);
  
  // Set up variable table and listen to important events
  self_connect__col_data_changed(self, vartable_stats_set_by_var, NULL);
  self_connect__col_data_changed(self, vartable_limits_set_by_var, NULL);
  self_connect__col_name_changed(self, vartable_collab_set_by_var, NULL);
  self_connect__col_name_changed(self, vartable_collab_tform_set_by_var, NULL);

  varcircles_populate (self, gg);
  self_connect__col_name_changed(self, varcircle_label_set, NULL);

  if (cleanup)
    varpanel_clear (self, gg);
  varpanel_populate (self, gg);   
  if (gg->current_display != NULL)
    varpanel_refresh (gg->current_display, gg);
  if (g_slist_index(gg->d, (gpointer)self) == 0)
    varpanel_set_sensitive (self, true, gg);
  self_connect__col_name_changed(self, varpanel_label_set, NULL);

  
  if (cleanup || g_list_length(gg->displays) == 0) {
    display_free_all (gg);  /*-- destroy any existing displays --*/
    gg->pmode = NULL_PMODE;

    /*-- initialize the first display --*/
    if(sessionOptions->info->createInitialScatterPlot && self->ncols > 0) {
      display = scatterplot_new (false, NULL, self, gg);

      gg->displays = g_list_append (gg->displays, (gpointer) display);
      gg->current_splot = (splotd *)
      g_list_nth_data (display->splots, 0);
      display->current_splot = gg->current_splot;
      display_set_current (display, gg);

      sp_event_handlers_toggle (gg->current_splot, on, gg->pmode, gg->imode);
    }
  }
  g_signal_emit_by_name (G_OBJECT (gg), "datad_added", self);
}

/*
 * set_rows_in_plot:
 *
 * @self: #GGobiData object
 *
 * Combine the values in two arrays:
 *   excluded[] (which comes from the exclusion panel or from linking)
 *   sampled[] (which come from the subset panel)
 * to determine which cases should be plotted.
 *
 * rows_in_plot = sampled && !excluded
*/
public void
set_rows_in_plot(self)
{
  guint i;
  self->nrows_in_plot = 0;

  for (i = 0; i < self->nrows; i++)
    if (self->sampled.els[i] && !self->excluded.els[i])
      self->rows_in_plot.els[self->nrows_in_plot++] = i;
  
  self_rows_in_plot_changed(self, (guint) self->nrows_in_plot); 
}

}
