%h{

#include "input-source.h"
#include "ggobi-variable.h"
#include "ggobi-stage.h"
#include "fileio.h"

#include <math.h>

/* used for variable notebooks - this will go in variable_nbook.h */
typedef enum {no_edgesets, edgesets_only, all_datatypes} datatyped;

%}

%{
#include "vars.h"
#include "externs.h"
%}

/**
 * SECTION:GGobiData
 * @short_description: Basic data storage and manipulation class.
 * @stability: Unstable
 *
 * The GGobiData class provides all methods for manipulating 
 * data within GGobi.  It is the starting point for the pipeline.
 * 
 * Eventually this will become an abstract class and subclass will
 * provide the actual implementation.  This will make it easy to treat
 * an R data frame, or a SQL query as the data source for GGobi.
 */
class GGobi:Data from GGobi:Stage {

public gchar *nickname;
property STRING nickname
  (nick = "alias", blurb = "The nickname of the dataset",
   default_value = "dataset", link, export);

/* A description of the source of the GGobiData */
// FIXME: should probably be CONSTRUCT_ONLY - why change the source?
private GGobiInputSource *source;
property OBJECT source
  (nick = "origin", blurb = "A representation of the source of this dataset",
   object_type = GGobi:Input:Source, type = GGobiInputSource *, link, export);

/* The actual data in this default implementation */
protected array_f raw;
/* Tracking missing values per cell */
protected array_s missing; 

/* Maps row labels to row indices */
protected GHashTable* idTable = {
  g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL)
} destroywith g_hash_table_destroy;

/* The row ids */
protected gchar **rowIds destroywith g_free;

/* We'll fix edge/polygon stuff after pipeline */
protected EdgeData  edge;

init(self) {
  ggobi_stage_set_name(GGOBI_STAGE(self), "unknown"); 
}

/** 
 * new:
 * @nrows: number of rows
 * @ncols: number of columns
 *
 * Create new #GGobiData object
 * 
 * Returns: #GGobiData object
 **/
public GGobiData* 
new(guint nrows, guint ncols)
{
  GObject* d = (GObject *)GET_NEW;
  self_add_cols(GGOBI_DATA(d), ncols);
  self_add_rows(GGOBI_DATA(d), nrows);

  return(GGOBI_DATA(d));
}

// FIXME: this stuff is _G_Gobi-specific, so it has to be added to every
// GGobiData that participates in _G_Gobi, regardless of source.
// Thus, this should probably be done when the GGobiData is added to the 
// GGobiApp (GGobiSession) object.
  /**
   * add_attributes:
   * @self: a #GGobiData
   *
   * Add the default GGobi attributes to a dataset. This will go away soon.
   *
   */
public void
add_attributes(self) {
  GGobiStage *stage = GGOBI_STAGE(self);
  gdouble def_color = (gdouble) (stage->gg ? stage->gg->color_id : 0);
  gdouble def_type  = (gdouble) (stage->gg ? stage->gg->glyph_id.type : FC);
  gdouble def_size =  (gdouble) (stage->gg ? stage->gg->glyph_id.size : 1);
  
  // FIXME: we set the default value here, even though the GGobiSession fields
  // change to match the current brush colour
  self_add_attribute(self, "_color", def_color);
  self_add_attribute(self, "_color_now", def_color);
  self_add_attribute(self, "_color_prev", def_color);

  self_add_attribute(self, "_size", def_size);
  self_add_attribute(self, "_size_now", def_size);
  self_add_attribute(self, "_size_prev", def_size);

  self_add_attribute(self, "_type", def_type);
  self_add_attribute(self, "_type_now", def_type);
  self_add_attribute(self, "_type_prev", def_type);

  self_add_attribute(self, "_hidden", 0);
  self_add_attribute(self, "_hidden_now", 0);
  self_add_attribute(self, "_hidden_prev", 0);

  self_add_attribute(self, "_cluster", 0);
  self_add_attribute(self, "_sampled", (gdouble) true);
  self_add_attribute(self, "_excluded", (gdouble) true);

} 

/**
 * add_attribute:
 * @self: GGobiData object
 * @name: attribute name (should begin with _)
 * @value: default value
 *
 * Adds a new attribute column with specified name and default value.
 **/
public void 
add_attribute(self, const gchar* name, gdouble value) {
  GGobiStage *stage = GGOBI_STAGE(self);

  if (ggobi_stage_get_col_index_for_name(stage, name) != -1)
    return;
  // FIXME: inefficient..
  guint j = self_add_cols(self, 1);
  stage->n_attributes += 1;

  ggobi_stage_set_col_name(stage, j, name);
  self_set_col_default_value(self, j, value);	
  
  for(guint i = 0; i < ggobi_stage_get_n_rows(stage); i++) {
    ggobi_stage_set_raw_value(stage, i, j, value);
  }

  GGobiVariable* vt = ggobi_stage_get_variable(stage, j);
  vt->is_attribute = true;
}

  /**
   * set_col_default_value:
   * @self: a #GGobiData
   * @j: column index
   * @value: default value for the column
   *
   * When a new row is added, its column needs a default value.
   *
   */
public void 
set_col_default_value(self, guint j, gdouble value)
{
  GGobiVariable* vt = ggobi_stage_get_variable(GGOBI_STAGE(self), j);
  ggobi_variable_set_default_value(vt, value);
}

  /**
   * get_col_default_value:
   * @self: a #GGobiData
   * @j: column index
   *
   * Gets the default value for the column.
   *
   * Returns: default value
   */
public gdouble
get_col_default_value(self, guint j)
{
  GGobiVariable* vt = ggobi_stage_get_variable(GGOBI_STAGE(self), j);
  return ggobi_variable_get_default_value(vt);
}

override (GGobi:Stage) void
set_missing(GGobi:Stage *self (check null type), guint i, guint j)
{
  // FIXME: would be nice to treat all variables types the same wrt missingness
  if (GGOBI_STAGE_IS_COL_CATEGORICAL(self, j)) {
    ggobi_stage_set_categorical_value(self, i, j, "MISSING");
    return;
  }
  SELF(self)->raw.vals[i][j] = 0;
  SELF(self)->missing.vals[i][j] = 1;
}

override (GGobi:Stage) gboolean
is_missing(GGobi:Stage *self, guint i, guint j) 
{
  return (SELF(self)->missing.vals[i][j] == 1);  
}

override (GGobi:Stage) void
set_raw_value(GGobi:Stage *self (check null type), guint i, guint j, gdouble value)
{
  if(GGobiMissingValue && GGobiMissingValue(value))
    ggobi_stage_set_missing(self, i, j);
  else {
    SELF(self)->raw.vals[i][j] = value;
    SELF(self)->missing.vals[i][j] = 0;
  }
}

override (GGobi:Stage) gdouble
get_raw_value(GGobi:Stage *self (check null type), guint i, guint j)
{
  return SELF(self)->raw.vals[i][j];
}

  /**
   * set_col_type:
   * @self: a #GGobiData
   * @j: column index
   * @value: the type of the column
   *
   * Sets the column type.
   *
   */
public void 
set_col_type(self, guint j, GGobiVariableType value)
{
  GGobiVariable *vt = ggobi_stage_get_variable(GGOBI_STAGE(self), j);
  ggobi_variable_set_vartype(vt, value);
}

override (GGobi:Stage) guint
get_n_edges (GGobiStage *self)
{
  return SELF(self)->edge.n; 
}

override (GGobi:Stage) EdgeData *
get_edge_data (GGobiStage *self)
{
  return &(SELF(self)->edge);
}

override (GGobi:Stage) void
set_row_id(GGobiStage *self, guint i, gchar* value) {
  if (value == NULL)
    value = g_strdup_printf("%d", i+1);
  SELF(self)->rowIds[i] = g_strdup(value);
  g_hash_table_replace (SELF(self)->idTable, SELF(self)->rowIds[i], GINT_TO_POINTER(i));
}

override (GGobi:Stage) gchar*
get_row_id(GGobi:Stage *self, guint i) {
  if (SELF(self)->rowIds[i]) 
    return g_strdup(SELF(self)->rowIds[i]);
  else
    return NULL;
}

override (GGobi:Stage) gint
get_row_for_id(GGobi:Stage *self, gchar *id) {
  gpointer pos, key;
  if (id && g_hash_table_lookup_extended(SELF(self)->idTable, id, &key, &pos))
    return GPOINTER_TO_INT(pos);
  return -1;
}

/**
 * add_rows: 
 * @self: #GGobiData object
 * @n: number of rows to add
 *
 * Add n rows to the dataset
 * Adds extra rows, allocating space as needed.
 *
 * For convenience, this registers the row change and flushes the changes.
 *
 * Returns: index of first new row
 **/
// FIXME: Most of this should happen in the outgoing message handler
public guint
add_rows(self, guint n) {
  guint i, nprev = GGOBI_STAGE(self)->n_rows;
  guint nrows = nprev + n;

  self->rowIds = (gchar **) g_realloc (self->rowIds, sizeof(gchar *) * nrows);

  arrayf_add_rows (&self->raw, nrows);
  arrays_add_rows (&self->missing, nrows);

  if (ggobi_stage_get_n_edges(GGOBI_STAGE(self)))
    vectorb_realloc (&self->edge.xed_by_brush, self->edge.n);

  for (i = nprev; i < nrows; i++) {    
    ggobi_stage_set_row_id(GGOBI_STAGE(self), i, NULL);
  }
  
  ggobi_stage_rows_added(GGOBI_STAGE(self), n);
  
  /* set default values here */
  // FIXME: this can probably be moved before rows_added emission and not
  // emit col_data_changed, once we have tform stage in place
  self_reset_rows(self, nprev, nrows);

  return nprev;
}

/**
 * reset_rows:
 * @self: #GGobiData object
 * @start: row index to start at
 * @end: row index to end at
 *
 * Resets values to their defaults for the specified 
 * rows.  This is mainly used to set default values for 
 * the attributes at the moment.
 **/ 
public void
reset_rows(self, guint start, guint end) {
  for (guint j = 0; j < GGOBI_STAGE(self)->n_cols; j++) {
    gdouble default_val = self_get_col_default_value(self, j);
    for (guint i = start; i < end; i++)
      ggobi_stage_set_raw_value(GGOBI_STAGE(self), i, j, default_val);
    ggobi_stage_col_data_changed(GGOBI_STAGE(self), j);
  }
  ggobi_stage_flush_changes_here(GGOBI_STAGE(self));
}

/**
 * add_cols:
 * @self: #GGobiData object
 * @n: number of columns to add
 *
 * Add n empty columns to the dataset.
 * For convenience, this registers the row change and flushes the changes.
 *
 * Returns: index of first new column
 **/ 
 // FIXME: This function and its siblings should probably be moved to GGobiStage,
 // and be written looking to _update_cols(). The function bodies should then
 // be moved to the outgoing message handler of GGobiData.
public guint 
add_cols(self, guint n) {
  guint nprev = GGOBI_STAGE(self)->n_cols;
  guint ncols = nprev + n;
  
  arrayf_add_cols (&self->raw, ncols);
  arrays_add_cols (&self->missing, ncols);

  ggobi_stage_cols_added(GGOBI_STAGE(self), n);
  
  /*for (guint j = nprev; j < ncols; j++)
    ggobi_stage_col_data_changed(GGOBI_STAGE(self), j);*/
  ggobi_stage_flush_changes_here(GGOBI_STAGE(self));
  
  return nprev;
}

  /**
   * delete_cols:
   * @self: a #GGobiData
   * @cols: the column indices to delete
   *
   * Deletes the specified columns from the dataset. Registers and flushes
   * the change.
   *
   * Returns: number of remaining columns.
   */
public guint
delete_cols(self, GSList *cols)
{
  /*gint j;*/
  guint /*keepers, nkeepers = 0,*/ old_ncols = GGOBI_STAGE(self)->n_cols;
  guint ncols = g_slist_length(cols);
  GGobiPipelineMessage *msg;
  
  g_return_val_if_fail(ncols <= old_ncols, old_ncols);

  /*keepers = find_keepers (old_ncols, cols, &nkeepers);
  if (nkeepers == -1) {
    g_free (keepers);
    g_return_val_if_reached(old_ncols);
  }
  
  for (j = 0; j < nkeepers; j++) {
    GGobiVariable *vt = ggobi_stage_get_variable(GGOBI_STAGE(self), keepers[j]);
    ggobi_stage_set_variable(GGOBI_STAGE(self), j, vt);
  }*/

  arrayf_delete_cols (&self->raw, cols);
  arrays_delete_cols (&self->missing, cols);
  
  msg = ggobi_stage_get_message(GGOBI_STAGE(self));
  ggobi_pipeline_message_remove_cols(msg, cols);
  
  ggobi_stage_flush_changes_here(GGOBI_STAGE(self));

  /*g_free (keepers);*/
  
  return(GGOBI_STAGE(self)->n_cols);
}
}